---
id: usaco-968
source: USACO Silver 2019 December
title: Milk Visits
author: Tanish Tyagi
---

[Official Analysis](http://www.usaco.org/current/data/sol_cowdance_silver_jan17.html)

<LanguageSection>

<CPPSection>

**Time Complexity:** $\mathcal{O}(N+M)$

We can use a DFS to create connected components from an adjacency list (which is made when we process the roads between the farms). Each connected component will contain farms that all have the same breed. 

Graph based off sample test case: <br/>
1 (H) --> 2 (H), 5 (G) <br/>
2 (H) --> 3, 4 (H) <br/>
3 (G) --> 2 (H) <br/>
4 (H) --> 2 (H) <br/>
5 (G) --> 1 (G) <br/>

NOTE: We are not going to store the breed of cow in our adjacency list. The breed is there for convenience.

Connected Components based off of graph: <br/>
components (first index is 1) = [1, 1, 2, 1, 3] <br/> <br/>
Farms 1,2, and 4 are all Holsteins and make up component 1, farm 3 makes up component 2, and farm 5 makes up component 3. 

When it comes to seeing which farmers will be happy, we just have to evalulate 3 conditions: <br/>
1. Farm $A$ and $B$ are part of the same component. If $C$ is the same breed as $A$ / $B$, then we should output 1.
2. Farm $A$ and $B$ are part of the different components. This means that the farmer will always be satisfied because the path between $A$ and $B$ contains both breeds of cows. We should output 1.
3. If case 1 and 2 are not met, then we should output 0.

```cpp
#include <bits/stdc++.h>

using namespace std;

#define maxn 100005

int n, m, cc; // cc = componentCount
int components[maxn]; //stores what component each farm is part of
string s; //holds cow breed preferences for each farmer
char pref[maxn]; //char array based of s since we are using 1-index system
vector<int> adj[maxn]; //adjacency list for representing graph

//input function
void setIO(string name, bool includeout=false) { 
    ios_base::sync_with_stdio(0); cin.tie(0); 
    freopen((name+".in").c_str(), "r", stdin); 
    if (includeout) {
        freopen((name+".out").c_str(), "w", stdout);
    }
}

void dfs(int start) {
    if (components[start] != 0) {
		//current farm has already been assigned a component b/c it has already been visited
        return;
    }
    components[start] = cc; //assign component # to farm
    for (auto next : adj[start]) {
        if (pref[start] == pref[next]) {
			//found another farm to add to our current component
            dfs(next);
        }
    }
}

int main() {
    setIO("milkvisits", true);
    string ans = "";
    cin >> n >> m;
    cin >> s;
    for (int i = 1; i < n+1; i++) {
        pref[i] = s[i-1];
    }
	//creating graph
    for (int i = 0; i < n-1; i++) {
        int a, b;
        cin >> a >> b;
        adj[a].push_back(b);
        adj[b].push_back(a);
    }
	//creating connected components
    for (int i = 1; i < n+1; i++) {
		if (components[i] == 0) {
			//add new component
			cc++;
			dfs(i);
    	}
	}
    for (int i = 0; i < m; i++) {
        int a, b;
        char c;
        cin >> a >> b >> c;
        if ((components[a] == components[b] && pref[a] == c) || components[a] != components[b]) {
            ans += '1';
        } else {
            ans += '0';
        }
    }
    cout << ans << endl;
    return 0;
}
```
</CPPSection>

</LanguageSection>
