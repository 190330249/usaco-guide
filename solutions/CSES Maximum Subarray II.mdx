---
id: cses-1671
title: CSES - Maximum Subarray II
author: Neo Wang
---

# Problem 

We are asked to find the maximum subarray with size in $[a,b]$. 

<Spoiler title="Hint 1">

We can observe that we will be performing sum range queries for our subarray.

Therefore, we should construct a prefix sum array to perform these queries.

</Spoiler>

<Spoiler title="Solution">

Notice that we are trying to maximize $\textrm{pfx}[i] - \textrm{pfx}[j]$. Since $j$ is guranteed to be within the window $[i-b,i]$, we can construct a sliding window of size b, and compute $max(\textrm{pfx}[i]-\textrm{pfx}[j])$.

Implementation using a multiset in C++:

```cpp

int N, A, B;

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0); cout.tie(0);
    re(N,A,B); //reading in variables

    vl pfx(N+1); //vector<long long>
    FOR(i, 1, N+1) { //for(int i = 1; i <= N; i++)
        int a; re(a);
        pfx[i] = a + pfx[i-1]; //construction of our prefix sum
    }

    ll ret = -LINF;
    multiset<ll> ms;

	//we can keep a sliding window of size B, then find the lowest pfx[j] using multiset
    FOR(i, A, N+1) { //for(int i = A; i <= N; ++i)
        if(i > B) ms.erase(ms.find(pfx[i-B-1])); //erase the element if size > B
        ms.insert(pfx[i-A]);
        ret = max(ret, pfx[i]-*ms.begin()); //we want to minimize ms.begin() aka pfx[j]
    }

    pr(ret, nl); //cout << ret << "\n";
}

```

</Spoiler>