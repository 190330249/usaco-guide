---
id: usaco-946
source: USACO Gold 2019 Open
title: I Would Walk 500 Miles
author: Benjamin Qi, Aryansh Shrivastava
---

## Solution 1

$\mathcal{O}(N^2)$ Prim's is intended; check the analysis.

## Solution 2

Kruskal with two iterations of counting sort passes in 1966 ms ...

```cpp
const int a = 2019201997-2019201913;
const int b = 2019201997-2019201949;

int N,K;

pi rhsh(int x) { return {x>>16,x&((1<<16)-1)}; }
int wei(int x) { return (x>>16)*a+(x&((1<<16)-1))*b; }

/**
 * Description: Disjoint Set Union with path compression
 	* and union by size. Add edges and test connectivity.
 	* Use for Kruskal's or Boruvka's minimum spanning tree.
 * Time: O(\alpha(N))
 * Source: CSAcademy, KACTL
 * Verification: *
 */

struct DSU {
	vi e; void init(int N) { e = vi(N,-1); }
	int get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }
	bool sameSet(int a, int b) { return get(a) == get(b); }
	int size(int x) { return -e[get(x)]; }
	bool unite(int x, int y) { // union by size
		x = get(x), y = get(y); if (x == y) return 0;
		if (e[x] > e[y]) swap(x,y);
		e[x] += e[y]; e[y] = x; return 1;
	}
};

/**template<class T> T kruskal(int N, vector<pair<T,pi>> ed) {
	sort(all(ed));
	T ans = 0; DSU D; D.init(N); // edges that unite are in MST
	trav(a,ed) if (D.unite(a.s.f,a.s.s)) ans += a.f;
	return ans;
}*/

const int SZ = 28121250;
int ed[SZ], res[SZ];
DSU D;

int cnt[1<<16];

int main() {
	setIO("walk");
	clock_t beg = clock();
	re(N,K); D.init(N+1);
	dbg((db)(clock()-beg)/CLOCKS_PER_SEC);
	{
		FOR(i,1,N+1) FOR(j,i+1,N+1) cnt[(a*i+b*j)&((1<<16)-1)] ++;
		int sum = 0; R0F(i,1<<16) swap(sum,cnt[i]), sum += cnt[i];
		FOR(i,1,N+1) FOR(j,i+1,N+1) res[cnt[(a*i+b*j)&((1<<16)-1)]++] = (i<<16)+j;
	}
	dbg((db)(clock()-beg)/CLOCKS_PER_SEC);
	{
		F0R(i,1<<16) cnt[i] = 0;
		FOR(i,1,N+1) FOR(j,i+1,N+1) cnt[(a*i+b*j)>>16] ++;
		int sum = 0; R0F(i,1<<16) swap(sum,cnt[i]), sum += cnt[i];
		F0R(i,N*(N-1)/2) ed[cnt[wei(res[i])>>16]++] = res[i];
	}
	dbg((db)(clock()-beg)/CLOCKS_PER_SEC);
	vi ans;
	F0R(i,N*(N-1)/2) {
		int t = ed[i];
		pi p = rhsh(t);
		if (D.unite(p.f,p.s)) ans.pb(2019201997-wei(t));
	}
	ps(ans[N-K]);
	dbg((db)(clock()-beg)/CLOCKS_PER_SEC);
}
```

## Solution 3

(By Aryansh Shrivastava) 

Since this problem has its roots in optimizing a given weight expression, we are motivated to use math.

First, we can use modular arithmetic to find a direct expression for the modular residue. The goal is to find an expression for the modular residue involving only basic operations that we will be able to optimize with mathematical techniques. Using modular arithmetic properties (negative numbers in modular arithmetic), consider the expression $\pmod{2019201997}$ to reduce the numbers:

$$2019201913x+2019201949y \equiv - 84 x - 48 y \pmod {2019201997}$$

Since $x,y$ are bounded by $N \leq 7500,$ this expression will always give a negative value whose absolute value does not exceed the modulus $2019201997.$ Thus, we can easily find an expression for the modular residue from here if we just shift up by the modulus $2019201997$ once:

$$(2019201913x+2019201949y) \, \text{mod} \, 2019201997 = 2019201997 - 84 x - 48 y.$$

Now, it remains to optimize this expression. Formally, we must find a $K$-partition of the cows such that

$$\min\limits_{x,y \, \text{in different groups}} (2019201997 - 84 x - 48 y)$$
is maximized.

Now, analyze the function's behavior: for large $x,y,$ the expression becomes small, and for small $x,y,$ the expression becomes large.

But remembering the condition that $x,y$ must be in different groups to contribute to the answer, this means that large $x,y$ should be together in the same group (to greedily avoid making the expression small) and small $x,y$ should be in different groups (to greedily make the expression large). This leads to the following greedy strategy:

Make one group with all the largest cows that can fit and $k-1$ groups with all the smallest cows. Of course, the $k-1$ smallest cows are just $1 \dots k-1,$ so this means that the other $n-(k-1)$ cows will be in the large group.

Now that we have pinpointed the optimal situation, we can find the answer by going back to the question: we want to minimize the expression. To minimize the expression, we should greedily choose the largest cows that are in different groups (since large $x,y$ make the expression smaller). Clearly, this means that we should take cow $n,$ the largest cow in the group of large cows, and $k-1,$ the largest cow not in the group of large cows.

Recall that the problem statement requires $x < y,$ so we have $x = k - 1, y = n.$ Our answer is as easy as a substitution of these values into the modular residue expression $2019201997 - 84 x - 48 y:$

$$2019201997 - 84 (k-1) - 48 n$$

Senpat's $O(1)$ code is below:

<Spoiler title="Solution">

```cpp
// source: Senpat
#include <bits/stdc++.h>
using namespace std;

int main(){
	ifstream fin ("walk.in");
	ofstream fout ("walk.out");
	int n,k; fin >> n >> k;
	int answer = 2019201997 - 48*n - 84*(k-1);
	fout << answer << endl;
}
```

</Spoiler>
