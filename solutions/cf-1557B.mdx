---
id: cf-1557B
source: Codeforces
title: Moamen and k-subarrays
author: Aadit Ambadkar
---

[Official Analysis](https://codeforces.com/blog/entry/93538)

## Solution

Consider the minimum number of needed subarrays. If this number is less than or equal to $k$ it is solvable using k subarrays.
To find the minimum number of subarrays, consider a configuration of subarrays where the number of subarrays is minimal. (Remember that the subarrays must be contiguous)
Specifically, in this configuration, consider a single subarray. The order of the elements inside the subarray never change, so the order of the elements inside the subarray is the same before and after reording the subarrays.
This means that if we know the order of the sorted elements before-hand, we can apply a greedy algorithm which tries to maximize the size of the previous subarray.

For example, in the first testcase, the ordering of the elements is like so:

<center>
<table>
	<tbody>
		<tr>
			<th>Index:</th>
			<th>0</th>
			<th>1</th>
			<th>2</th>
			<th>3</th>
			<th>4</th>
		</tr>
	</tbody>
	<tbody>
		<tr>
			<td>$\texttt{arr}[i]$</td>
			<td>6</td>
			<td>3</td>
			<td>4</td>
			<td>2</td>
			<td>1</td>
		</tr>
	</tbody>
</table>
</center>

After sorting the list looks like so:

<center>
<table>
	<tbody>
		<tr>
			<th>Index:</th>
			<th>0</th>
			<th>1</th>
			<th>2</th>
			<th>3</th>
			<th>4</th>
		</tr>
	</tbody>
	<tbody>
		<tr>
			<td>$\texttt{arr}[i]$</td>
			<td>1</td>
			<td>2</td>
			<td>3</td>
			<td>4</td>
			<td>6</td>
		</tr>
	</tbody>
</table>
</center>

We may then create a map mapping each element to the element which should be before it:

<center>
<table>
	<tbody>
		<tr>
			<th>value</th>
			<th>1</th>
			<th>2</th>
			<th>3</th>
			<th>4</th>
			<th>6</th>
		</tr>
	</tbody>
	<tbody>
		<tr>
			<td>$\texttt{map}[\texttt{value}]$</td>
			<td>$\infty$</td>
			<td>1</td>
			<td>2</td>
			<td>3</td>
			<td>4</td>
		</tr>
	</tbody>
</table>
</center>

With this map in mind, we generate the subsets as shown:

<center>
<table>
	<tbody>
		<tr>
			<th>Index:</th>
			<th className="bg-yellow-100 dark:bg-yellow-800">0</th>
			<th>1</th>
			<th>2</th>
			<th>3</th>
			<th>4</th>
		</tr>
	</tbody>
	<tbody>
		<tr>
			<td>$\texttt{arr}[i]$</td>
			<td>6</td>
			<td>3</td>
			<td>4</td>
			<td>2</td>
			<td>1</td>
		</tr>
	</tbody>
</table>
</center>

<center>
<table>
	<tbody>
		<tr>
			<th>Index:</th>
			<th className="bg-yellow-100 dark:bg-yellow-800">0</th>
			<th className="bg-green-100 dark:bg-green-800">1</th>
			<th>2</th>
			<th>3</th>
			<th>4</th>
		</tr>
	</tbody>
	<tbody>
		<tr>
			<td>$\texttt{arr}[i]$</td>
			<td>6</td>
			<td>3</td>
			<td>4</td>
			<td>2</td>
			<td>1</td>
		</tr>
	</tbody>
</table>
</center>

<center>
<table>
	<tbody>
		<tr>
			<th>Index:</th>
			<th className="bg-yellow-100 dark:bg-yellow-800">0</th>
			<th className="bg-green-100 dark:bg-green-800">1</th>
			<th className="bg-green-100 dark:bg-green-800">2</th>
			<th>3</th>
			<th>4</th>
		</tr>
	</tbody>
	<tbody>
		<tr>
			<td>$\texttt{arr}[i]$</td>
			<td>6</td>
			<td>3</td>
			<td>4</td>
			<td>2</td>
			<td>1</td>
		</tr>
	</tbody>
</table>
</center>

<center>
<table>
	<tbody>
		<tr>
			<th>Index:</th>
			<th className="bg-yellow-100 dark:bg-yellow-800">0</th>
			<th className="bg-green-100 dark:bg-green-800">1</th>
			<th className="bg-green-100 dark:bg-green-800">2</th>
			<th className="bg-red-100 dark:bg-red-800">3</th>
			<th>4</th>
		</tr>
	</tbody>
	<tbody>
		<tr>
			<td>$\texttt{arr}[i]$</td>
			<td>6</td>
			<td>3</td>
			<td>4</td>
			<td>2</td>
			<td>1</td>
		</tr>
	</tbody>
</table>
</center>

<center>
<table>
	<tbody>
		<tr>
			<th>Index:</th>
			<th className="bg-yellow-100 dark:bg-yellow-800">0</th>
			<th className="bg-green-100 dark:bg-green-800">1</th>
			<th className="bg-green-100 dark:bg-green-800">2</th>
			<th className="bg-red-100 dark:bg-red-800">3</th>
			<th className="bg-blue-100 dark:bg-blue-800">4</th>
		</tr>
	</tbody>
	<tbody>
		<tr>
			<td>$\texttt{arr}[i]$</td>
			<td>6</td>
			<td>3</td>
			<td>4</td>
			<td>2</td>
			<td>1</td>
		</tr>
	</tbody>
</table>
</center>

Thus, we need 4 subarrays at minimum.

**Time Complexity:** $\mathcal{O}(N\log N)$

<Spoiler title="Time Complexity Proof">
Sorting Requires $\mathcal{O}(N\log N)$, and repeated map insertions also require $\mathcal{O}(N\log N)$. Hence the overall time complexity is $\mathcal{O}(N\log N)$.
</Spoiler>
	
<LanguageSection>
<CPPSection>
```cpp
#include <bits/stdc++.h>
using namespace::std;

typedef long long ll;
#define F0R(i, n) for (int i = 0; i < n; i++)
#define R0F(i, n) for (int i = n-1; i >= 0; i--)
#define FOR(i, a, n) for (int i = a; i < n; i++)
#define pb push_back
#define fastio ios::sync_with_stdio(0); cin.tie(0)
#define MOD 1000000007
#define FF first
#define SS second
 
void solve() {
	int n, k; cin >> n >> k;
	int arr[n];
	int sarr[n];
	F0R(i, n) {
		cin >> arr[i];
		sarr[i]=arr[i];
	}
	map<int, int> next;
	sort(sarr, sarr+n);
	F0R(i, n-1) {
		next[sarr[i]]=sarr[i+1];
	}
	int ans = 1;
	FOR(i, 1, n) {
		if (next[arr[i-1]]!=arr[i]) ans++;
	}
	if (ans<=k) cout << "YES\n";
	else cout << "NO\n";
}
 
int main() {
	fastio;
	int t; cin >> t; while (t--) solve();
}
```
</CPPSection>
</LanguageSection>
