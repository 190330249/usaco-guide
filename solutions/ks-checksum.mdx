---
id: ks-checksum
source: Kick Start 2020 Round A
title: Check Sum 
author: Neo Wang
---

[Official Analysis](https://codingcompetitions.withgoogle.com/kickstart/round/0000000000436140/000000000068c2c3#analysis)

## Implementation

**Time Complexity:** $\mathcal{O}(N^2\log N)$

Since the official analysis is well-documented and covers the problem in its
entirety, read that first. The following notes clarify a few details of the
implementation.

- Firstly, note that the number of rows and columns is equivalent to $2N$,
  because the matrix is square. Therefore, when constructing our graph, we can
  simply add $N$ to distinguish row $i$ from column $j$.

> Of course, the problem of finding a minimum weight cycle breaking edge set is
> equivalent to the well known problem of finding a maximum weight spanning
> forest of $G$, except that we would build the complement set of edges to keep
> rather than the set of edges to remove.

- Notice that the edges that we should remove - which are highlighted in the
  diagram in red - are equivalent to any edges that are not included in the
  maximum spanning tree of graph $G$. Therefore, our answer is equivalent to the
  difference between the total sum of all the edges and the those that are in
  the maximum spanning tree.

<LanguageSection>

<CPPSection>

```cpp
// CodeSnip{Benq Template}

/**
 * Description: Disjoint Set Union with path compression
	 * and union by size. Add edges and test connectivity.
	 * Use for Kruskal's or Boruvka's minimum spanning tree.
 * Time: O(\alpha(N))
 * Source: CSAcademy, KACTL
 * Verification: *
 */

struct DSU {
	vi e; void init(int N) { e = vi(N,-1); }
	int get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }
	bool sameSet(int a, int b) { return get(a) == get(b); }
	int size(int x) { return -e[get(x)]; }
	bool unite(int x, int y) { // union by size
		x = get(x), y = get(y); if (x == y) return 0;
		if (e[x] > e[y]) swap(x,y);
		e[x] += e[y]; e[y] = x; return 1;
	}
};

template<class T> T kruskal(int N, vector<pair<T,pi>> ed) {
	sort(rall(ed));
	T ans = 0; DSU D; D.init(N); // edges that unite are in MST
	each(a,ed) if (D.unite(a.s.f,a.s.s)) ans += a.f;
	return ans;
}

void solve(int tc) {
	int n; re(n);
	V<vi> A(n, vi(n)), B(n, vi(n));
	F0R(i,n) F0R(j,n) re(A[i][j]);
	F0R(i,n) F0R(j,n) re(B[i][j]);

	vi row(n), col(n);
	re(row, col);

	V<pair<int, pi>> edges;

	int total = 0;

	F0R(i, n) F0R(j, n) {
		if(A[i][j] == -1)  {
			// n + j is used to distinguish rows from cols
			edges.pb({B[i][j], {i, n + j}});
			total += B[i][j];
		}
	}

	pr("Case #", tc, ": ", total - kruskal(2*n, edges), "\n");
}

int main() {
	setIO();

	ints(n);
	FOR(i, 1, n+1) solve(i);
}
```

</CPPSection>

</LanguageSection>
