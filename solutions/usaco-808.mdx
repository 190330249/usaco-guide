---
id: usaco-808
source: USACO Bronze 2018 February
title: Hoofball
author: Arpan Banerjee, Ryan Chou
---

[Official Analysis](http://www.usaco.org/current/data/sol_hoofball_bronze_feb18.html)

## Explanation

Let's consider the basic structure of the hoofball tournament and see if we can extract a solution from there. Assuming some cow has a ball, she passes to *exactly* one cow directly beside her. Furthermore, if some cow has a ball, she *must* pass it to another cow. We can get three important facts from this:

1. The leftmost cow in the line always passes to the cow just to the right of her
2. The rightmost cow in the line always passes to the cow just to the left of her
3. If for some cow, no ball can be passed to her by either of it's neighbors, Farmer John *must* initially give a ball to her

This leads us to the solution: for each cow, count the number of cows that can pass to her. Call this $\texttt{reach}[i]$ for a cow $i$. Then the answer is the number of cows with $0$ cows passing to her (the number of $i$ such that $\texttt{reach}[i]=0$). However, we forgot the case where there are exactly two adjacent cows passing to each other, and they each have exactly one cow passing to them. In that case, the number of cows passing to each of them is nonzero, but they need $1$ ball from Farmer John initially since they are secluded from the passings of the rest of the cows. To do this, we can keep an array $\texttt{to}$ to keep track of which cow $\texttt{to}[i]$ each cow $i$ passes to. The C++ code below takes $\mathcal{O}(N\log{N})$ time, but $\mathcal{O}(N^2)$ passes as well (the Python solution). 

## Implementation

**Time Complexity:** $\mathcal{O}(N\log{N})$
<LanguageSection>
<CPPSection>
```cpp
#include<bits/stdc++.h>
using namespace std;

// reach[i] is how many cows pass the ball to cow i
// to[i] is where does cow i pass the ball
int n, cows[100], reach[100], to[100];

int main() {
	ifstream cin("hoofball.in");
	ofstream cout("hoofball.out");
	cin >> n;
	for (int i = 0; i < n; i++) cin >> cows[i];
	if (n <= 2){
		cout << 1 << endl;
		return 0;
	}
	sort(cows, cows + n);  // O(nlogn) 
	reach[1]++; reach[n - 2]++;
	to[0] = 1; to[n - 1] = n - 2;
	for (int i = 1; i < n - 1; i++){
		if (cows[i] - cows[i - 1] <= cows[i + 1] - cows[i]){
			reach[i - 1]++;
			to[i] = i - 1;
		} else {
			reach[i + 1]++;
			to[i] = i + 1;
		}
	}
	int num_islands = 0;
	if (reach[0] == 1 && reach[1] == 1 && to[2] != 1) num_islands++;
	if (reach[n - 1] == 1 && reach[n - 2] == 1 && to[n - 3] != n - 2) num_islands++;
	
	for (int i = 2; i < n - 3; i++){
		if (reach[i] == 1 && reach[i + 1] == 1 && to[i + 2] != i + 1 && to[i - 1] != i){
			num_islands++;
		}
	}
	cout << count(reach, reach + n, 0) + num_islands << endl;
}
```
</CPPSection>

<JavaSection>
```java
import java.util.*;
import java.io.*;

public class Hoofball
	static BufferedReader in;
	static PrintWriter out;
	static {
		try {
			in = new BufferedReader(new FileReader("hoofball.in"));
			out = new PrintWriter(new FileWriter("hoofball.out"));
		} catch (IOException e) {}
	}
	public static void main(String[] args) throws IOException{
		StringTokenizer st = new StringTokenizer(in.readLine());
		int n = Integer.parseInt(st.nextToken());
		int[] cows = new int[n];
		st = new StringTokenizer(in.readLine());
		for(int i = 0; i < n; i++){
			cows[i] = Integer.parseInt(st.nextToken());
		}
		in.close();
		if(n <= 2){
			out.write(1);
			System.exit(0);
		}
		Arrays.sort(cows);
		int[] reach = new int [n]; // reach[i] is how many cows pass the ball to i
		int[] to = new int [n]; // to[i] is where does cow i pass the ball
		reach[1]++; reach[n - 2]++;
		to[0] = 1; to[n - 1] = n - 2;
		for (int i = 1; i < n - 1; i++) {
			if (cows[i] - cows[i - 1] <= cows[i + 1] - cows[i]){
				reach[i - 1]++;
				to[i] = i - 1;
			} else {
				reach[i + 1]++;
				to[i] = i + 1;
			}
		}
		int num_islands = 0;
		if (reach[0] == 1 && reach[1] == 1 && to[2] != 1) num_islands++;
		if (reach[n - 1] == 1 && reach[n - 2] == 1 && to[n - 3] != n - 2) num_islands++;
		
		for (int i = 2; i < n - 3; i++){
			if (reach[i] == 1 && reach[i + 1] == 1 && to[i + 2] != i + 1 && to[i - 1] != i){
				num_islands++;
			}
		}
		int num_zeros = 0;
		for(int i = 0; i < n; i++){
			if(reach[i] == 0){
				num_zeros++;
			}
		}
		out.print(num_zeros + num_islands);
		out.close();
	}
}
```
</JavaSection>
</LanguageSection>

**Time Complexity:** $\mathcal{O}(N^2)$
<LanguageSection>
<PySection> 
```py
import sys

sys.stdin = open('hoofball.in', 'r')
sys.stdout = open('hoofball.out', 'w')

n = int(input())
cows = sorted(list(map(int, input().strip().split())))
balls = [0] * n
ans = 0

def nearestneighbor(ind):
	lnbr, rnbr = -1, -1
	ldist, rdist = 1000, 1000
	for i in range(n):
		"""
		If the cow we're looking at is on the left
		and it's closer to the target than the previous one.
		"""
		if cows[i] < cows[ind] and cows[ind] - cows[i] < ldist:
			lnbr = i
			ldist = cows[ind] - cows[i]
	for i in range(n):
		# same thing, but for the right.
		if cows[i] > cows[ind] and cows[i] - cows[ind] < rdist:
			rnbr = i
			rdist = cows[i] - cows[ind]
	return lnbr if ldist <= rdist else rnbr
    
for i in range(n):
	# all cows who receive a ball
	balls[nearestneighbor(i)] += 1
for i in range(n):
	"""
	if the cow isn't passed to by any of the neighbors,
	then we have to give it a ball.
	"""
	if balls[i] == 0:
		ans += 1
	"""
	If we find two cows which only pass to each other,
	we have to give them one as well.
	"""
	if (i < nearestneighbor(i) and nearestneighbor(nearestneighbor(i)) == i
		and balls[i] == 1 and balls[nearestneighbor(i)] == 1):
		ans += 1
    
print(ans)
```
</PySection>
</LanguageSection>
