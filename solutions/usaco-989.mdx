---
id: usaco-989
source: USACO Bronze 2020 January
title: Race
author: Sathvik Chundru, Kevin Sheng
---

[Official Analysis (C++)](http://www.usaco.org/current/data/sol_race_bronze_jan20.html)

<LanguageSection>
<CPPSection>

```cpp
#include <iostream>
#include <fstream>

using std::cout;
using std::endl;

int fastest_time(int dist, int max_speed) {
	int lhs_travel = 0;  // Amount of distance where Bessie's speeding up
	int rhs_travel = 0;  // and slowing down respectively
	int time = 0;
	
	// Gradually speed up until we achieve our distance
	for (int curr_speed = 1; ; curr_speed++) {
		lhs_travel += curr_speed;
		time++;
		if (lhs_travel + rhs_travel >= dist) { 
			return time; 
		}

		/*
		 * If we're above the speed limit, add the current speed
		 * to the part where we slow down (the RHS) as well.
		 */
		if (curr_speed >= max_speed) {
			rhs_travel += curr_speed;
			time++;
			// Check again if we've achieved our distance
			if (lhs_travel + rhs_travel >= dist) { 
				return time; 
			}
		}
	}
}

int main() {
	std::ifstream read("race.in");
	int race_len;
	int query_num;
	read >> race_len >> query_num;

	std::ofstream written("race.out");
	for (int q = 0; q < query_num; q++) {
		int max_speed;
		read >> max_speed;
		written << fastest_time(race_len, max_speed) << '\n';
	}
}
```

</CPPSection>
<JavaSection>

```java
import java.util.*;
import java.io.*;

class Race {
	public static void main(String[] args) throws IOException {
		Scanner sc = new Scanner(new File("race.in"));
		int raceLen = sc.nextInt();
		int queryNum = sc.nextInt();

		PrintWriter pw = new PrintWriter(new File("race.out")); 
		for (int q = 0; q < queryNum; q++) {
			int maxSpeed = sc.nextInt(); 
			pw.println(fastestTime(raceLen, maxSpeed));
		}
		pw.close();
	}

	static int fastestTime(int dist, int maxSpeed) {
		int lhsTravel = 0;  // Amount of distance where Bessie's speeding up
		int rhsTravel = 0;  // and slowing down respectively
		int time = 0;

		// Gradually speed up until we achieve our distance
		for (int currSpeed = 1; ; currSpeed++) {
			lhsTravel += currSpeed;
			time++;
			if (lhsTravel + rhsTravel >= dist) { 
				return time; 
			}

			/*
			 * If we're above the speed limit, add the current speed
			 * to the part where we slow down (the RHS) as well.
			 */
			if (currSpeed >= maxSpeed) {
				rhsTravel += currSpeed;
				time++;
				// Check again if we've achieved our distance
				if (lhsTravel + rhsTravel >= dist) { 
					return time; 
				}
			}
		}
	}
}
```

</JavaSection>
</LanguageSection>
