---
id: usaco-712
source: USACO Bronze 2017 February
title: Why Did the Cow Cross the Road II
author: Benjamin Qi, Danh Ta Chi Thanh
---

## Solution 1

[Official Analysis](http://www.usaco.org/current/data/sol_circlecross_bronze_feb17.html)

## Solution 2

Let the first occurrence of a letter be the cow's entry and the last occurrence her exit. Then, we count the number of pairs $(cow_1, cow_2)$ such that $cow_1$ enters before $cow_2$ and leaves somewhere between $cow_2$'s entry and exit. 

In other words, we define $start_x$, $end_x$, as the entry and exit points of a $cow_x$, where $start_x$ is the index of the first occurrence of $cow_x$ and $end_x$ is the index of the last occurrence of $cow_x$. Thus, we count the number of pairs of cows $(x, y)$ such that $start_x$ < $start_y$ < $end_x$ < $end_y$.

**Time Complexity:** $\mathcal{O}(N^4)$ (where $N$ is the number of cows)

Alternatively, we can store the positions of entry points and exit points in another arrays in order to reduce the **Time Complexity** to  $\mathcal{O}(N^2)$. 

<LanguageSection>

<CPPSection>

## C++ Implementation

Naive $\mathcal{O}(N^4)$ solution

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	ios_base::sync_with_stdio(0); cin.tie(0);
	freopen("circlecross.in","r",stdin);
	freopen("circlecross.out","w",stdout);
	string s; cin >> s;
	int ans = 0;
	for (int a = 0; a < s.size(); ++a) 
		for (int b = a+1; b < s.size(); ++b) 
			for (int c = b+1; c < s.size(); ++c) 
				for (int d = c+1; d < s.size(); ++d) 
					ans += s[a] == s[c] && s[b] == s[d];
	cout << ans;
	return 0;
}
```

Optimized $\mathcal{O}(N^2)$ solution

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	ios_base::sync_with_stdio(0); cin.tie(0);
	freopen("circlecross.in","r",stdin);
	freopen("circlecross.out","w",stdout);
	string s; cin >> s;
	int enter[26], exit[26];
	//Set all elements of enter and exit arrays to -1.
	memset(enter,-1,sizeof(enter));
	memset(exit,-1,sizeof(exit));
	for (int i = 0; i < s.size(); ++i) {
		if (enter[s[i]-'A'] == -1) enter[s[i]-'A'] = i;
		else exit[s[i]-'A'] = i;
	}
	int ans = 0;
	for (int i = 0; i < 26; ++i)
		for (int j = 0; j < 26; ++j)
			ans +=  enter[i] < enter[j] && enter[j] < exit[i] && exit[i] < exit[j];
	cout << ans;
	return 0;
}

```

</CPPSection>

</LanguageSection>
