---
id: usaco-712
source: USACO Bronze 2017 February
title: Why Did the Cow Cross the Road II
author: Benjamin Qi, Danh Ta Chi Thanh
---

## Solution 1

[Official Analysis](http://www.usaco.org/current/data/sol_circlecross_bronze_feb17.html)

## Solution 2

Let the first occurrence of a letter be the cow's entry and the last occurrence her exit. Then, we count the number of pairs $(cow_1, cow_2)$ such that $cow_1$ enters before $cow_2$ and leaves somewhere between $cow_2$'s entry and exit. 

In other words, we define $start_x$, $end_x$, as the entry and exit points of a $cow_x$, where $start_x$ is the index of the first occurrence of $cow_x$ and $end_x$ is the index of the last occurrence of $cow_x$. Thus, we count the number of pairs of cows $(x, y)$ such that $start_x$ < $start_y$ < $end_x$ < $end_y$.

**Time Complexity:** $\mathcal{O}(N^4)$ (where $N$ is the number of cows)

Alternatively, we can store the positions of entry and exit points for each of the cows. Then, we can loop through all pairs of cows and see if they cross based on their entry and exit points. This runs in $\mathcal O(N^2)$.

<LanguageSection>

<CPPSection>

## C++ Implementation

Naive $\mathcal{O}(N^4)$ solution

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	ios_base::sync_with_stdio(0); cin.tie(0);
	freopen("circlecross.in","r",stdin);
	freopen("circlecross.out","w",stdout);
	string s; cin >> s;
	int ans = 0;
	for (int a = 0; a < s.size(); ++a) 
		for (int b = a+1; b < s.size(); ++b) 
			for (int c = b+1; c < s.size(); ++c) 
				for (int d = c+1; d < s.size(); ++d) 
					ans += s[a] == s[c] && s[b] == s[d];
	cout << ans;
	return 0;
}
```

Optimized $\mathcal{O}(N^2)$ solution

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	ios_base::sync_with_stdio(0); cin.tie(0);
	freopen("circlecross.in","r",stdin);
	freopen("circlecross.out","w",stdout);
	string s; cin >> s;
	int Start[26], Exit[26];
	//Set all elements of Start and End arrays to -1.
	memset(Start,-1,sizeof(Start));
	memset(End,-1,sizeof(End));
	for (int i = 0; i < s.size(); ++i) {
		if (Start[s[i]-'A'] == -1) Start[s[i]-'A'] = i;
		else End[s[i]-'A'] = i;
	}
	int ans = 0;
	for (int i = 0; i < 26; ++i)
		for (int j = 0; j < 26; ++j)
			ans +=  Start[i] < Start[j] && Start[j] < End[i] && End[i] < End[j];
	cout << ans;
	return 0;
}
```

<Info title="Useful functions for initializing array values">

In this problem, you can use `std::fill` instead of `memset` with no significant difference. However, with large arrays (i.e. arrays with $10^5$ or $10^6$ elements) it seems that `memset` is [more efficient](https://lemire.me/blog/2020/01/20/filling-large-arrays-with-zeroes-quickly-in-c/) than `std::fill`.

</Info>

<Warning>

Make sure you know what `memset` actually does before using it! `memset` treats the value that is passed to it as an `unsigned char`. So for an array of 32-bit integers, `memset(arr, -1, sizeof arr)` will set each element to $-1$, as you might expect. However, `memset(arr, 1, sizeof arr)` will set each element to $1+2^8+2^{16}+2^{24}=16843009$, not $1$. Note that if you want to initialize the whole array to some values that is neither 0 nor -1, you can write a single `for` loop or use `std::fill` to do that.

</Warning>

</CPPSection>

</LanguageSection>
