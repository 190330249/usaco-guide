---
id: ac-MultipleOf2019
source: AtCoder Beginner Contest
title: Multiple of 2019
author: Maggie Liu, Brad Ma, Mohammad Nour Massri, David Zhang
---

[Official Analysis](https://img.atcoder.jp/abc164/editorial.pdf#page=10)

## Explanation
First of all, in order to store sections of the string, we can make a suffix array with the condition that at index $$i$$ in suffix array $${S}$$

$${S_i = s_n + 10*s_{n-1} +100*s_{n-2} + ... + {10^{n-i}} * s_{i}}$$

For example, in the string "1234", the suffix array would be

[1234, 234, 34, 4]

This is useful because we can query any substring in $\mathcal{O}(1)$ time. So if $${S_0} = 1234 $$ and $${S_3=4}$$, this means $${S_0}-{S_3} = 123 * {10^1}$$ or $$1230$$. 

It also means that if both $${S_0}(mod$$ $$M)=$$ $${S_3}(mod$$ $$M)$$, subtracting would lead to $${S_0}(mod$$ $$M)-$$ $${S_3}(mod$$ $$M)=0$$, meaning a substring that makes a number that is divisible by $$M$$ or $$2019$$. 

So then we can use $${N \choose K}$$ choose formula, and choose 2 numbers $$(2)$$ that are divisible by the same reminder of 2019 $$(N)$$. 

We can then store all the counts of all the remainders from $$0...2018$$. Then, we can add all $${N \choose 2}$$ and that is our answer. 

(Note: A prefix array can be utilized as well, but a suffix array is easier to implement)

Errichto's Video
<Youtube id="https://www.youtube.com/watch?v=83yW2Pp6HMk" />
## Implementation

**Time Complexity:** $\mathcal{O}(N)$

<LanguageSection>

<CPPSection>

```cpp
#include <iostream>
using namespace std;

int main()
{
	string s;
	cin >> s;
	int num = 0, n = s.size(), pow = 1;
	//initializes array with initializer list
	//explained here: https://www.learncpp.com/cpp-tutorial/arrays-part-ii/
	int count[2019]{1};
	for (int i = n - 1; i >= 0; i--)
	{
		//find the remainder of the current number mod 2019
		num = (num + pow * (s[i] - '0')) % 2019;
		//increment the count of this remainder
		count[num]++;
		pow = pow * 10 % 2019;
	}
	long long ans = 0;
	for (int i = 0; i < 2019; i++)
	{
		//there are nC2 ways to pair the numbers with the same remainder
		ans += (long long)count[i] * (count[i] - 1) / 2;
	}
	cout << ans << endl;
	return 0;
}
```

</CPPSection>
	
<JavaSection>
	
```java
import java.io.*;
import java.util.*;

public class MultipleOf2019 {
	public static void main (String[] args) {
		Kattio io = new Kattio();
		String numberString = io.next();
		int num = 0;
		int stringLength = numberString.length();
		int pow = 1;
		int[] count = new int[2019];
		count[0] = 1;

		for (int i = stringLength - 1; i >= 0; i--) {
			// find the remainder of the current number mod 2019
			num = (num + pow * (numberString.charAt(i) - '0')) % 2019;
			// increment the count of this remainder
			count[num]++;
			pow = pow * 10 % 2019;
		}
		long answer = 0;
		for (int i = 0; i < 2019; i++) {
			// there are nC2 ways to pair the numbers with the same remainder
			answer += (long) count[i] * (count[i] - 1) / 2;
		}
		io.println(answer);
		io.close();
	}
	//CodeSnip{Kattio}
}
```
					 
</JavaSection>
<PySection>

```py
MOD = 2019
string = input()

count = [0] * MOD
count[0] = 1

cur_num = 0
power = 1
for c in reversed(string):
	# find the remainder of the current number MOD 2019
	cur_num = (int(c) * power + cur_num) % MOD
	# increase the power of 10
	power = (power * 10) % MOD
	# increase the count of this remainder
	count[cur_num] += 1

ans = 0
for rep in count:
	# when remainder i repeats rep times then there is C(rep, 2) valid pairs
	ans += (rep * (rep - 1)) // 2
print(ans)
```
</PySection>
</LanguageSection>
