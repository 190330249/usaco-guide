---
id: usaco-1062
source: USACO Silver 2020 December
title: Cowntagion
author: Kevin Sheng
---

[Official Editorial](http://www.usaco.org/current/data/sol_prob1_silver_dec20.html)

<LanguageSection>

<JavaSection>

```java
import java.io.*;
import java.util.*;

public class Cowntagion {
    public static void main(String[] args) throws IOException {
        BufferedReader read = new BufferedReader(new InputStreamReader(System.in));
        int farmNum  = Integer.parseInt(read.readLine());
        ArrayList<Integer>[] neighbors = new ArrayList[farmNum];
        for (int f = 0; f < farmNum; f++) {
            neighbors[f] = new ArrayList<>();
        }
        for (int i = 0; i < farmNum - 1; i++) {  // note: a connected graph with n nodes and n - 1 edges is always a tree
            StringTokenizer path = new StringTokenizer(read.readLine());
            int farm1 = Integer.parseInt(path.nextToken()) - 1;
            int farm2 = Integer.parseInt(path.nextToken()) - 1;
            neighbors[farm1].add(farm2);
            neighbors[farm2].add(farm1);
        }

        int minDays = 0;
        HashSet<Integer> visited = new HashSet<>(Collections.singletonList(0));
        ArrayDeque<Integer> frontier = new ArrayDeque<>(Collections.singletonList(0));
        // do a bfs of the tree
        while (!frontier.isEmpty()) {
            int current = frontier.poll();
            // this stores all the farms that this farm should spread to for optimal spreading
            ArrayList<Integer> spreadTo = new ArrayList<>();
            for (int n : neighbors[current]) {
                if (!visited.contains(n)) {
                    spreadTo.add(n);
                    visited.add(n);
                    frontier.add(n);
                }
            }
            // the log base 2 is so enough superspreader events go around so that there are enough cows, and then we need to add the length of spreadTo so the cows can actually go to the other farms
            minDays += Math.ceil(Math.log10(spreadTo.size() + 1) / Math.log10(2)) + spreadTo.size();
        }

        System.out.println(minDays);
    }
}
```

</JavaSection>


<PySection>

```py
from math import log, ceil
from collections import deque

farmNum = int(input())
neighbors = [[] for _ in range(farmNum)]
for _ in range(farmNum - 1):
    start, end = [int(i) - 1 for i in input().split()]
    neighbors[start].append(end)
    neighbors[end].append(start)

minDays = 0
visited = {0}
frontier = deque([0])
while frontier:
    curr = frontier.popleft()
    # this stores all the farms that this farm should spread to for optimal spreading
    spreadTo = []
    for n in neighbors[curr]:
        if n not in visited:
            spreadTo.append(n)
            visited.add(n)
            frontier.append(n)
    # the log base 2 is so enough superspreader events go around so that there are enough cows, and then we need to add the length of spreadTo so the cows can actually go to the other farms
    minDays += ceil(log(len(spreadTo) + 1, 2)) + len(spreadTo)

print(minDays)
```

</PySection>

</LanguageSection>
