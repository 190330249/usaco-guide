---
id: usaco-1041
source: USACO Gold 2020 US Open
title: Haircut
author: Jeffrey Meng
---


[Official Analysis (C++)](http://www.usaco.org/current/data/sol_haircut_gold_open20.html)

First, we need to count the number of inversions. (Fun fact: the number of inversions is also a measure of how sorted an array is. If an array has 0 inversions, it's perfectly sorted in ascending order.) 

One way to count inversions is to use a Binary Indexed Tree. Think of an inversion as a pair $i, j$, with $i < j$ & $a[i] > a[j]$. Then, we can easily compute, for each element in the array, the number of inversions it is $j$ for.

To do this, we use the BIT as a frequency table, keeping track of the number of hairs before index $i$ of each possible value. If our BIT is named $tree$, $tree[i]$ will tell us how many times $i$ is seen in the array of hairs. The trick, however, is that as long as we fill out the frequency table in the order the elements appear in the array, we can use the frequency table to also count the number of inversions, because the frequency table only contains hairs to the left of the hair we are currently considering.

The algorithm to count inversions:

1. Initialze the BIT so the frequency of each value is 0.
2. Create an array `inversions`. `inversions[j]` will store the number of inversion pairs with the second number being $j$
3. For each hair $j$ in the order it appears in the array:

    a. Count the number of hairs taller than it that appear before the hair in the array, which is just the frequencies of all values greater than $j$. Store this in `inversions[j]`.
    
    b. Update the frequency table with $j$.

The number of inversions would then be the sum of the all values we computed in step 2a. However, we also need to consider the haircuts. If we cut all hairs greater than a number $n$ to $n$, what does that mean? It means that there can be no inversions with a $j \geq n$, because the definition of an inversion is that $i > j$, but if $j \geq n$ than $i > n$ must also be true. However, if this is true, then $i$ and $j$ would both have been cut to height $n$, and they would no longer be part of an inversion.

Thus, the number of inversions if all hairs greater than $n$ are cut to height $n$ is simply the sum of the first $n - 1$ elements of the inversions array (if $n$ is 0 then all hairs are 0 tall, so there are 0 inversions). This is also just the prefix sum of the `inversions` array.


<LanguageSection>
  <JavaSection>

```java

import java.io.*;
import java.util.*;

public class Haircut {

    public static void main(String[] args) throws IOException {
        BufferedReader f = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(System.out)));

        int N = Integer.parseInt(f.readLine());
        StringTokenizer st = new StringTokenizer(f.readLine());

        int[] hairs = new int[N];

        for (int i = 0; i < N; i++) {
            hairs[i] = Integer.parseInt(st.nextToken());
        }

        BIT tree = new BIT(N + 1); // hair can be at most N

        long[] inversionsWithValue = new long[N + 1];
        // inversionsWithValue[i] == the number of inversions used with all hairs of height i

        for (int value : hairs) {


            // we process from left to right, so the tree only
            // has elements to the left of this. Therefore,
            // the number of elements higher than this is the number of inversions.
            int numInversions = tree.getSum(value + 1, tree.size - 1);
            inversionsWithValue[value] += numInversions;

            tree.increase(value, 1);
        }


        long cumulativeInversions = 0;
        out.println(0); // if all hairs are cut to length 0, they're all equal, so no inversions are possible
        for (int j = 0; j < N - 1; j++) {
            cumulativeInversions += inversionsWithValue[j];
            out.println(cumulativeInversions);
        }

        out.close();
    }

    static class BIT {
        int size;
        int[] tree;

        public BIT(int size) {
            this.size = size;
            tree = new int[size + 1];
        }

        /**
        * Change the value at index i by change
        * @param i
        * @param change
        */
        public void increase(int i, int change) {
            i++; // We start BIT at index 0
            while (i < tree.length) {
                tree[i] += change; // Update for all parents
                i += i & -i; // lowbit (~i + 1) is the same thing as -i
            }

        }

        /**
        * Set i to a value
        * @param i
        * @param val
        */
        public void set(int i, int val) {
            increase(i, val - get(i));
        }

        /**
        * Sum of all elements up to and including i
        * @param i - index
        * @return
        */
        public int getSum(int i) {
            i++;
            int sum = 0;
            while (i > 0) { // Sum the values of each parent
                sum += tree[i];
                i -= i & -i;
            }
            return sum;
        }

        /**
        * Get sum of range [i, j]
        * @param i - start index, inclusive
        * @param j - end index, inclusive
        * @return sum of range [i, j]
        */
        public int getSum(int i, int j) {
            return getSum(j) -
                (i > 0 ? getSum(i - 1) : 0);
        }

        /**
        * @param i - index
        * @return element at i
        */
        public int get(int i) {
            return getSum(i, i);
        }

        /**
        * String representation
        * @return
        */
        public String toString() {
            String out = "";
            for (int i = 0; i < size - 1; i++) {
                out += get(i) + " ";
            }
            out += get(size - 1);
            return out;
        }
    }
}

```

  </JavaSection>
</LanguageSection>
