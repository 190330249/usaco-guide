---
id: usaco-831
source: USACO Bronze 2018 Open
title: Team Tic Tac Toe
author: Jesse Choe, Kevin Sheng, Benjamin Qi, Brad Ma
contributor: Aadit Ambadkar
---

## Solution 1

[Official Analysis (C++)](http://www.usaco.org/current/data/sol_tttt_bronze_open18.html)

<LanguageSection>
<CPPSection>
	
```cpp
#include <bits/stdc++.h>
using namespace std;

char board[3][3];

// Does 1 cow win?
int cowWins(char ch) {
	// Check diagonals
	if (board[0][0] == ch && board[1][1] == ch && board[2][2] == ch) {
		return 1;
	}
	if (board[0][2] == ch && board[1][1] == ch && board[2][0] == ch) {
		return 1;
	}

	// Check rows and columns
	for (int i = 0; i < 3; i++) {
		if (board[0][i] == ch && board[1][i] == ch && board[2][i] == ch) {
			return 1;
		}
		if (board[i][0] == ch && board[i][1] == ch && board[i][2] == ch) {
			return 1;
		}
	}
	return 0;
}

// Test if a team wins based on 3 characters in a row, column, or diagonal
bool check3(char ch1, char ch2, char a, char b, char c) {
	// All 3 characters have to be either ch1 or ch2
	if (a != ch1 && a != ch2) {
		return false;
	}
	if (b != ch1 && b != ch2) {
		return false;
	}
	if (c != ch1 && c != ch2) {
		return false;
	}

	// ch1 and ch2 have to appear at least once each
	if (a != ch1 && b != ch1 && c != ch1) {
		return false;
	}
	if (a != ch2 && b != ch2 && c != ch2) {
		return false;
	}

	return true;
}
// Does a team win?
int teamWins(char ch1, char ch2) {
	// Check diagonals
	if (check3(ch1, ch2, board[0][0], board[1][1], board[2][2])) {
		return 1;
	}
	if (check3(ch1, ch2, board[0][2], board[1][1], board[2][0])) {
		return 1;
	}

	// Check rows and columns
	for (int i = 0; i < 3; i++) {
		if (check3(ch1, ch2, board[0][i], board[1][i], board[2][i])) {
			return 1;
		}
		if (check3(ch1, ch2, board[i][0], board[i][1], board[i][2])) {
			return 1;
		}
	}

	return 0;
}

int main() {
	freopen("tttt.in", "r", stdin);
	freopen("tttt.out", "w", stdout);
	
	for (int i = 0; i < 3; i++) {
		string line;
		cin >> line;
		for (int j = 0; j < 3; j++) {
			board[i][j] = line[j];
		}
	}

	int answer1 = 0, answer2 = 0;
	for (char ch = 'A'; ch <= 'Z'; ch++) {
		answer1 += cowWins(ch);
	}
	
	for (char ch1 = 'A'; ch1 <= 'Z'; ch1++) {
		for (char ch2 = (char) ((int) ch1 + 1); ch2 <= 'Z'; ch2++) {
			answer2 += teamWins(ch1, ch2);
		}
	}

	cout << answer1 << "\n" << answer2 << "\n";
}
```
</CPPSection>
<JavaSection>
	
```java
import java.util.*;
import java.io.*;

public class TeamTicTacToe {
	static char[][] board = new char[3][3];

	// Does 1 cow win?
	static int cowWins(char ch) {
		// Check diagonals
		if (board[0][0] == ch && board[1][1] == ch && board[2][2] == ch) {
			return 1;
		}
		if (board[0][2] == ch && board[1][1] == ch && board[2][0] == ch) {
			return 1;
		}

		// Check rows and columns
		for (int i = 0; i < 3; i++) {
			if (board[0][i] == ch && board[1][i] == ch && board[2][i] == ch) {
				return 1;
			}
			if (board[i][0] == ch && board[i][1] == ch && board[i][2] == ch) {
				return 1;
			}
		}
		return 0;
	}

	// Test if a team wins based on 3 characters in a row, column, or diagonal
	static boolean check3(char ch1, char ch2, char a, char b, char c) {
		// All 3 characters have to be either ch1 or ch2
		if (a != ch1 && a != ch2) {
			return false;
		}
		if (b != ch1 && b != ch2) {
			return false;
		}
		if (c != ch1 && c != ch2) {
			return false;
		}

		// ch1 and ch2 have to appear at least once each
		if (a != ch1 && b != ch1 && c != ch1) {
			return false;
		}
		if (a != ch2 && b != ch2 && c != ch2) {
			return false;
		}

		return true;
	}

	// Does a team win?
	static int teamWins(char ch1, char ch2) {
		// Check diagonals
		if (check3(ch1, ch2, board[0][0], board[1][1], board[2][2])) {
			return 1;
		}
		if (check3(ch1, ch2, board[0][2], board[1][1], board[2][0])) {
			return 1;
		}

		// Check rows and columns
		for (int i = 0; i < 3; i++) {
			if (check3(ch1, ch2, board[0][i], board[1][i], board[2][i])) {
				return 1;
			}
			if (check3(ch1, ch2, board[i][0], board[i][1], board[i][2])) {
				return 1;
			}
		}

		return 0;
	}

	public static void main(String[] args) throws IOException {
		Kattio io = new Kattio("tttt");

		for (int i = 0; i < 3; i++) {
			String line = io.next();
			for (int j = 0; j < 3; j++) {
				board[i][j] = line.charAt(j);
			}
		}

		int answer1 = 0;
		int answer2 = 0;
		for (char ch = 'A'; ch <= 'Z'; ch++) {
			answer1 += cowWins(ch);
		}

		for (char ch1 = 'A'; ch1 <= 'Z'; ch1++) {
			for (char ch2 = (char) ((int) ch1 + 1); ch2 <= 'Z'; ch2++) {
				answer2 += teamWins(ch1, ch2);
			}
		}

		io.println(answer1 + "\n" + answer2);
		io.close();
	}
	//CodeSnip{Kattio}
}
```
	
</JavaSection>
	
</LanguageSection>
## Solution 2 - Using Sets

An alternate solution would be to use sets. 

First, create an array (of size 4) of set of sets called `winners`. In each index `index`, this array will store a set containing the distinct sets of size `index` of cows which form a winning row/column/diagonal somewhere on the board. 

Loop over each possible winning "state" (all rows, columns, and diagonals). For each row/column/diagonal, add the distinct cows which "contribute" to that state into a temporary set called `contained`; for example, if a row contains `W W X` then the distinct cows would be `W` and `X`. Then, add this set to `winners[contained.size()]`. Finally, we print out `winners[1].size()` and `winners[2].size()`.
	

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

const int WIDTH = 3;

vector<string> board(WIDTH);
set<set<char>> winners[WIDTH + 1];

void insert(vector<pair<int, int>> coordinates) {
	set<char> contained;
	for (const pair<int, int>& p: coordinates) {
		contained.insert(board[p.first][p.second]);
	}
	// add the amount of cows who contributed to this to the winners count
	winners[contained.size()].insert(contained);
}

int main() {
	ifstream read("tttt.in");
	
	for (int r = 0; r < WIDTH; r++) {
		read >> board[r];
	}
	
	// insert rows
	for (int i = 0; i < WIDTH; i++) {
		insert({{i, 0}, {i, 1}, {i, 2}});
	}
	
  	// insert columns
	for (int i = 0; i < WIDTH; i++) {
		insert({{0, i}, {1, i}, {2, i}});
	}
	
	// insert the 2 diagonals
	insert({{0, 0}, {1, 1}, {2, 2}});
	insert({{2, 0}, {1, 1}, {0, 2}});

	ofstream written("tttt.out");
	written << winners[1].size() << endl;
	written << winners[2].size() << endl;
}
```
</CPPSection>
<JavaSection>
Unfortunately, implementing this solution in java is quite tricky, and is beyond the scope of Bronze
</JavaSection>
</LanguageSection>
