---
id: poi-14-hot
title: POI 2014 Hotels
author: Andi Qu
---

The following two hints apply for all three approaches:

<Spoiler title="Hint 1">

For any three nodes $a$, $b$, and $c$, the three paths $a \rightarrow b$, $b \rightarrow c$, and $c \rightarrow a$ only have one common node.

</Spoiler>

<Spoiler title="Hint 2">

Let the aforementioned common node be $r$. The triple $(a, b, c)$ is good if and only if the lengths of the paths $r \rightarrow a$, $r \rightarrow b$, and $r \rightarrow c$ are equal.

</Spoiler>

## Approach 1 - Prefix/Suffix Sums

<Spoiler title="Hint 3">

Do you think you have an $O(N^3)$ solution that doesn't involve looping through all triples of nodes? If so, is it really $O(N^3)$ or is it actually amortized $O(N^2)$?

</Spoiler>

<Spoiler title="Solution">

Since $N$ is small, we can afford to calculate the number of good triples with common node $r$, for all $r$ from 1 to $N$.

For some $r$, root the tree at $r$. We can then perform DFSes to find the depths of the subtrees of $r$'s children, and the number of nodes at each depth in each subtree. Let $\texttt{at\_depth}_i[d]$ be the number of nodes at depth $d$ in child $i$'s subtree.

Each node in a good triple must be at the same depth and in different subtrees, so the number of good triples that depth $d$ of subtree $i$ contributes is thus:

$$
\left(\sum_{j < i}\texttt{at\_depth}_j[d]\right) \cdot \texttt{at\_depth}_i[d] \cdot \left(\sum_{j > i}\texttt{at\_depth}_j[d]\right)
$$

We can loop through each **valid** pair $(i, d)$ in amortized $O(N)$ time, since each pair corresponds to at least one node in the tree.

But how can we compute $\sum_{j < i}\texttt{at\_depth}_j[d]$ and $\sum_{j > i}\texttt{at\_depth}_j[d]$ quickly?

Notice how we only have to compute one of these sums, and that they look awfully similar to prefix/suffix sums. In my solution, I compute $\sum_{j > i}\texttt{at\_depth}_j[d]$ using suffix sums. Let's call this value $\texttt{after}_i[d]$.

Assume (without loss of generality) that the children of $r$ are ordered by the depths of their subtrees.

Since we only care about $\texttt{after}_i[d]$ for **valid** pairs $(i, d)$, this means that we care about $\texttt{after}_i[d]$ only if we also care about $\texttt{after}_{i + 1}[d]$. We know that $\texttt{after}_i[d] = \texttt{at\_depth}_{i + 1}[d] + \texttt{after}_{i + 1}[d]$, so this allows us to compute all interesting $\texttt{after}_i[d]$ in $O(N)$ time!

The final complexity of this code is $O(N^2)$ time (or $O(N^2 \log N)$, depending on how you sort) with $O(N)$ memory.

### Code

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> graph[5001];

void find_dep(int node, int parent, pair<int, vector<int>> &root, int depth = 0) {
    if (depth == root.first) {
        root.first++;
        root.second.push_back(1);
    } else root.second[depth]++;
    for (int i : graph[node]) if (i != parent) find_dep(i, node, root, depth + 1);
}

int main() {
    int n;
    scanf("%d", &n);
    for (int i = 1; i < n; i++) {
        int a, b;
        scanf("%d %d", &a, &b);
        graph[a].push_back(b);
        graph[b].push_back(a);
    }

    if (n < 4) {
        printf("0\n");
        return 0;
    }

    long long ans = 0;
    for (int i = 1; i <= n; i++) {
        int m = graph[i].size();
        vector<pair<int, vector<int>>> dep(m);
        vector<vector<int>> aft(m);
        vector<int> tot;

        for (int j = 0; j < m; j++) find_dep(graph[i][j], i, dep[j]);
        sort(dep.begin(), dep.end());

        tot.resize(dep[m - 1].first);
        for (int j = m - 1; ~j; j--) {
            aft[j].resize(dep[j].first);
            for (int k = 0; k < dep[j].first; k++) {
                tot[k] += dep[j].second[k];
                if (j != m - 1) {
                    aft[j][k] = aft[j + 1][k] + dep[j + 1].second[k];
                }
            }
        }

        for (int j = 0; j < m; j++) {
            for (int k = 0; k < dep[j].first; k++) {
                ans += (tot[k] - dep[j].second[k] - aft[j][k]) * dep[j].second[k] * aft[j][k];
            }
        }
    }
    
    printf("%lld\n", ans);
    return 0;
}
```

Be sure to use `std::vector`s to ensure $O(N)$ memory!

</Spoiler>

## Approach 2 - DP

<IncompleteSection>
</IncompleteSection>

## Bonus - An $O(N \log N)$ Solution

<IncompleteSection>
</IncompleteSection>

See [the Polish editorial](https://github.com/mostafa-saad/MyCompetitiveProgramming/blob/master/Olympiad/POI/official/2014/editorial/hot.pdf) for more details.
