---
id: cses-1753
source: CSES
title: String Matching
author: Dustin Miao
---

## Solution - Knuth-Morris-Prat Algorithm

Define an array $\pi_S$ on some string $S$ such that $\pi_S[i]$ stores the length of the longest nontrivial prefix of the entire string that is equivalent to a suffix ending at position $i$. Formally, 

$$
\pi_S[i] = \max\{k \: | \: 1 \leq k < i \text{ and } S[0:k - 1] \equiv S[i - (k - 1): i]\}
$$

If we are searching for string $P$ inside of string $T$, create a new string $S = P + \# + T$, where $\#$ is any arbitrary character that does not occur in either string. Then, create an array $\pi_S$ using the [KMP](https://cp-algorithms.com/string/prefix-function.html) algorithm. The answer is simply the number of indicies inside of $\pi_S$ that is equal to $|P|$ (the length of $P$). 

<LanguageSection>

<CPPSection>

**Time Complexity:** $\mathcal{O}(n + m)$

```cpp
#include <bits/stdc++.h>
using namespace std;

namespace str {
	vector<int> pi(const string &s) {
		int n = (int)s.size();
		vector<int> _pi(n);
		for (int i = 1, j; i < n; i++) {
			for (j = _pi[i - 1]; j > 0 && s[j] != s[i]; j = _pi[j - 1]);
			if (s[i] == s[j])
				j++;
			_pi[i] = j;
		}
		return _pi;
	}
}

string P, T;

int main() {
	cin >> T >> P;
	string S = P + '#' + T;
	vector<int> pi = str::pi(S);   
	int ans = 0;
	for (int l : pi)
		if (l == P.size())
			ans++;
	cout << ans << '\n';
}
```

</CPPSection>

</LanguageSection>

## Solution - Z-Algorithm

Like the previous solution, we now define an array $z_S$ such that $z_S[i]$ is the length of the longest prefix beginning at index $i$ that is equivalent to a prefix of the entire string. Formally, 

$$
z_S[i] = \max\{k \: | \: 1 \leq k\text{ and } S[0:k - 1] \equiv S[i:i+k-1]\}
$$

As before, for pattern string $P$ and text string $T$, create a new string $S = P + '\#' + T$, and create the array $z_S$ using the [z-algorithm](https://cp-algorithms.com/string/z-function.html). The answer is the number of indices inside of $z_S$ that is equal to $|P|$. 

<LanguageSection>

<CPPSection>

**Time Complexity:** $\mathcal{O}(n + m)$

```cpp
#include <bits/stdc++.h>
using namespace std;

namespace str {
	vector<int> z(const string &s) {
		int n = (int)s.size();
		vector<int> _z(n);
		for (int i = 1, l = 0, r = 0; i < n; i++) {
			if (i <= r)
				_z[i] = min(_z[i - l], r - i + 1);
			while (i + _z[i] < n && s[_z[i]] == s[i + _z[i]])
				_z[i]++;
			if (i + _z[i] - 1 > r)
				l = i, r = i + _z[i] - 1;
		}
		return _z;
	}
}

string P, T;

int main() {
	cin >> T >> P;
	string S = P + '#' + T;
	vector<int> z = str::z(S);   
	int ans = 0;
	for (int l : z)
		if (l == P.size())
			ans++;
	cout << ans << '\n';
}
```

</CPPSection>

</LanguageSection>

## Solution - Rabin-Karp Algorithm

Precompute the rolling hash of both $P$ and $T$. Each substring of length $|P|$ can be compared for equality in $\mathcal{O}(1)$ time. Since there is a relatively small number of comparisons, using a single set of hash values is fine. Using hash base $9973$ and modulo $10^9 + 7$ suffices. 

<LanguageSection>

<CPPSection>

**Time Complexity:** $\mathcal{O}(n + m)$

```cpp
#include <bits/stdc++.h>
using namespace std;

namespace str {
	vector<long long> rhash(const string &s, const long long P, const long long M) {
		int n = (int)s.size();
		vector<long long> _rhash(n);
		for (int i = 0; i < n; i++)
			_rhash[i] = ((i == 0 ? 0 : _rhash[i - 1]) * P + (long long)s[i]) % M;
		return _rhash;
	}
}

const long long hashPow = 9973, hashMod = 1e9 + 7;

string P, T;

int main() {
	cin >> T >> P;
	auto Phash = str::rhash(P, hashPow, hashMod), Thash = str::rhash(T, hashPow, hashMod);
	long long ppow = 1;  // hashPow to the power of |P|
	for (int i = 0; i < P.size(); i++)
		ppow = (ppow * hashPow) % hashMod;
	int ans = 0;
	for (int i = 0; i + P.size() - 1 < T.size(); i++) {
		long long curHash = (Thash[i + P.size() - 1] - 
			(i == 0 ? 0 : (Thash[i - 1] * ppow) % hashMod) + hashMod) % hashMod;
		if (curHash == Phash.back())
			ans++;
	}
	cout << ans << '\n';
}
```

</CPPSection>

</LanguageSection>
