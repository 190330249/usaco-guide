---
id: usaco-1159
source: USACO Silver 2021 December
title: Connecting Two Barns
author: Ryan Chou
---

[Official Analysis (C++)](http://www.usaco.org/current/data/sol_prob2_silver_dec21.html)

## Explanation
The important observation is that there are only two types of edges that we add in an optimal solution:
* Connecting the connected component containing $1$ to the connected component containing $N$ directly
* Connecting the connected component containing $1$ to an "middle component" and connecting the middle component to the connected component containing $N$

We can find these connected components using [DFS](/silver/dfs), and naively check each pair. This results in a $\mathcal{O}(N^2)$ algorithm. However, this only solves the first and second subtasks. 

To speed this up, we need to be more conservative about what edges to consider. When connecting a connnected component to a barn we only care about the largest element in it which is less than our target and the smallest element in it which is greater than our target because this minimizes the absolute difference. You can compute this using [binary search](/silver/binary-search) or [two pointers](/silver/two-pointers).

## Implementation: DFS + Two Pointers

**Time Complexity:** $\mathcal{O}(N + M)$

See the [official editorial](http://www.usaco.org/current/data/sol_prob2_silver_dec21.html).

## Implementation: DSU + Binary Search
<Warning>
DSU is a [gold topic](/gold/dsu), so feel free to skip this solution if you find it unfamiliar and come back later.
</Warning>

**Time Complexity:** $O((N + M) \alpha(N) + N \log N)$

<CPPSection>

```cpp

#include <bits/stdc++.h>
using namespace std;

struct DSU {
	vector<int> e;
	DSU(int N) { e = vector<int>(N, -1); }

	// get representive component (uses path compression)
	int get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }

	bool same_set(int a, int b) { return get(a) == get(b); }

	int size(int x) { return -e[get(x)]; }

	bool unite(int x, int y) {  // union by size
		x = get(x), y = get(y);
		if (x == y) return false;
		if (e[x] > e[y]) swap(x, y);
		e[x] += e[y]; e[y] = x;
		return true;
	}
};

void solve() {
	int n, m;
	cin >> n >> m;

	DSU dsu(n);

	// build graph
	for (int i = 0; i < m; i++) {
		int u, v;
		cin >> u >> v;
		dsu.unite(--u, --v);
	}

	// maps nodes to their respective component
	vector<int> comp(n);

	// maps components to their vertices
	vector<set<int>> ctv(n);


	for (int i = 0; i < n; i++) {
		// gets component of i
		int c = dsu.get(i);

		comp[i] = c;
		ctv[c].insert(i);
	}

	/*
	 * src[i] is the min cost from connecting the connected component cotaining 0 
	 * to the ith connected component
	 * 
	 * dst[i] is the min cost from connecting the connected component containing n - 1
	 * to the ith connected component
	 */
	vector<long long> src(n, INT32_MAX), dst(n, INT32_MAX);

	for (int i = 0; i < n; i++) {
		auto it = ctv[comp[0]].lower_bound(i);
		auto it2 = ctv[comp[n - 1]].lower_bound(i);
		int min_src, min_dst;

		if (it == ctv[comp[0]].end()) {
			min_src = *(--it);
		} else if (it == ctv[comp[0]].begin()) {
			min_src = *it;
		} else {
			/*
			 * we only care about the max element less than i 
			 * and the min element greater than i
			 */
			int l = *it;
			int r = *(--it);

			if (abs(l - i) < abs(r - i)) {
				min_src = l;
			} else {
				min_src = r;
			}
		}

		if (it2 == ctv[comp[n - 1]].end()) {
			min_dst = *(--it2);
		} else if (it2 == ctv[comp[n - 1]].begin()) {
			min_dst = *it2;
		} else {
			// same here
			int l = *it2;
			int r = *(--it2);

			if (abs(l - i) < abs(r - i)) {
				min_dst = l;
			} else {
				min_dst = r;
			}
		}

		// update mins
		src[comp[i]] = min(src[comp[i]], (long long)(abs(i - min_src)));
		dst[comp[i]] = min(dst[comp[i]], (long long)(abs(i - min_dst)));
	}

	long long best = LLONG_MAX;

	for (int i = 0; i < n; i++) {
		best = min(best, (src[i] * src[i]) + (dst[i] * dst[i]));
	}

	cout << best << '\n';
}

int main() {
	int t;
	cin >> t;
	
	while (t--) solve();
}
```
</CPPSection>
