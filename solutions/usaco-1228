---
id: usaco-1228
source: USACO Bronze 2022 Open
title: Counting Liars
author: Chongtian Ma
---

[Official Analysis](http://www.usaco.org/current/data/sol_prob2_bronze_open22.html)

## Alternate Explanation

An important observation is that if Bessie is at position $x$, then the number of cows lying are all the
cows with position less than $x$ that says "L" plus all the cows with a position greater than x that says
"G". Thus, we can loop through every cow's position and treat it as point $x$ and compute the total number 
of liars by using a forwards loop and a backwards loop. The answer is the minimum liars over all possible position $x$.

## Implementation

**Time Complexity**: $\mathcal{O}(N \log N)$

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;
int main() {
	int n; cin>>n;
	vector<pair<int,char>> cows(n);
	for(int i = 0; i < n; i++){
		// notice the position is read into the first slot of the pair
		cin>>cows[i].second>>cows[i].first;
	}

	// sort by non-decreasing position
	sort(cows.begin(),cows.end());
	
	// stores the cows lying relative to each cow's position
	vector<int> lying_left(n), lying_right(n);
	for(int i = 1; i < n; i++){
		// add up all the cows that are already lying to the left of our position
		lying_left[i] += lying_left[i-1];
		if(cows[i-1].second == 'L' && cows[i].first > cows[i-1].first){
			/*
			 * If the cow before says our position is to the left
			 * and their position is strictly less than our position
			 * then they are lying
			*/
			lying_left[i]++;
		}
	}
	for(int i = n-2; i >= 0; i--){
		lying_right[i] += lying_right[i+1];
		if(cows[i+1].second == 'G' && cows[i].first < cows[i+1].first){
			lying_right[i]++;
		}
	}
	int ans = n;
	for(int i = 0; i < n; i++){
		ans = min(ans, lying_left[i] + lying_right[i]);
	}
	cout<<ans<<endl;
}
```

</CPPSection>

</LanguageSection>
