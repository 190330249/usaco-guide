---
id: lc-find-pivot-index
source: LeetCode
title: Find Pivot Index
author: Qi Wang
---

**Time Complexity:** $\mathcal O(N)$.

## Solution 1

The pivot index must have the same sum on its left and its right. To calculate this, we can create a prefix sum of the $\texttt{nums}$ array (in my solution it is cushioned with one $0$ at index $0$). Afterwards, all we need to do is to loop through every index from $0$ (inclusive) to $\texttt{nums}.length$ (exclusive) in the $\texttt{psums}$ array and check for:

$$
\texttt{psums}[i] - \texttt{psums}[0] == \texttt{psums}[\texttt{nums}.length] - \texttt{psums}[i+1]
$$

If this is true, we can return our current index because the problem wants the left-most index. If it finishes the for-loop without returning, it means there is no valid pivot index so return $-1$.

## Solution 2

The alternate solution does not require an array to store the sums. Instead, we only need the total sum of the array and the current sum at each index (exclusive of index). With this we check for:

$$
\texttt{curSum} == \texttt{total} - \texttt{curSum} - \texttt{nums}[i];
$$

If this is true, we can return our current index because the problem wants the left-most index. If it finishes the for-loop without returning, it means there is no valid pivot index so return $-1$.

Note: This is technically the same solution as solution 1, but it is another way to think about approaching this question.

<LanguageSection>
<CPPSection>

```cpp
//Created by Qi Wang

//Solution 1
class Solution {
public:
    int pivotIndex(vector<int>& nums) {
        vector<int> psums;
        
        psums.push_back(0);
        for(int i = 0; i<nums.size(); i++){
            //Notice i in psums is always one less than the current index
            psums.push_back(psums[i] + nums[i]);
        }
        

        
        for(int i = 0; i<psums.size()-1; i++){
            //Checking whether the left and the right are equal in area
            if(psums[i] - psums[0] == psums[nums.size()] - psums[i+1]){
                return i;
            }
        }
        return -1;
    }
};

//Solution 2
class Solution {
public:
    int pivotIndex(vector<int>& nums) {      
        int total = 0;
        for(auto &x : nums)
            total += x;
        
        int curSum = 0;
        for(int i = 0; i<nums.size(); i++){
            //curSum is up to i not inclusive of i.
            if(curSum == total - curSum - nums[i]){
                return i;
            }

            //updating curSum
            curSum += nums[i];
        }
        return -1;
    }
};

```

</CPPSection>

<JavaSection>

```java
//Created by Qi Wang


//Solution 1

class Solution {
    public int pivotIndex(int[] nums) {
        int[] psums = new int[nums.length+1];
        
        for(int i = 0; i<nums.length; i++){
            //Notice i in psums is always one less than the index we are modifying
            psums[i+1] = psums[i] + nums[i];
        }
        

        
        for(int i = 0; i<psums.length-1; i++){
            //Checking whether the left and the right are equal in area
            if(psums[i] - psums[0] == psums[nums.length] - psums[i+1]){
                return i;
            }
        }
        return -1;
    }
}


//Solution 2

class Solution {
    public int pivotIndex(int[] nums) {        
        int total = 0;
        for(int num : nums)
            total += num;
        
        int curSum = 0;
        for(int i = 0; i<nums.length; i++){
            //curSum is up to i not inclusive of i.
            if(curSum == total - curSum - nums[i]){
                return i;
            }

            //updating curSum
            curSum += nums[i];
        }
        return -1;
    }
}

```

</JavaSection>

<PySection>

</PySection>
</LanguageSection>