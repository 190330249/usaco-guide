---
id: kattis-catandmice
source: Kattis
title: Cat and Mice
author: Kevin Sheng
---

## Explanation

Binary search on the minimum possible speed of Cartesian Cat.

For each speed, let $\texttt{mintime}[S][e]$ be the minimum time to go from the start to end $e$, eating each mouse in the set $S$ along the way.
If it is impossible to do so, the value will be defined as infinity.
When processing each state, go through all the possible previous ending points and see if it's possible to reach the defined end given the previous ending time. Calculate the minimum time for the state over all valid previous endings.

## Implementation

Complexity: $\mathcal{O}(\log{ans}\cdot 2^N \cdot N^2)$

<LanguageSection>
<JavaSection>
```java
import java.io.*;
import java.util.*;

public final class CatAndMice {
	private static final long PRECISION = (long) 1e4;
	public static void main(String[] args) throws IOException {
		BufferedReader read = new BufferedReader(new InputStreamReader(System.in));
		int miceNum = Integer.parseInt(read.readLine());
		int[][] mice = new int[miceNum][];
		for (int m = 0; m < miceNum; m++) {
			mice[m] = Arrays.stream(read.readLine().split(" "))
							.mapToInt(Integer::parseInt).toArray();
		}
		double speedRed = Double.parseDouble(read.readLine());

		long lo = 0;
		long hi = Long.MAX_VALUE / 2;  // this should be large enough
		double valid = -1;
		while (lo <= hi) {
			long mid = (lo + hi) / 2;
			double toTest = (double) mid / PRECISION;
			if (allEatable(new int[] {0, 0}, mice, speedRed, toTest)) {
				hi = mid - 1;
				valid = toTest;
			} else {
				lo = mid + 1;
			}
		}
		System.out.println(valid);
	}

	private static boolean allEatable(
		int[] start, int[][] mice, double speedRed, double initSpeed
	) {
		double[][] minTime = new double[1 << mice.length][mice.length];
		for (int s = 0; s < (1 << mice.length); s++) {
			// MAX_VALUE will be used as a placeholder for invalid values
			Arrays.fill(minTime[s], Double.MAX_VALUE);
		}

		for (int s = 1; s < (1 << mice.length); s++) {
			double speed = Math.pow(speedRed, Integer.bitCount(s) - 1) * initSpeed;
			for (int end = 0; end < mice.length; end++) {
				if ((s & (1 << end)) == 0) {
					continue;
				}
				// the subset without the current end
				int prev = s & ~(1 << end);
				// handle the special case for when we just started
				if (prev == 0) {
					double dist = dist(start, mice[end]);
					minTime[s][end] = initSpeed * mice[end][2] >= dist
									  ? dist / initSpeed : Double.MAX_VALUE;
					continue;
				}
				for (int prevEnd = 0; prevEnd < mice.length; prevEnd++) {
					if (minTime[prev][prevEnd] == Double.MAX_VALUE) {
						continue;
					}
					double dist = dist(mice[prevEnd], mice[end]);
					// check if Cartesian Cat can reach the mouse in time
					if (speed * (mice[end][2] - minTime[prev][prevEnd]) < dist) {
						continue;
					}
					minTime[s][end] = Math.min(
							minTime[s][end],
							minTime[prev][prevEnd] + dist / speed
					);
				}
			}
		}
		for (double time : minTime[(1 << mice.length) - 1]) {
			if (time != Double.MAX_VALUE) {
				return true;
			}
		}
		return false;
	}

	private static double dist(int[] p1, int[] p2) {
		return Math.sqrt(Math.pow(p1[0] - p2[0], 2) + Math.pow(p1[1] - p2[1], 2));
	}
}
```
</JavaSection>
</LanguageSection>
