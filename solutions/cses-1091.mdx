---
id: cses-1091
source: CSES
title: Concert Tickets
author: Danh Ta Chi Thanh, Ben Dodge
---

## Implementation

[Unofficial Editorial (C++)](https://codeforces.com/blog/entry/83295)

**Time Complexity:** $\mathcal{O}(n+ m)$

For each customer, we want to find the maximum possible ticket price they will
accept from the available tickets. If the customer's maximum price is too low,
so that no ticket price is below it, we can return -1. If not, we find the
greatest ticket price less than or equal to the maximum price, and then remove
that price as specified by the problem.

We use a multiset for this. A
[multiset](https://en.wikipedia.org/wiki/Multiset) is basically an ordered set
that allows multiple elements of the same value. We do this because different tickets can have the same price. 

<LanguageSection>
<CPPSection>
```cpp
#include <bits/stdc++.h>

using namespace std;

//variables used for the current problem
int n,m,h,t; multiset<int> tickets;

void solve() {
	cin >> n >> m;
	for (int i=0;i<n;++i){
		cin >> h; tickets.insert(h);
	}
	for (int i=0;i<m;++i){
		cin >> t;
		auto it = tickets.upper_bound(t);
		if (it==tickets.begin()){
			cout << -1 << "\n";
		}
		else{
			cout << *(--it) << "\n";
			tickets.erase(it);
		}
	}
}

int main(){
	ios::sync_with_stdio(0);
	cin.tie(0);
	solve();
	return 0;
}
```

</CPPSection>

<JavaSection>
<Warning>
Due to the way CSES's grader works (allowing 1 second for all problems + being slow), test cases 5 and 8 TLE (time limit exceeded). USACO gives Java test cases 4 seconds, so this isn't representative of what competing with Java will be like. 
	
Also, Java doesn't have a defined multiset function, so we have to use an ordered map with some special modifications, using values as a counter of the number of identical sets. This allows us to distinguish between sets, and remove each set once.
</Warning>
```java
import java.io.*;
import java.util.*;

public class ConcertTickets {
	public static void main(String[] args) throws IOException {
		Kattio io = new Kattio();

		int ticketNum = io.nextInt();
		int peopleNum = io.nextInt();
		// No multiset in java so we'll have to use a TreeMap
		NavigableMap<Integer, Integer> ticketMultiset = new TreeMap<>();
		Map.Entry<Integer, Integer> val;

		for (int i = 0; i < ticketNum; i++) {
			int priceOfTicket = io.nextInt();
			/*
			 * If the set already contains the same key value, create another pair 
			 * next to it
			 */
			if (ticketMultiset.containsKey(priceOfTicket)) {
				ticketMultiset.put(priceOfTicket, ticketMultiset.get(priceOfTicket) + 1);
			} else {
				ticketMultiset.put(priceOfTicket, 1);
			}
		}

		for (int i = 0; i < peopleNum; i++) {
			int customerMaxPrice = io.nextInt();
			/*
			 * Get the optimal ticket for this customer 
			 * We add 1 because lowerEntry returns the highest *strictly* lower entry
			 */
			val = ticketMultiset.lowerEntry(customerMaxPrice + 1); 
			// If there are no possible prices, we can exit and return -1
			if (val != null) {
				io.println(val.getKey());
				/*
				 * If there's more than one set with the key value, then replace
				 * the current set with the next-lowest set with the same key 
				 */
				if (val.getValue() == 1) {
					ticketMultiset.remove(val.getKey());

				} else {
					ticketMultiset.put(val.getKey(), val.getValue() - 1);
				}
			} else
				io.println(-1);
		}
		io.close();
	}
	//CodeSnip{Kattio}
}
```
</JavaSection>
</LanguageSection>
