---
id: cses-1139
source: CSES
title: Distinct Colors
author: Timothy Gao
---

## Editorial

Let us consider the Euler tour of the tree. We flatten the tree into an array, where each node corresponds to a range 
in this array. Now, we are essentially tasked the find the number of distinct values in a range $N$ times(for each node).

There are a variety of ways to approach the problem from here.

**Solution: BIT**

One such solution is with a binary indexed tree. Let us consider iterating through the Euler tour array from left to right. 
When we consider a node at index $i$ in the Euler tour array, it's subtree range will be $[j, i]$, where $j<=i$.
Now, let's focus on a single color. Notice that if there are multiple of colors $c$ to the left of a certain index $i$,
only $c$'s most rightmost occurance is relevant. This is because any non-rightmost occurance of $c$
from $i$ must include the rightmost occurance of $c$. More formally, 
any segment $[l, r]$ must contains $i$ if $l <= i <= r$. 

With this observation, we can essentially reduce the distinct colors queries to a simple range query. As we iterate
 through the euler tour from left to right, mark the current index as 1, and if the color of the node at current index 
has occured before, make it 0 in the BIT. We can find the solution to every node by doing a sum query
 as we iterate.

**Time Complexity:** $\mathcal O(N\log N)$

<LanguageSection>
<CPPSection>
```cpp
#include <bits/stdc++.h>
 
using namespace std;
 
typedef pair<int, int> pii;
 
#define pb push_back
 
#define f first
#define s second

template <typename T>
struct BIT {
		vector<T> bit;
		int n;
		BIT(int n) {
				this->n = n + 1;
				bit.resize(n+1);
		}
		T sum(int r) {
				r++;
				T ret = 0;
				while (r > 0) {
						ret += bit[r];
						r -= r & -r;
				}
				return ret;
		}
		void update(int idx, T v) {
				idx++;
				while (idx < n) {
						bit[idx] += v;
						idx += idx & -idx;
				}
		}
};

const int maxn = 2e5+6;
int tour[maxn], color[maxn], answer[maxn], lend[maxn];
//euler tour, color of each node, answer for each node, left endpoint of each node(as explained in editorial)
vector<int> adj[maxn];
int idx = 0;

void dfs(int u, int par = 0){
	lend[u] = idx;
	for(int n : adj[u]){
		if(n == par) continue;
		dfs(n, u);
	}
	tour[idx] = u; idx++;
}

int main(){
	ios_base::sync_with_stdio(false); cin.tie(0);
	int N, u, v; cin >> N;
	for(int i = 1; i <= N; i++){
		cin >> color[i];
	}
	for(int i = 0; i < N-1; i++){
		cin >> u >> v;
		adj[u].pb(v);
		adj[v].pb(u);
	}
	dfs(1);
	BIT<int> bit(N);
	map<int, int> last;
// This map stores the rightmost occurance of each color
	for(int i = 0; i < N; i++){
		if(last.count(color[tour[i]])){ // Check if we ever considered the color of tour[i]

			bit.update(last[color[tour[i]]], -1);
			// We update the BIT at the index of the last occurrence of tour[i].

		}
		last[color[tour[i]]] = i; //we change the last occurance of the color of tour[i]

		bit.update(i, 1); //we reflect that change in our BIT

		answer[tour[i]] = bit.sum(i) - bit.sum(lend[tour[i]] - 1);
		//the answer for tour[i]'s node is simply the sum of 1s in its contiguous subinterval in the euler tour
	}
	for(int i = 1; i <= N; i++){
		cout << answer[i] << " ";
	}
}
```
</CPPSection>
</LanguageSection>
