---
id: cses-1077
source: CSES
title: Sliding Cost
author: Isaac Noel
---

**Time Complexity:** $\mathcal{O}(N\log K)$

## Abstract

Finding the difference between sums of the upper $K/2$ elements and lower $K/2$ with two multisets.

<Warning>

The implementation of this solution assumes familarity with [Sliding Median](/gold/sliding#problem-https://cses.fi/problemset/task/1076) as their implementations are near identical.

</Warning>

## Solution

### The cost of a window

It can be shown that it is optimal to change the values of the window to the median (left as an exercise :D). Once we find the median, we must find the sum of all elements' distance from the median. Rather than finding the absolute value of every individual element's distance, which is far too slow, we can split the window into two groups and use $\mathcal{O}(\log K)$ insertions/deletions to find the cost in constant time. The smallest $K/2$ elements in the window will be in the lower group while the largest $K/2$ elements in the window will be in the upper group.

The cost of the window can be expressed as a function of ${K,S_1,S_2}$, and $M$, where $S_1$ and $S_2$ denote the sum of elements in the lower and upper group respectively, and $M$ denotes the median of the window. The cost of the lower group will be $\sum_{i=1}^{K/2} M-e_i$, and the cost of the upper group will be $\sum_{i=1}^{K/2} e_i-M$, where $e$ represents an element in the group. These expressions can be simplified to $M\times K/2 - S_1$ and $S_2 - M\times K/2$.  After summing cost of the two groups, we have the total cost of the window which is $S_2 - S_1$.

## Implementation

Finding the difference between the largest $K/2$ elements in the window and the smallest $K/2$ elements in the window is similar to finding the sliding median (more info [here](/solutions/cses-1076?lang=cpp)). To find the sum of the groups, we keep track of the sum of values within the multisets as we insert and erase. Keep in mind that when the window size is odd, the sum of the lower elements will include the median. We can correct this by adding the median to the final answer if the window size is odd. 


```cpp
#include <iostream>
#include <set>
#include <algorithm>
using namespace std;
using ll = long long;
const ll mn = (ll) 2e5+5;

ll N, K;
ll arr[mn];
multiset<ll> up;
multiset<ll> low;
ll sLow, sUp;

void ins(ll val){
    ll a = *low.rbegin();
    if(a < val){
        up.insert(val); sUp += val;
        if(up.size() > K/2){
            ll moving = *up.begin();
            low.insert(moving); sLow += moving;
            up.erase(up.find(moving)); sUp -= moving;
        }
    }
    else{
        low.insert(val); sLow += val;
        if(low.size() > (K + 1)/2){
            ll moving = *low.rbegin();
            up.insert(*low.rbegin()); sUp += moving;
            low.erase(low.find(*low.rbegin())); sLow -= moving;
        }
    }
}

void er(ll val){
    if(up.find(val) != up.end()){up.erase(up.find(val)); sUp -= val;}
    else {low.erase(low.find(val)); sLow -= val;}
    if(low.empty()){
        ll moving = *up.begin();
        low.insert(*up.begin()); sLow += moving;
        up.erase(up.find(*up.begin())); sUp -= moving;
    }
}

ll med(){ return (K%2 == 0) ? 0 : (*low.rbegin()); }

int main() {
    cin >> N >> K;
    for(ll i = 0; i < N; i++) cin >> arr[i];
    low.insert(arr[0]); sLow += arr[0];
    for(ll i = 1; i < K; i++) ins(arr[i]);
    cout << sUp - sLow + med(); if(N!=1) cout << " ";
    for(ll i = K; i < N; i++){
        if(K == 1){
            ins(arr[i]);
            er(arr[i - K]);
        }
        else{
            er(arr[i - K]);
            ins(arr[i]);
        }
        cout << sUp - sLow + med(); if(i != N -1) cout << " ";
    }
    cout << endl;
}


```
