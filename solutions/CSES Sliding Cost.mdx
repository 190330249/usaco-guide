---
id: cses-1077
source: CSES
title: Sliding Cost
author: Isaac Noel
---

**Time Complexity:** $\mathcal{O}(N\log K)$

## Abstract

All elements in the window must be brought to the value of the median. Once we know the median, we may calculate the cost of the window by using a variety of range sums.


<Warning title = "">

		
This problem requires an understanding of Sliding Median and Point Update Range Sums. Doing these first will make this problem significantly easier.

[Point Update Range Sums module](https://usaco.guide/gold/PURS) [Sliding Median](https://usaco.guide/gold/sliding#problem-https://cses.fi/problemset/task/1076)

</Warning>


## Solution

### The cost of a window

It can be shown that it is optimal to change the values of the window to the median (left as an exercise :D). Once we find the median, we must find the sum of all elements' distance from the median. Rather than finding the absolute value of every individual element's distance, which is too slow as it results with $\mathcal{O}(NK)$ runtime, we can split the window into two groups and deal with them each in $\mathcal{O}(\log K)$ time. The elements in the window with values strictly less than the median will be Group 1 while the elements in the window with values strictly greater than the median will be Group 2.

The cost of the window can be expressed as a function of ${J_1,J_2,S_1,S_2, \text{and } M}$, where $J_1$ and $J_2$ denote the number of elements within the lower and upper group respectively, $S_1$ and $S_2$ are the sum of elements in the lower and upper group respectively, and $M$ denotes the median of the window. The cost of the lower group will be $\sum_{i=1}^{J_1} M-e_i$, and the cost of the upper group will be $\sum_{i=1}^{J_2} e_i-M$, where $e$ represents an element in the group. These expressions can be simplified to $M\times J_1 - S_1$ and $S_2 - M\times J_2$.  After summing cost of the two groups, we have the total cost of the window.

### Binary Indexed Tree Implementation

First, compress the input so that you may find the rank of an element in an Ordered Statistic Tree and find the sum of elements below it. When inserting an element into the window, do the following:

1. Maintain two multisets to find the median (more info can be found at [Sliding Median solution](https://usaco.guide/solutions/cses-1076)). This will find $M$.
2. Insert the data into an OST so that you may find the number of elements less than/greater than an element. This will find $J_1$ and $J_2$.
3. Insert the data into a BIT at the index of its compressed value so that the sum of the elements below an element may be retrieved. This will find $S_1$ and $S_2$.

When removing an element, do the reverse of the above operations. Once these operations have been completed, apply the numbers to find the cost of the window.



```cpp
#include <iostream>
#include <set>
#include <algorithm>
#define ll long long
#define mn (ll) 2e5+5
#define pll pair<long, long>
using namespace std;

ll N, M;
ll arr[mn];
multiset<ll> up;
multiset<ll> low;
set<pll> compress;
ll m[mn];

ll tree[mn]; // BIT for sums below an element
ll treeNum[mn]; // OST

ll sum(ll k, bool a) {ll s = 0; // BIT functions
    while(k >= 1) {
        if(a)s += tree[k];
        else s += treeNum[k];
        k -= k&-k;
    } return s;
}
ll query(ll l, ll r, bool a){return sum(r,a)-sum(l,a);}
void add(ll k, ll x, bool a){
    while(k <= mn){
        if(a)tree[k] += x;
        else treeNum[k] += x;
        k += k&-k;
    }
}
void ins(ll val){ // managing the window and its median
    add(val, m[val], true); add(val,1, false);
    ll a = *low.rbegin();
    if(a < val){
        up.insert(val);
        if(up.size() > M/2){
            low.insert(*up.begin());
            up.erase(up.find(*up.begin()));
        }
    }
    else{
        low.insert(val);
        if(low.size() > (M + 1)/2){
            up.insert(*low.rbegin());
            low.erase(low.find(*low.rbegin()));
        }
    }
}

void er(ll val){
    add(val, -1*m[val], true); add(val, -1, false);
    if(up.find(val) != up.end()) up.erase(up.find(val));
    else low.erase(low.find(val));
    if(low.empty()){
        low.insert(*up.begin());
        up.erase(up.find(*up.begin()));
    }
}

ll solve(ll med){ // putting the numbers together
    ll ans = 0;
    ans += m[med] * sum(med-1,false) - sum(med-1, true);
    ans += query(med, mn-1, true) - m[med] * query(med, mn-1, false);
    return ans;
}

int main() {
    cin >> N >> M;
    for(ll i = 0; i < N; i++){
        cin >> arr[i];
        compress.insert(pll(arr[i],i));
    }
    ll nVal = 1;
    while(!compress.empty()) { // compressing so numbers can be indexes for BIT
        ll val = (*compress.begin()).first;
        while(!compress.empty() && val == (*compress.begin()).first){
            pll top = *compress.begin();
            arr[top.second] = nVal;
            m[nVal] = top.first;
            compress.erase(compress.begin());
        }
        nVal++;
    }
    low.insert(arr[0]); add(arr[0], m[arr[0]], true); add(arr[0], 1, false);
    for(ll i = 1; i < M; i++) ins(arr[i]);
    cout << solve(*low.rbegin()); if(N!=1) cout << " ";
    for(ll i = M; i < N; i++){
        if(M == 1){
            ins(arr[i]);
            er(arr[i - M]);
        }
        else{
            er(arr[i - M]);
            ins(arr[i]);
        }
        cout << solve(*low.rbegin()); if(i != N -1) cout << " ";
    }
    cout << endl;
}

```

