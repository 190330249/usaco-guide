---
id: cf-magship
source: CF
title: Magic Ship
author: Kevin Sheng
---

[Official Editorial](https://codeforces.com/blog/entry/65365)

We can binary search on the minimum time it takes to go from the start to the destination. If a time $t$ is possible, then any time greater than it is possible as well, since once we hit the destination point, we can move in the opposite direction of the wind each time.

For each time we search on, we calculate the distance the wind will blow us, and we see if the destination's manhattan distance is less than the time given.

<LanguageSection>

<JavaSection>

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;

/**
* https://codeforces.com/problemset/problem/1117/C
* 0 0
* 4 6
* 3
* UUU should output 5
*
* 0 3
* 0 0
* 3
* UDD should output 3
*/
public class MagicShip {
    public static void main(String[] args) throws IOException {
        BufferedReader read = new BufferedReader(new InputStreamReader(System.in));
        long[] atPos = Arrays.stream(read.readLine().split(" ")).mapToLong(Long::parseLong).toArray();
        long[] destination = Arrays.stream(read.readLine().split(" ")).mapToLong(Long::parseLong).toArray();
        read.readLine();
        char[] winds = read.readLine().toUpperCase().toCharArray();

        if (!reachable(atPos, destination, Long.MAX_VALUE / 2, winds)) {
            System.out.println(-1);
            System.exit(0);
        }

        long lo = 0;
        long hi = Long.MAX_VALUE / 2;
        long valid = -1;
        while (lo <= hi) {
            long mid = lo / 2 + hi / 2;
            if (reachable(atPos, destination, mid, winds)) {
                    valid = mid;
                    hi = mid - 1;
                } else {
                    lo = mid + 1;
                }
        }
        System.out.println(valid);
    }

    private static boolean reachable(long[] from, long[] to, long time, char[] windPattern) {
        long windX = 0;
        long windY = 0;
        // calculate the net change by the wind through one cycle
        for (char w : windPattern) {
            switch (w) {
                case 'U':
                    windY++;
                    break;
                case 'D':
                    windY--;
                    break;
                case 'L':
                    windX--;
                    break;
                case 'R':
                    windX++;
                    break;
            }
        }
        // to speed things up, we can multiply the blown amount by the complete cycle amount
        windX *= time / windPattern.length;
        windY *= time / windPattern.length;
        long remainder = time % windPattern.length;
        for (int i = 0; i < remainder; i++) {  // calculate the remaining wind
        switch (windPattern[i]) {
            case 'U':
                windY++;
                break;
            case 'D':
                windY--;
                break;
            case 'L':
                windX--;
                break;
            case 'R':
                windX++;
                break;
            }
        }
        return manhattanDist(new long[] {from[0] + windX, from[1] + windY}, to) <= time;
    }

    private static long manhattanDist(long[] from, long[] to) {
        return Math.abs(from[0] - to[0]) + Math.abs(from[1] - to[1]);
    }
}
```

</JavaSection>

</LanguageSection>
