---
id: cses-1751
source: CSES 
title: Planets Cycles
author: Maggie Liu (C++), Qi Wang (Java)
---

Define the number of teleportations starting from a planet as the $\texttt{pathlength}$ of that planet. For each planet that hasn't been visited, we want to find its $\texttt{pathlength}$. Call the planet we are performing $\texttt{dfs}$ from the $\textit{start}$. As we perform $\texttt{dfs}$ from the $\textit{start}$, keep track of the planets seen, in order, in the $\texttt{path}$ queue and keep track of the $\texttt{steps}$, the length of the path so far. When we reach a planet that has already been visited (call this planet the $\textit{repeat}$), add the $\texttt{pathlength}$ of the $\textit{repeat}$ to the current $\texttt{step}$ count because we would continue to visit all of the planets that $\textit{repeat}$ would go on to visit. 

Once we have $\texttt{path}$ and $\texttt{steps}$ (the $\texttt{pathlength}$ of the $\textit{start}$) we can calculate the $\texttt{pathlength}$ of all the planets in this $\texttt{path}$. We know the $\textit{repeat}$ will always be the planet at the end of the $\texttt{path}$, but it may appear elsewhere as well. We can break this down into two cases:
1. The $\textit{repeat}$ was visited twice in the current $\texttt{path}$. Let the planets in the $\texttt{path}$ between the two occurrences of the $\textit{repeat}$ be the $\textit{cycle}$.
2. The $\textit{repeat}$ was visited previously and only appears at the end of the current $\texttt{path}$. All of the planets in the $\texttt{path}$ are not part of a $\textit{cycle}$.

For planets inside a $\textit{cycle}$, the repeating planet when starting from that planet is itself. For all the planets outside the $\textit{cycle}$, the planet that repeats when starting from each planet will still be the $\textit{repeat}$.

Since the planets outside the $\textit{cycle}$ all have paths ending at the $\textit{repeat}$, each one's $\texttt{pathlength}$ is $1$ less than the previous'. So, as we iterate through the planets outside the $\textit{cycle}$, the $\texttt{pathlength}$ will decrease by $1$ each time, starting from $\texttt{steps}$. Once we get to the $\textit{cycle}$, the $\texttt{pathlength}$ of the planets will all be equal to the $\texttt{pathlength}$ of the $\textit{repeat}$, which is the length of the $\textit{cycle}$.

<LanguageSection>

<CPPSection>

## C++ Implementation

```cpp
#include <iostream>
#include <queue>
using namespace std;
void dfs(int planet);

bool visited[200000]{};
int destinations[200000];
int pathlength[200000]{};
queue<int> path;
int steps = 0;

int main()
{
	int n;
	cin >> n;
	for (int i = 0; i < n; i++)
	{
		cin >> destinations[i];
		destinations[i]--;
	}
	for (int i = 0; i < n; i++)
	{
		if (!visited[i])
		{
			steps = 0;
			dfs(i);
			int decrement = 1;
			//for each planet in current path, calculate pathlength
			while (!path.empty())
			{
				//we are in the cycle; all nodes have same pathlength
				if (path.front() == path.back())
				{
					decrement = 0;
				}
				pathlength[path.front()] = steps;
				steps -= decrement;
				path.pop();
			}
		}
	}
	for (int i = 0; i < n; i++)
	{
		cout << pathlength[i] << " ";
	}
	cout << endl;
	return 0;
}

void dfs(int planet)
{
	//add planet to path
	path.push(planet);
	if (visited[planet])
	{
		//add pathlength of the repeat planet to current step count
		steps += pathlength[planet];
		return;
	}
	visited[planet] = true;
	steps++;
	dfs(destinations[planet]);
}
```

</CPPSection>

<JavaSection>

## Java Implementation

```java

import java.util.*;
import java.io.*;

public class planetCycles {
    static int N, L;
    static int[] P, A;
    static boolean[] vis;
    static LinkedList<Integer> q = new LinkedList<>();
    public static void main(String[] args) throws IOException {
        Kattio in = new Kattio(System.in);

        N = in.getInt();
        P = new int[N+1];
        vis = new boolean[N+1];
        A = new int[N+1];
        for (int i = 1; i < N + 1; i++) {
            P[i] = in.getInt();
        }

        for (int i = 1; i < N + 1; i++) {
            if(!vis[i]){
                L = 0;
                dfs(i);
                int de = 1;
                Integer last = q.peekLast();
                while(!q.isEmpty()){
                    if(q.peekFirst().equals(last)) de = 0;
                    A[q.poll()] = L;
                    L-=de;
                }
            }
        }

        for (int i = 1; i < N + 1; i++) {
            System.out.print(A[i] + " ");
        }
    }

    public static void dfs(int n){
        vis[n] = true;
        q.add(n);
        L++;
        if(!vis[P[n]])
            dfs(P[n]);
        else
            q.add(P[n]); L += A[P[n]];

    }

    static class Kattio extends PrintWriter {
        public Kattio(InputStream i) {
            super(new BufferedOutputStream(System.out));
            r = new BufferedReader(new InputStreamReader(i));
        }
        public Kattio(InputStream i, OutputStream o) {
            super(new BufferedOutputStream(o));
            r = new BufferedReader(new InputStreamReader(i));
        }

        public boolean hasMoreTokens() {
            return peekToken() != null;
        }

        public int getInt() {
            return Integer.parseInt(nextToken());
        }

        public double getDouble() {
            return Double.parseDouble(nextToken());
        }

        public long getLong() {
            return Long.parseLong(nextToken());
        }

        public String getWord() {
            return nextToken();
        }



        private BufferedReader r;
        private String line;
        private StringTokenizer st;
        private String token;

        private String peekToken() {
            if (token == null)
                try {
                    while (st == null || !st.hasMoreTokens()) {
                        line = r.readLine();
                        if (line == null) return null;
                        st = new StringTokenizer(line);
                    }
                    token = st.nextToken();
                } catch (IOException e) { }
            return token;
        }

        private String nextToken() {
            String ans = peekToken();
            token = null;
            return ans;
        }
    }

}

```
</JavaSection>

</LanguageSection>