---
id: usaco-899
source: USACO Gold 2019 January
title: Shortcut
author: Ryan Chou
---

[Official Analysis (C++)](http://www.usaco.org/current/data/sol_shortcut_gold_jan19.html)

## Explanation

A simple brute-force approach would be to find the shortest path for all of the nodes, and then try to add a shortcut from $1$ to $i$ and find the shortest path again for all $i$.

Using this approach, the answer is $\min(\sum\limits_{i=0}^n \texttt{dist}-\texttt{short}_i)$, where $\texttt{dist}$ is the travel time that all cows take without a shortcut and $\texttt{short}_i$ represents the travel time that all cows take when there is a shortcut from $1$ to $i$. Although this will certainly TLE, it hints at a faster way to compute the time saved. 

Let's call $\texttt{occ}_i$ the number of cows that pass through field $i$. Then the answer would be $\max(\sum\limits_{i=0}^n \texttt{occ}_i \cdot (\texttt{trav}_i - T))$. $\texttt{trav}_i$ being the cost for one cow to get from field $i$ to $1$.

We can find the values for $\texttt{trav}_i$ quickly with [Djikstra's Algorithm](/gold/shortest-paths). To get $\texttt{occ}_i$, we'll store the parents of nodes during our Djikstra's Algorithm, so we can backtrack to get the counts of cows that pass through. This can be found in $\mathcal{O}(N^2)$ because $N \leq 10^4$.

## Implementation

**Time Complexity:** $\mathcal{O}(M\log N + N^2)$

<LanguageSection>
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	freopen("shortcut.in", "r", stdin);
	freopen("shortcut.out", "w", stdout);

	int n, m, t;
	cin >> n >> m >> t;

	vector<int> fields(n);
	for (int i = 0; i < n; i++) {
		cin >> fields[i];
	}

	// adj[i] = {travel time, adjacent node}
	vector<vector<pair<int, int>>> adj(n);
	for (int i = 0; i < m; i++) {
		int u, v, c;
		cin >> u >> v >> c;

		adj[--u].push_back({c, --v});
		adj[v].push_back({c, u});
	}

	// prev stores parents for backtracking
	vector<int> cost(n, INT32_MAX), prev(n, INT32_MAX);
	priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
	
	cost[0] = 0;
	// travel time, adjacent node
	pq.push({0, 0});
	while (pq.size()) {
		pair<int, int> nxt = pq.top();
		pq.pop();
		
		int ccost = nxt.first;
		int cnode = nxt.second;

		if (ccost != cost[cnode]) continue;

		for (pair<int, int> u : adj[cnode]) {
			// if this path is more optimal
			if (u.first + ccost < cost[u.second]) {
				cost[u.second] = u.first + ccost; 
				pq.push({u.first + ccost, u.second});
				prev[u.second] = cnode;
			// keep paths lexicographically minimum
			} else if (u.first + ccost == cost[u.second] && cnode < prev[u.second]) {
				prev[u.second] = cnode;
				pq.push({u.first + ccost, u.second});
			}
		}
	}

	vector<long long> occ(n, 0);
	// backtrack
	for (int i = 0; i < n; i++) {
		int cur = i;
		while (cur != INT32_MAX) {
			occ[cur] += fields[i];
			cur = prev[cur];
		}
	}

	long long ans = 0;
	for (int i = 0; i < n; i++) {
		ans = max(ans, (long long)(occ[i] * (cost[i] - t)));
	}
	cout << ans << '\n';
}
```
</CPPSection>
</LanguageSection>
