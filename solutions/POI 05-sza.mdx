---
id: poi-05-sza
source: POI 2005
title: Template
author: Andi Qu
---

Let the string be $S$.

<Spoiler title="Hint 1">

A template of $S$ is both a prefix and a suffix of $S$. This suggests that we should use KMP.

</Spoiler>

<Spoiler title="Hint 2">

If $T$ is a template of $S$ and $U$ is a template of $T$, then $U$ is also a template of $S$.

<Spoiler title="Proof">

Since $U$ is a template of $T$, we can make $T$ using $U$. Since $T$ is a template of $S$, we can make $S$ using $T$.

Therefore, we can also make $S$ using $U$ (i.e. it's a template of $S$).

</Spoiler>

</Spoiler>

<Spoiler title="Hint 3">

First, use KMP to compute the prefix function $\pi$ of $S$. The shortest template of $S$ is either $S$ itself or the shortest template of $S[0 : \pi[|S| - 1]]$.

<Spoiler title="Proof">
    
We'll prove instead that any template of $S$ that isn't $S$ itself is also a template of $S[0 : \pi[|S| - 1]]$, since that's equivalent.

Since $S[0 : \pi[|S| - 1]]$ is the longest proper prefix of $S$ that is also a suffix, we know that the only longer string that can be $S$'s template is $S$ itself. Let the shortest template of $S[0 : \pi[|S| - 1]]$ be $T'$ and some longer template of $S$ be $T$.

By hint 1, $T$ must be a prefix and suffix of $S$, which means that it's also a prefix and suffix of $S[0 : \pi[|S| - 1]]$.

This means that we can make at least half of $T$'s prefix using $T'$, since we can make $S[0 : \pi[|S| - 1]]$ (which is bigger than $T$) using $T'$ and $|T'| < |T|$. A similar argument holds for being able to make at least half of $T$'s suffix.

This implies that $T'$ is a template of $T$, as we can combine this prefix and suffix to form the whole string. Therefore $T$ is also a template of $S[0 : \pi[|S| - 1]]$.

</Spoiler>

</Spoiler>

<Spoiler title="Hint 4">

Don't be afraid to use KMP again!

</Spoiler>

<Spoiler title="Solution">

**Time complexity:** $\mathcal O(N)$.

First, we compute the prefix function $\pi$ of $S$ using KMP.

We then solve the following problem recursively: given a string, what's the length of its shortest template? We can do this as so:
1. Find the answer for the longest proper prefix of the string that's also a suffix.
2. Check whether this answer also works for the current string.
3. If it does, return that length; otherwise, return the length of the current string.

We will solve each step 2 using DP and another KMP in **amortized** $\mathcal O(N)$ time.

If we know where a candidate template matches in a given string, then we can also check whether it's a template in linear time. However, this will run in quadratic time overall if we're not careful.

The key observation is that since we know the candidate template is also a template of the longest proper prefix of the given string, then we only need to do the DP on the remaining part of the string. This means that we only need to process each character in $S$ in the DP at most once!

To find the matches just as efficiently, we run KMP on the same partial string in each recursive step.

```cpp
#include <bits/stdc++.h>
using namespace std;

string s;
int p[500000];

int shortest_template(int n) {
    if (!p[n - 1]) return n;
    int cand = shortest_template(p[n - 1]);
    for (int i = p[n - 1], j = cand, curr = p[n - 1] - 1; i < n; i++) {
        while (j && (j == cand || s[i] != s[j])) j = p[j - 1];
        if (s[i] == s[j]) j++;

        if (j == cand) curr = i;
        if (i - curr >= cand) return n;
    }
    return cand;
}

int main() {
    cin.tie(0)->sync_with_stdio(0);
    cin >> s;
    int n = s.size();
    for (int i = 1; i < n; i++) {
        p[i] = p[i - 1];
        while (p[i] && s[i] != s[p[i]]) p[i] = p[p[i] - 1];
        if (s[i] == s[p[i]]) p[i]++;
    }
    cout << shortest_template(n);
    return 0;
}
```

</Spoiler>
