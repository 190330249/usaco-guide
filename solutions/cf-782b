---
id: cf-782B
source: CF
title: The Meeting Place Cannot Be Changed
author: Aditya Gupta
---

[Official Analysis](https://codeforces.com/blog/entry/50854)

## Explanation

We can binary search on the location where the friends will meet up. Since we want a precision of $10^{-6}$, we stop when the difference between high and low is less than $10^{-6}$. 

Whenever we are calculating the answer, we take note of which side the maximum answer came from. If the max answer comes from both sides, regardless of where we, decide to go next, our answer will only increase, so we return that answer. Else, if it comes from only one side of the point that we just calculated, we move our search towards that side, as moving it towards the other side will only increase our answer. 

**Time Complexity:** $\mathcal{O}(N\log M)$ where $M$ is the farthest north location

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>

using namespace std;

typedef long long ll;

vector<double> locations;
vector<double> speeds;

double min_ans = (double) INT_MAX, curr_ans;
bool left_has_max = false, right_has_max = false;  // which side gives us max answer

double solve(double loc) {
	double curr_ans = 0;
	for (int i = 0; i < locations.size(); i++) {
		if (locations[i] == loc) {
			continue;
		}
		double i_time = abs(locations[i] - loc) / speeds[i];
		// amount of time for ith friend to get to loc
		if (i_time > curr_ans) {
			left_has_max = false;  // reset to false, as we have a new maximum
			right_has_max = false;
			if (locations[i] > loc) {
				right_has_max = true;
			} else {
				left_has_max = true;
			}
			curr_ans = i_time;
		} else if (i_time == curr_ans) {
			// We can have a max on both sides, so we don't reset the 2 booleans to false
			if (locations[i] > loc) {
				right_has_max = true;
			} else {
				left_has_max = true;
			}
		}
	}
	return curr_ans;
}

int main() {
	int n;
	cin >> n;
	locations.resize(n);
	speeds.resize(n);

	double low = 0;
	double high = 0;  // high will be the location of the farthest north friend
	double mid;
	
	for (int i = 0; i < n; i++) {
		cin >> locations[i];
		high = max(high,locations[i]);
	}
	for (int i = 0; i < n; i++) {
		cin >> speeds[i];
	}
	
	while (low < high && high - low > .000001) {
		mid = (high + low) / 2;
		curr_ans = solve(mid);  // gets answer if friends were to meet at mid
		min_ans = min(min_ans, curr_ans);
		if (left_has_max && right_has_max) {
			break; 
		} else if (left_has_max) {
			high = mid;
		} else {
			low = mid;
		}
	}

	cout << setprecision(13) << min_ans << endl;
}
```

</CPPSection>

</LanguageSection>
