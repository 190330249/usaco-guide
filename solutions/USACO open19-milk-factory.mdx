---
id: usaco-940
title: USACO 2019 December Bronze - Milk Factory
author: Jesse Choe
---

[Official Analysis](http://www.usaco.org/current/data/sol_factory_bronze_open19.html)

The solution provided by USACO can be solved more simply and efficiently using the Depth-First Search Algorithm (DFS). Since you are likely unfamiliar with what DFS is, please refer to this link to learn more about DFS: https://usaco.guide/silver/dfs.

My solution below uses DFS to traverse every connected node to the root node and see whether every node has been visited or not. To check whether each node has been visited, I will store a boolean array called visited to determine whether each node has been visited. I will check whether each node has been visited my defining a boolean function called all visited that returns true if all nodes are visited and false if not. Since the problem is asking for the lowest node such that you can get from any other node and arrive at the root node, I will search through each root node and increase the vertex of the node until every node is visited. If none of the nodes follow this property, then I will return -1 as said in the problem.

<LanguageSection>
<CPPSection>

## C++ Implementation

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using str = string;
using bb = bool;
using vl = vector<ll>;
using pl = pair<ll, ll>;
using vb = vector<bb>;
using vs = vector<str>;

#define FOR(i, a, b) for(ll i=a; i<(ll)b; ++i)
#define ROF(i, a, b) for(ll i=a-1; i>=b; --i)
#define TRAV(a, x) for(auto& a: x)
#define pb push_back
#define all(x) begin(x), end(x)
#define sor(x) sort(begin(x), end(x))

void setIO(string name="") { // name is nonempty for USACO file I/O
    ios_base::sync_with_stdio(0); cin.tie(0); 
    if((ll)name.size() > 0){
        freopen((name+".in").c_str(), "r", stdin);
        freopen((name+".out").c_str(), "w", stdout);
    }
}

vl adj[101]; vb visited(101); ll n;

void dfs(ll node){
	visited[node] = true;
	for(ll v: adj[node]){
		if(!visited[v]){
			dfs(v);
		}
	}
}

bool allVisited(){
	FOR(i, 0, n){
		if(!visited[i]){
			return false;
		}
	}
	return true;
}

int main(){
	setIO("factory");
	cin >> n;
	FOR(i, 0, n-1){
		ll a, b; cin >> a >> b;
		--a; --b;
		adj[b].pb(a);
	}
	FOR(i, 0, n){
		fill(all(visited), false);
		dfs(i);
		if(allVisited()){
			cout << i+1 << endl;
			return 0;
		}
	}
	cout << -1 << endl;
}

```

</CPPSection>
</LanguageSection>
