---
id: usaco-940
title: USACO 2019 December Bronze - Milk Factory
author: Jesse Choe
---

[Official Analysis](http://www.usaco.org/current/data/sol_factory_bronze_open19.html)

This problem can also be solved using Depth-First Search (a Silver topic). First, I must represent the graph as a directed unweighted graph. By setting $b_i$ as the starting node and $a_i$ as the ending node, we can recursively traverse this graph across each edge list for every node from $1 ... N$. With a boolean array, we can keep track of whether each node has been visited for the currently checked node. If it has, then we can print that node, otherwise, we print -1 if the visited array is never full for each node we traverse.

<LanguageSection>
<CPPSection>

## C++ Implementation

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using str = string;
using bb = bool;
using vl = vector<ll>;
using pl = pair<ll, ll>;
using vb = vector<bb>;
using vs = vector<str>;

#define FOR(i, a, b) for(ll i=a; i<(ll)b; ++i)
#define ROF(i, a, b) for(ll i=a-1; i>=b; --i)
#define TRAV(a, x) for(auto& a: x)
#define pb push_back
#define all(x) begin(x), end(x)
#define sor(x) sort(begin(x), end(x))

void setIO(string name="") { // name is nonempty for USACO file I/O
    ios_base::sync_with_stdio(0); cin.tie(0); 
    if((ll)name.size() > 0){
        freopen((name+".in").c_str(), "r", stdin);
        freopen((name+".out").c_str(), "w", stdout);
    }
}

vl adj[101]; vb visited(101); ll n;

void dfs(ll node){
	visited[node] = true;
	for(ll v: adj[node]){
		if(!visited[v]){
			dfs(v);
		}
	}
}

bool allVisited(){
	FOR(i, 0, n){
		if(!visited[i]){
			return false;
		}
	}
	return true;
}

int main(){
	setIO("factory");
	cin >> n;
	FOR(i, 0, n-1){
		ll a, b; cin >> a >> b;
		--a; --b;
		adj[b].pb(a);
	}
	FOR(i, 0, n){
		fill(all(visited), false);
		dfs(i);
		if(allVisited()){
			cout << i+1 << endl;
			return 0;
		}
	}
	cout << -1 << endl;
}

```

</CPPSection>
</LanguageSection>
