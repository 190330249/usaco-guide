---
id: usaco-1206
source: USACO Silver 2022 February
title: Redistributing Gifts
author: Chongtian Ma
---

[Official Analysis](http://www.usaco.org/current/data/sol_prob1_silver_feb22.html)

## Explanation

Similar to the official analysis, we can construct directed edges from $i$ to $j$ if cow $i$ prefers gift $j$ to gift $i$.
If cow $i$ is able to receive a gift where it has an outgoing edge, then the solution will always be more optimal. 
Remember to also add an edge between cow $i$ and $i$ in the case where it cannot get a more preferred gift.

Then, we can separate the graph into strongly connected components. If $i$ is in a strongly connected component, this means that cow $i$ can receive
all gifts in the strongly connected component through a series of reassignments based on SCC definition. It is also guaranteed to receive one 
or more preferred gifts (including the original assignment) since we are only adding these gifts as outgoing edges. If a cow does not belong in 
a strongly connected component, it cannot receive a more optimal reassignment.

## Implementation

Kosaraju's algorithm can be used to find all strongly connected components in the graph. At the end, it is optimal to just go down cow $i$'s preference list and assign the first gift belonging in the SCC.

**Time Complexity:** $\mathcal{O}(N^3)$

<LanguageSection>
<CPPSection>
```cpp
#include <bits/stdc++.h>

using namespace std;
const int N = 501;

// The adjacency lists for the graph (revgraph is reversed)
vector<int> graph[N], revgraph[N];
vector<bool> vis(N), vis2(N);
vector<int> path;

// stores all nodes in a SCC
set<int> comp;

void dfs(int node) {
	vis[node] = true;
	for (int i: graph[node]) {
		if (!vis[i]) {
			dfs(i);
		}
	}
	path.push_back(node);
}

void dfs2(int node) {
	vis2[node] = true;
	for (int i: revgraph[node]) {
		if (!vis2[i]) {
			dfs2(i);
		}
	}
	comp.insert(node);
}

int main() {
	int n;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		// The graph array contains the cow i's preferred gifts (and itself).
		graph[i].resize(n);
		for (int j = 0; j < n; j++) {
			cin >> graph[i][j];
		}
		/*
		 * We don't want edges to non-preferred gifts,
		 * so we remove all gifts after its original assignment.
		 */
		while (graph[i].back() != i) {
			graph[i].pop_back();
		}
		for (int j : graph[i]) {
			revgraph[j].push_back(i);
		}
	}

	// classic kosaraju implementation
	for (int i = 1; i <= n; i++) {
		if (!vis[i]) {
			dfs(i);
		}
	}
	
	reverse(path.begin(), path.end());

	vector<int> ans(n + 1);
	for (int i: path) {
		if (!vis2[i]) {
			dfs2(i);
			/*
			 * Loop over all cows in the SCC and its preference list.
			 * If a gift is found in its preference and also in the SCC,
			 * just assign the it to the cow.
			 */
			for (int j: comp) {
				for (int k: graph[j]) {
					if (comp.count(k)) {
						ans[j] = k;
						break;
					}
				}
			}
			comp.clear();
		}
	}
	
	for (int i = 1; i <= n; i++) {
		cout << ans[i] << endl;
	}
}
```  
</CPPSection>
</LanguageSection>
