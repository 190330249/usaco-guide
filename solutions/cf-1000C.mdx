---
id: cf-1000C
source: CF
title: Covered Points COunt
author: Jesse Choe
---

[Official Editorial](http://codeforces.com/blog/entry/60288)


# Solution (Coordinate Compression)

Due to the large constraints on $l_i$ and $r_i$, it is impossible to apply brute force the number of intersecting segments for each point on the coordinate line. Nonetheless, we can compress the coordinates and "pretend" as if the coordinates were between $1$ and $n$.

This allows us to apply prefix sums on each point in our compressed "number line" and retransform these compressed coordinates to the original endpoints $l_i$ and $r_i$. To compress the coordinates, we can either sort the coordinates or use a `HashMap`.

**Time Complexity:** $\mathcal{O}(N\log N)$

<LanguageSection>

<CPPSection>

### Implementation

```cpp
#include <bits/stdc++.h>

using namespace std;
using ll = long long;
using vi = vector<int>;
using pi = pair<int, int>;

#define f first
#define s second
#define all(x) begin(x), end(x)

int main(){
	int n; cin >> n;
	vector<pair<ll, ll>> a(n);
	set<ll> points; // This stores only the unique endpoints (also, the endpoints will be in sorted order).
	for(int i = 0; i < n; i++){
		cin >> a[i].f >> a[i].s; // Read in the endpoints of the i-th segment
		points.insert(a[i].f);
		points.insert(a[i].s + 1); 
		// This ensures that only the unique points are stored
	}
	int cur = 0; map<ll, int> mp; // This map stores the compressed coordinates.
	vector<ll> coords;
	for(auto& a: points){
		mp[a] = cur; // Assign "a" to cur, where cur is our compressed coordinate for "a".
		coords.push_back(a); // We still need to remember our original endpoints so we can retransform the compressed coordinates
		cur++;
	}
	vi freq(2 * n); // This stores the frequency of a given endpoint. However, we will use the compressed endpoints rather than the original ones :).
	for(int i = 0; i < n; i++){
		// A segment starts from [l*, r*], so we should end the segment at r* + 1 to ensure that r* is included into the segment.
		freq[mp[a[i].f]]++;
		freq[mp[a[i].s + 1]]--;
	}
	// This counts how many points are at a given compressed endpoint using prefix sums.
	for(int i = 1; i < 2 * n; i++){
		freq[i] += freq[i - 1];
	}
	vector<ll> ans(n + 1); // This is equivalent to the cnt array. ans[i] stores cnt[i]
	for(int i = 1; i < coords.size(); i++){
		ans[freq[i - 1]] += coords[i] - coords[i - 1]; // We add r - l to the number of points for a given frequency since we compressed the coordinates
	}
	for(int i = 1; i <= n; i++){
		cout << ans[i] << " "; // Print out the answer here
	}
	cout << endl;
}
```

</CPPSection>

</LanguageSection>
