---
id: usaco-849
source: USACO Silver 2019 January
title: Grass Planting
author: Aadit Ambadkar
---

## Solution 1 (Smart & Intended Solution)

$\mathcal{O}(N)$ using key insight.

Let ```adj[i]``` represent the number of paths adjacent to node $i$ in the graph. Then, considering that node, and that node alone, you would need exactly ```adj[i]+1``` numbers to fill it. This is because you would need ```adj[i]``` for each of the adjacent nodes, and $1$ for the node itself. So, our answer is the maximum of all the adjacents, plus 1. My Java code is below.

```java
import java.io.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.StringTokenizer;

public class planting {
    public static void main(String[] args) throws IOException {
        BufferedReader f = new BufferedReader(new FileReader("planting.in"));
        PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter("planting.out")));
        StringTokenizer st = new StringTokenizer(f.readLine());
        int n = Integer.parseInt(st.nextToken());
        if (n==1) {
            pw.println(1);
            pw.close();
        } else if (n==2) {
            pw.println(2);
            pw.close();
        }
        int[] adj = new int[n];
        Arrays.fill(adj, 1);
        int max=1;
        for (int i = 0; i < n-1; i++) {
            st = new StringTokenizer(f.readLine());
            int ne = Integer.parseInt(st.nextToken())-1;
            if (++adj[ne]>adj[max]) max=ne;
            ne = Integer.parseInt(st.nextToken())-1;
            if (++adj[ne]>adj[max]) max=ne;
        }
        pw.println(adj[max]);
        pw.close();
    }
}
```

## Solution 2 (DFS, not intended)

This can also be solved using DFS in $\mathcal{O}(V+E)=\mathcal{O}(N+N-1)=\mathcal{O}(2N-1)$, which is linear time (although slightly slower than the previous solution), enough to pass for all testcases. The implementation is straight forward. My java code for this is below:

```java
import java.io.*;
import java.util.*;

public class Main {
    public static int[] visited;
    public static ArrayList<ArrayList<Integer>> adj;

    public static void main(String[] args) throws IOException {
        BufferedReader f = new BufferedReader(new FileReader("planting.in"));
        PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter("planting.out")));
        StringTokenizer st = new StringTokenizer(f.readLine());
        int farms = Integer.parseInt(st.nextToken());
        adj = new ArrayList<>();
        for (int i = 0; i < farms; i++) {
            adj.add(new ArrayList<Integer>());
        }
        for (int i = 0; i < farms - 1; i++) {
            st = new StringTokenizer(f.readLine());
            int a = Integer.parseInt(st.nextToken());
            int b = Integer.parseInt(st.nextToken());
            adj.get(a - 1).add(b - 1);
            adj.get(b - 1).add(a - 1);
        }
        visited = new int[farms];
        Arrays.fill(visited, 0);
        visited[0] = 1;
        dfs(0, 0);
        int max = 0;
        for (int i : visited) {
            max = Math.max(max, i);
        }
        pw.println(max);
        pw.close();
    }

    public static void dfs(int self, int parent) {
        int len = adj.get(self).size();
        int g = 1;
        for (int i : adj.get(self)) {
            if (i != parent) {
                while (g == visited[self] || g == visited[parent]) g++;
                visited[i] = g;
                dfs(i, self);
                g++;
            }
        }
    }
}
```
