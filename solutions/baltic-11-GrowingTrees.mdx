---
id: baltic-11-GrowingTrees
source: Baltic OI 2011
title: Growing Trees
author: Dong Liu
---

**Time Complexity**: $\mathcal O(N\log N + Q\log^2 N)$

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

template<class T> struct FT {
	int n; vector<T> ft;

	void init(int n_) {
		n = n_;
		ft.assign(n_, 0);
	}
	void add(int l, int r, T x) { // add x to [l, r] 
		if (r < l)
			return;
		for ( ; l < n; l |= l + 1)
			ft[l] += x;
		for ( ++r; r < n; r |= r + 1)
			ft[r] -= x;
	}
	T query(int i) { // point query at i
		T sum = 0;
		for ( ; i >= 0; i &= i + 1, --i) sum += ft[i];
		return sum;
	}
};

#define N	100000

int n, q, a[N];
FT<int> ft;

template<class T, class U> T firstTrue(T lo, T hi, U f) {
	assert(lo <= hi); ++hi; // assuming f is increasing
	while (lo < hi) { // find first index such that f is true 
		T mid = lo + (hi - lo) / 2;
		f(mid) ? hi = mid : lo = mid + 1; 
	} 
	return lo;
}

int main() {
	ios::sync_with_stdio(false); cin.tie(NULL);

	cin >> n >> q;
	ft.init(n);
	for (int i = 0; i < n; ++i)
		cin >> a[i];
	sort(a, a + n);
	for (int i = 0; i < n; ++i)
		ft.add(i, i, a[i]);
	for (int i = 0; i < q; ++i) {
		char c; int a, b;

		cin >> c >> a >> b;
		if (c == 'F') {
			int l = firstTrue(0, n - 1, [&](int i) {
				return ft.query(i) >= b;
			});
			if (l == n) // found nothing
				continue;
			int r = l + a - 1;
			if (r >= n - 1) {
				ft.add(l, n - 1, 1);
				continue;
			}
			int x = ft.query(r);
			int l_ = firstTrue(l, n - 1, [&](int i) {
				return ft.query(i) >= x;
			});
			int r_ = firstTrue(l_, n - 1, [&](int i) {
				return ft.query(i) > x;
			});
			ft.add(l, l_ - 1, 1);
			int size = a - (l_ - l);
			ft.add(r_ - size, r_ - 1, 1);
		} else {
			int l = firstTrue(0, n - 1, [&](int i) {
				return ft.query(i) >= a;
			});
			int r = firstTrue(0, n - 1, [&](int i) {
				return ft.query(i) > b;
			});
			cout << r - l << '\n';
		}
	}
}
```

</CPPSection>

</LanguageSection>