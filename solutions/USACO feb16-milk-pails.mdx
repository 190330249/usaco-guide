---
id: usaco-620
source: USACO Silver 2016 February
title: Milk Pails
author: Ã“scar Garries, Neo Wang
---

[Official Analysis](http://www.usaco.org/current/data/sol_pails_silver_feb16.html)

<LanguageSection>
<CPPSection>

## C++ Implementation (BFS)

We can directly simulate all operations using BFS.

When we are performing our BFS, we only have to keep track of the amount of operations used so far for the current amount of milk in pails $X$ and $Y$. That way, we can check all nodes with distance $\le K$ once our BFS is finished, and then compute the smallest value of  $|i + j -M|$.

In our matrix, the current amount of milk in $X$ is $i$, and $Y$ is $j$.

For every step, we simulate all the possible actions.

1. Fill either pail completely to the top: set $i$ to $X$ or $j$ to $Y$.
2. Empty either pail: set $i$ or $j$ to $0$.
3. Pour the contents of one pail into another without overflowing.

To perform operation 3, let the quantity to be poured $Q$ be denoted by either $Q_x=\min(i, X - j)$ or $Q_y=\min(j, Y-i)$, depending on which bucket is poured ($Q_x$ if we are pouring out of $x$ and vice versa). Then, to pour $X$ into $Y$, we subtract this poured quantity $Q_x$ from $X$ and add it to $Y$. In other words, if we were to pour $X$ into $Y$, the new amount in $X$ would be $X - Q_x$, and the new amount in $Y$ is $Y + Q_x$. To pour $Y$ into $X$, this would be $Y_{\textrm{new}}=Y-Q_y$, $X_{\textrm{new}}=X+Q_y$.

Now, to compute the smallest $|i+j-M|$, simply scan over all elements where $A[i][j] \le K$.


```cpp
#include <bits/stdc++.h>

using namespace std;

#define FOR(i, a, b) for(int i = (a); i < (b); i++)
#define FORE(i, a, b) for(int i = (a); i <= (b); i++)
#define F0R(i, a) for(int i = 0; i < (a); i++)
#define trav(a, x) for (auto& a : x)

int X, Y, K, M;

const int MX = 101;
const int MOD = 1e9 + 7;

int dist[MX][MX];

void setIn(string s) { freopen(s.c_str(),"r",stdin); }
void setOut(string s) { freopen(s.c_str(),"w",stdout); }

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);

    setIn("pails.in");
    setOut("pails.out");

    cin >> X >> Y >> K >> M;

    F0R(i, MX) F0R(j, MX) dist[i][j] = MOD;

    queue<pair<int, int>> bfs;
    bfs.push({0, 0});
    dist[0][0] = 0;

    while(!bfs.empty()) {
        pair<int, int> top = bfs.front();
        bfs.pop();
        int ndist = dist[top.first][top.second]+1;

        int pourX = min(top.first, Y - top.second);
        int pourY = min(top.second, X - top.first);

        int nx[] = {top.first, 0, X, top.first, top.first - pourX, top.first + pourY }; // all possible pours
        int ny[] = {0, top.second, top.second, Y, top.second + pourX, top.second - pourY };

        F0R(i, 6) {
            if(ndist > K || dist[nx[i]][ny[i]] != MOD) continue;
            dist[nx[i]][ny[i]] = ndist;
            bfs.push({nx[i], ny[i]});
        }
    }

    int ret = MOD;

    F0R(i, MX) {
        F0R(j, MX) {
            if(dist[i][j] != MOD) ret = min(ret, abs(M - (i+j)));
        }
    }

    cout << ret << endl;
}
```

## C++ Implementation (DFS)

```cpp
#include <bits/stdc++.h>

using namespace std;

bool vis[101][101][101];
int x, y, k, m, sol;

void ff (int curX, int curY, int curK) {
	if (vis[curX][curY][curK] || curK > k) return;
	vis[curX][curY][curK] = true;

	sol = min (sol, abs(m - (curX + curY)));
	//case 1
	ff (x, curY, curK + 1);
	ff (curX, y, curK + 1);
	//case 2
	ff (0, curY, curK + 1);
	ff (curX, 0, curK + 1);
	//case 3
	int leftoverX = (curX + curY > y ? curX + curY - y : 0);
	int leftoverY = (curY + curX > x ? curY + curX - x : 0);

	ff (leftoverX, min(y, curY + curX), curK + 1);
	ff (min(x, curX + curY), leftoverY, curK + 1);

}

int main () {
	freopen("pails.in", "r", stdin);
	freopen("pails.out", "w", stdout);

	cin >> x >> y >> k >> m;
	sol = m;
	ff (0, 0, 0);
	cout << sol << '\n';
}

```

</CPPSection>
</LanguageSection>
