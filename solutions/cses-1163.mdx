---
id: cses-1163
source: CSES
title: Traffic Lights
author: Danh Ta Chi Thanh, Ben Dodge
---

<LanguageSection>
<CPPSection>
In this problem, we are given an empty interval of length $x$ spanning from 0 to
$x$, and $n$ points are added to the interval chronologically. We want to find
the largest gap between the points after each step.

## Solution 1

First you can read and think more about the solution here:
[Unofficial Editorial](https://codeforces.com/blog/entry/83295) (and also here:
[Sketch](https://codeforces.com/blog/entry/86096?#comment-739122))

I will try to explain it: Let's create a set and a multiset. The set will store
the positions of the traffic lights, while the multiset will keep track of the
"gaps" between the lights. The multiset keeps expanding because more lights are
added, and you just need to print the length of the longest passage without
traffic lights after each addition (i.e. the max element of that multiset). This
element is the last element by default.

Note that when placing a new traffic light on the road, that light will split
the gap between two adjacent lights into two smaller pieces, so you also have to
remove the length of that gap in the multiset and add two new lengths to the
multiset.

```cpp
#include <bits/stdc++.h>

using namespace std;

//constant initialization
const int maxn=2e5+10;

//variables used for the current problem
int x,n,p; set<int> lights; multiset<int> dist;

void solve() {
	cin >> x >> n;
	lights.insert(0); lights.insert(x);
	dist.insert(x);
	for (int i=0;i<n;++i){
		cin >> p;
		auto it1 = lights.upper_bound(p),it2 = it1; --it2;
		dist.erase(dist.find(*it1-*it2));
		dist.insert(p-*it2); dist.insert(*it1-p);
		lights.insert(p);
		auto ans = dist.end(); --ans;
		cout << *ans << " ";
	}
}

int main(){
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	solve();
	return 0;
}
```

## Solution 2 - Reversing the steps

I found another solution by reversing all the steps and calculating the maximum
length at each step. Here is my implementation.

```cpp
#include <bits/stdc++.h>

using namespace std;

//constant initialization
const int maxn=2e5+10;

//variables used for the current problem
int x,n,p[maxn],mx; set<int> st; vector<int> ans;

void solve() {
	cin >> x >> n;
	st.insert(0); st.insert(x);
	for (int i=0;i<n;++i){
		cin >> p[i]; st.insert(p[i]);
	}
	for (auto it = ++st.begin(); it != st.end();++it){
		auto it2=it; --it2;
		mx=max(*it-*it2,mx);
	}
	ans.push_back(mx);
	for (int i=n-1;i>0;--i){
		auto it = st.upper_bound(p[i]),it2=it; --it2; if (*it2) --it2;
		mx=max(*it-*it2,mx);
		ans.push_back(mx);
		st.erase(st.find(p[i]));
	}
	reverse(ans.begin(),ans.end());
	for (int res : ans) cout << res << " ";
}

int main(){
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	solve();
	return 0;
}
```

</CPPSection>
<JavaSection>
## Implementation
[Unofficial Editorial (C++)](https://codeforces.com/blog/entry/83295)

**Time Complexity:** $\mathcal{O}(n)$

We'll start by trying to find the maximum
gap once all the traffic lights are added. This is the last thing we'll output,
so we'll add it to the end of our output array. Then, we'll remove traffic
lights in the reverse order to how they were added, and find the gap each
removal creates.

This gap is just the distance between the two street coordinates (either a
traffic light or the beginning or ending of the street) next to a given traffic
light stored in our set, so we can use our set to find these values and subtract
them to get our gap.

But this gap may not be the maximum gap. We'll compare this to the gap we found
once all the traffic lights are added, and set the max gap to the greater value.
We'll then set the next lowest element in the output array to this value, which
will represent the greatest gap prior to adding the traffic light we just
removed.

<Warning>
We have to use some nonstandard io (input/output) to pass all test cases in the allowed time on CSES, because of its slow grader. 
</Warning>
```java
import java.io.*;
import java.util.*;

public class TrafficLights {
	public static void main(String[] args) throws IOException {
		BufferedReader r = new BufferedReader(new InputStreamReader(System.in));
		PrintWriter pw = new PrintWriter(System.out);
		StringTokenizer st = new StringTokenizer(r.readLine());

		int streetLength = Integer.parseInt(st.nextToken());
		int lightNum = Integer.parseInt(st.nextToken());

		// Using an array to read values since we can't get values from sets in Java
		int[] opArray = new int[lightNum];
		TreeSet<Integer> streetPositions = new TreeSet<>();
		// Initialize the set with beginning and ending values
		streetPositions.add(0);
		streetPositions.add(streetLength);
		st = new StringTokenizer(r.readLine());

		for (int i = 0; i < lightNum; i++) {
			int nextTrafficLight = Integer.parseInt(st.nextToken());
			opArray[i] = nextTrafficLight;
			streetPositions.add(nextTrafficLight);
		}
		r.close();

		int[] gapsArray = new int[lightNum];
		int prev = 0;
		int maxGap = 0;
		// Find the longest passage once all the streetlights are added
		for (int i : streetPositions) {
			maxGap = Math.max(i - prev, maxGap);
			prev = i;
		}
		gapsArray[lightNum - 1] = maxGap;
		/*
		 * Remove the streetlights in reverse order to how they were added, then find
		 * the gap created by removing each. Find the biggest current gap, and 
		 * add it to the next lowest index in answer.
		 */
		for (int i = lightNum - 1; i > 0; i--) {
			streetPositions.remove(opArray[i]);
			int low = streetPositions.lower(opArray[i]);
			int high = streetPositions.higher(opArray[i]);
			maxGap = Math.max(maxGap, high - low);
			gapsArray[i - 1] = maxGap;
		}
		//  Use StringBuilder to print out the array quicker
		StringBuilder sb = new StringBuilder();
		for (int i : gapsArray) {
			sb.append(i).append(" ");
		}
		pw.println(sb);
		pw.close();
	}
}

```

</JavaSection>
</LanguageSection>

