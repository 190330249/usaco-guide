---
id: cses-1202
source: CSES
title: Investigation
author: Andrew Wang
---

## Explanation

We can run Dijkstra keeping track of
- the distance: $\texttt{dist}[]$
- the number of ways with the minimum distance: $\texttt{num}[]$
- the minimum flights with the minimum distance: $\texttt{minf}[]$, and 
- the maximum flights with the minimum distance: $\texttt{maxf}[]$.

For every node, $v$, we take into consideration all of its neighbors, $u$. If we
can reach $u$ in a shorter distance than its current minimum, we update the
distance and reset $\texttt{num}[u]$, $\texttt{minf}[u]$, and $\texttt{maxf}[u]$.

We also have to take into
consideration if we can reach $u$ in an equivalent distance. If so, we update:

$$
\texttt{num}[u] = \texttt{num}[v] + \texttt{num}[u]
$$

$$
\texttt{minf}[u] = \min(\texttt{minf}[u], \texttt{minf}[v] + 1)
$$

$$
\texttt{maxf}[u] = \max(\texttt{maxf}[u], \texttt{maxf}[v] + 1)
$$

## Implementation

**Time Complexity:** $\mathcal{O}((N + M)\log N)$

<LanguageSection>
	
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

typedef long long ll;

const int MAXN = 100001;
const ll MAX = 0x3f3f3f3f3f3f3f3f;
const int MOD = 1000000007;

vector<pair<ll, int>> edge[MAXN];
ll dist[MAXN], num[MAXN];
int minf[MAXN], maxf[MAXN];
bool v[MAXN];

void djikstra(int s) {
	priority_queue<pair<ll, int>, vector<pair<ll, int>>, greater<pair<ll, int>>> pq;
	pq.push({dist[s] = 0, s});
	num[s] = 1;
	while (!pq.empty()) {
		auto [cost, vert] = pq.top(); pq.pop();
		if (!v[vert]) {
			v[vert] = true;
			for (auto [cost, next] : edge[vert]) {
				ll alt = cost + dist[vert];
				if (alt == dist[next]) {
					num[next] = (num[next] + num[vert]) % MOD;
					minf[next] = min(minf[next], minf[vert] + 1);
					maxf[next] = max(maxf[next], maxf[vert] + 1);
				} else if(alt < dist[next]) {
					num[next] = num[vert];
					minf[next] = minf[vert] + 1;
					maxf[next] = maxf[vert] + 1;
					pq.push({dist[next] = alt, next});
				}
			}
		}
	}
}
int main() {
	ios_base::sync_with_stdio(0); cin.tie(0);
	int n, m; cin >> n >> m;
	for (int i = 0; i < m; i++) {
		int a, b, c; cin >> a >> b >> c;
		edge[a].push_back({c, b});
	}
	for (int i = 0; i < MAXN; i++) {
		dist[i] = MAX;
		num[i] = 0;
		minf[i] = 0;
		maxf[i] = 0;
	}
	djikstra(1);
	cout << dist[n] << " " << num[n] << " " << minf[n] << " " << maxf[n];
	return 0;
}
```

</CPPSection>

</LanguageSection>
