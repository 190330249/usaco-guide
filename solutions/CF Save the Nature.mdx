---
id: cf-1223C
source: CF
title: Save the Nature
author: Jesse Choe, Kevin Sheng
---

[Official Editorial](https://codeforces.com/blog/entry/66993)

Binary search on the answer for the minimum number of tickets, which we call $t$, to sell to make the total ecological contribution to at least $k$. 

To check if a certain number of tickets reaches a minimal contribution of $k$, we can observe that in order to minimize the number of tickets sold, we should maximize the total revenue from selling these tickets. If, however, it is impossible to sell at least $k$ tickets after selling all tickets, then output $-1$.

Additionally, the problem indicates that only $x\%$ of the $a$-th ticket and $y\%$ of the $b$-th ticket could contribute to the total ecological contribution. Thus, we can iterate over every $a$-th ticket and $b$-th ticket at most $t$ and add $x\%$ to the total percentages contributing to an ecological program for each $a$-th ticket and $y\%$ for each $b$-th ticket, which we can store in $pct$.

It suffices to sort the tickets and percentages in decreasing order. Our total ecological contribution is $\sum\limits_{i=1}^{t} p_i \cdot pct_i$.

We can move the binary search forward by comparing the amount of money we came up with with the amount of money required

# Solution 

**Time Complexity:** $\mathcal{O}(N\log^2 N)$

<LanguageSection>

<CPPSection>

### C++ Implementation

```cpp
#include <bits/stdc++.h>

using namespace std;
using ll = long long;
using vl = vector<ll>;

int n; vl p;
ll x, a, y, b, k;

bool works(int sellTickets){
        vl percentages(sellTickets);
        // Add x% to every a-th ticket.
        for(int i = a - 1; i < sellTickets; i += a){
            percentages[i] += x;
        }
        // Add y% to every b-th ticket
        for(int i = b - 1; i < sellTickets; i += b){
            percentages[i] += y;
        }
        sort(percentages.begin(), percentages.end(), greater<ll>());
        ll cur = 0;
        for(int i = 0; i < sellTickets; i++){
            cur += percentages[i] * p[i] / 100;
        }
        return cur >= k;
}

void solve(int t){
        cin >> n;
        p.resize(n);
        for(int i = 0; i < n; i++){
            cin >> p[i];
        }
        sort(p.begin(), p.end(), greater<ll>());
        cin >> x >> a >> y >> b >> k;
        int l = 0, r = n, ans = -1;
        while(l <= r){
            int mid = l + (r - l) / 2;
            if(works(mid)){
                ans = mid;
                r = mid - 1;
            } else {
                l = mid + 1;
            }
        }
        cout << ans << endl;
}

int main(){
        int q; cin >> q;
        for(int i = 1; i <= q; i++){
            solve(i);
        }
}
```

</CPPSection>

<JavaSection>
    
### Java Implementation

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.Arrays;
import java.util.Comparator;

public final class SaveNature {
        public static void main(String[] args) throws IOException {
                BufferedReader read = new BufferedReader(new InputStreamReader(System.in));
                int queryNum = Integer.parseInt(read.readLine());
                for (int q = 0; q < queryNum; q++) {
                        int ticketNum = Integer.parseInt(read.readLine());
                        long[] tickets = Arrays.stream(read.readLine().split(" ")).mapToLong(Long::parseLong).toArray();
                        Arrays.sort(tickets);

                        // first the percentage of the proceeds, then the frequency
                        int[] prog1 = Arrays.stream(read.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
                        int[] prog2 = Arrays.stream(read.readLine().split(" ")).mapToInt(Integer::parseInt).toArray();
                        long minRevenue = Long.parseLong(read.readLine());
                        long comboFreq = (long) prog1[1] * prog2[1] / gcd(prog1[1], prog2[1]);

                        int lo = 0;
                        int hi = ticketNum;
                        int valid = -1;
                        while (lo <= hi) {
                                int mid = (lo + hi) / 2;
                                int[][] helpChances = new int[][] {
                                        {prog1[0] + prog2[0], ((int) (mid / comboFreq))},
                                        {prog1[0], (int) (mid / prog1[1] - mid / comboFreq)},
                                        {prog2[0], (int) (mid / prog2[1] - mid / comboFreq)}
                                };
                                Arrays.sort(helpChances, Comparator.comparingInt(c -> -c[0]));

                                int ticketAt = ticketNum - 1;
                                long revenue = 0;
                                for (int[] chance : helpChances) {
                                    for (int i = 0; i < chance[1]; i++) {
                                        revenue += tickets[ticketAt--] * chance[0] / 100;
                                    }
                                }

                                if (revenue >= minRevenue) {
                                    valid = mid;
                                    hi = mid - 1;
                                } else {
                                    lo = mid + 1;
                                }
                        }
                        System.out.println(valid);
                    }
        }

    private static int gcd(int a, int b) {
            return b == 0 ? a : gcd(b, a % b);
    }
}
```

</JavaSection>

<PySection>
    
### Python Implementation

```py
from math import gcd

for _ in range(int(input())):
    ticket_num = int(input())
    tickets = sorted([int(i) for i in input().split()], reverse=True)
    prog1 = [int(i) for i in input().split()]
    prog2 = [int(i) for i in input().split()]
    min_revenue = int(input())
    combo_freq = prog1[1] * prog2[1] // gcd(prog1[1], prog2[1])

    lo = 0
    hi = ticket_num
    valid = -1
    while lo <= hi:
        mid = (lo + hi) // 2
        help_chances = sorted([
            [prog1[0] + prog2[0], mid // combo_freq],
            [prog1[0], mid // prog1[1] - mid // combo_freq],
            [prog2[0], mid // prog2[1] - mid // combo_freq],
        ], reverse=True)

        ticket_at = 0
        revenue = 0
        for ch in help_chances:
            for _ in range(ch[1]):
                revenue += tickets[ticket_at] * ch[0] // 100
                ticket_at += 1

        if revenue >= min_revenue:
            valid = mid
            hi = mid - 1
        else:
            lo = mid + 1
    print(valid)
```
    
</PySection>

</LanguageSection>
