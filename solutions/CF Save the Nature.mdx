---
id: cf-1223C
source: CF
title: Save the Nature
author: Jesse Choe, Kevin Sheng
---

[Official Editorial](https://codeforces.com/blog/entry/66993)

Binary search on the answer for the minimum number of tickets, which we call $t$, to sell to make the total ecological contribution to at least $k$. 

To check if a certain number of tickets reaches a minimal contribution of $k$, we can greedily observe that in order to minimize the number of tickets sold, we should maximize the total revenue from selling these tickets. If, however, it is impossible to sell at least $k$ tickets after selling all tickets, then output $-1$.

Additionally, the problem indicates that only $x\%$ of the $a$-th ticket and $y\%$ of the $b$-th ticket could contribute to the total ecological contribution. Thus, we can iterate over every $a$-th ticket and $b$-th ticket at most $t$ and add $x\%$ to the total percentages contributing to an ecological program for each $a$-th ticket and $y\%$ for each $b$-th ticket, which we can store in $pct$.

It suffices to sort the tickets and percentages in decreasing order. Our total ecological contribution is $\sum\limits_{i=1}^{t} p_i \cdot pct_i$.

All that remains is to check whether the total sum of ecological contribution is at least $k$, which can be done in constant time.

# Solution 

**Time Complexity:** $\mathcal{O}(N\log^2 N)$

<LanguageSection>

<CPPSection>

### C++ Implementation

```cpp
#include <bits/stdc++.h>

using namespace std;
using ll = long long;
using vl = vector<ll>;

int n; vl p;
ll x, a, y, b, k;

bool works(int sellTickets){
    vl percentages(sellTickets);
    // Add x% to every a-th ticket.
    for(int i=a-1; i<sellTickets; i+=a){
        percentages[i] += x;
    }
    // Add y% to every b-th ticket
    for(int i=b-1; i<sellTickets; i+=b){
        percentages[i] += y;
    }
    sort(percentages.begin(), percentages.end(), greater<ll>());
    ll cur = 0;
    for(int i=0; i<sellTickets; i++){
        cur += percentages[i]*p[i]/100;
    }
    return cur >= k;
}

void solve(int t){
    cin >> n;
    p.resize(n);
    for(int i=0; i<n; i++){
        cin >> p[i];
    }
    sort(p.begin(), p.end(), greater<ll>());
    cin >> x >> a >> y >> b >> k;
    int l = 0, r = n, ans = -1;
    while(l <= r){
        int mid = l + (r-l) / 2;
        if(works(mid)){
            ans = mid;
            r = mid-1;
        } else {
            l = mid+1;
        }
    }
    cout << ans << endl;
}

int main(){
    int q; cin >> q;
    for(int i=1; i<=q; i++){
        solve(i);
    }
}
```

</CPPSection>

</LanguageSection>
