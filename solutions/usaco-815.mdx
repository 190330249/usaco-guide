---
id: usaco-815
source: USACO Gold 2018 Febuary
title: Taming the Herd
author: Shijie Ren
---

[Official Analysis (C++)](http://www.usaco.org/current/data/sol_taming_gold_feb18.html)

## Explanation

Let $\texttt{dp}[i][j]$ be the the minimum number of changes that must be made to the first j entries
so that there are i breakouts among the first j entries.

If $j$-th entry is NOT tampered


On the $j$-th day, there's 3 cases:

- If log is tampered and cows would NOT breakout:

$$
\texttt{dp}[i][j]=\texttt{dp}[i][j-1]+1
$$

- If log is tampered and cows would breakout (So $a[j] \not = 0$):

$$
\texttt{dp}[i][j]=\texttt{dp}[i-1][j-1]+1
$$

- If log is NOT tampered (Then $i$-th breakout will be on $(j-a[j])$-th day):

$$
\texttt{dp}[i][j] = \texttt{dp}[i-1][j-a[j]-1]+\texttt{range\_ans}[j-a[j]][j]);
$$

$$\texttt{range\_ans}[l][r]$$ represents minimum cost to replace range
$a[l]...a[r]$ with $0...(r-l)$ respectively.

So if the state meets the conditions,

$$
\texttt{dp}[i][j] = \max \{ \texttt{dp}[i][j-1]+1 ,\texttt{dp}[i-1][j-1]+1 ,\texttt{dp}[i-1][j-a[j]-1] + \texttt{range\_ans}[j-a[j]][j]) \}
$$

## Implementation

**Time Complexity:** $\mathcal{O}(N^2)$

<LanguageSection>

<CPPSection>

```cpp
#include <algorithm>
#include <cstdio>
#include <cstring>
#include <iostream>
const int N = 105;
const int inf = 0x3fffffff;
#define byteinf 0x3f
using namespace std;
int main() {
	freopen("taming.in", "r", stdin);
	freopen("taming.out", "w", stdout);

	int n;
	cin >> n;

	vector<int> a(n + 1);
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}

	vector<vector<int>> range_ans(n + 1, vector<int>(n + 1, 0));
	for (int i = 1; i <= n; i++) {
		for (int j = i; j <= n; j++) {
			range_ans[i][j] = range_ans[i][j - 1] + (a[j] == j - i ? 0 : 1);
		}
	}

	vector<vector<int>> dp(n + 1, vector<int>(n + 1, inf));
	dp[0][0] = 0;
	for (int i = 1; i <= n; i++) {
		for (int j = i; j <= n; j++) {
			dp[i][j] = dp[i][j - 1] + 1;
			if (a[j]) {
				dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + 1);
			}
			if (j - a[j] - 1 >= 0) {
				dp[i][j] = min(dp[i][j], dp[i - 1][j - a[j] - 1] + range_ans[j - a[j]][j]);
			}
		}
	}
	for (int i = 1; i <= n; i++) {
		cout << dp[i][n] << endl;
	}
}
```

</CPPSection>

</LanguageSection>