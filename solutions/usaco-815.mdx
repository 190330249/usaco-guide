---
id: usaco-815
source: USACO Gold 2018 Febuary
title: Taming the Herd
author: Shijie Ren
---

[Official Analysis (C++)](http://www.usaco.org/current/data/sol_taming_gold_feb18.html)

## Explanation

Let $\texttt{dp}[i][j]$ be the the minimum number of changes that must be made
to the first $j$ entries so that there are $i$ breakouts among the first $j$
entries.

There are three cases when we calculate the current value of $\texttt{dp}[i][j]$:

- If the log was tampered with and the cows would NOT breakout:

  - Compared to the previous day, the breakout number won't change. However, we need one
    more change of the log, so we transfer from $\texttt{dp}[i][j-1]$.
    $$
    \texttt{dp}[i][j]=\texttt{dp}[i][j-1]+1
    $$

- If the log was tampered with and the cows would breakout (Notice that $a[j] \neq 0$):

  - Compared to the previous day the breakout number increases by 1. We also
    need one more change of the log, so we transfer from $\texttt{dp}[i-1][j-1]$.
    $$
    \texttt{dp}[i][j]=\texttt{dp}[i-1][j-1]+1
    $$

- If the log was NOT tampered with:
  - Then the $i$-th breakout would be on the $(j-a[j])$-th day, so we transfer from
    $\texttt{dp}[i-1][j-a[j]-1]$.
    $$
    \texttt{dp}[i][j] = \texttt{dp}[i-1][j-a[j]-1]+\texttt{range\_ans}[j-a[j]][j]);
    $$

$$\texttt{range\_ans}[l][r]$$ represents the minimum cost to replace the range
$a[l]...a[r]$ with $0...(r-l)$.

Thus, our final DP relation is

$$
\texttt{dp}[i][j] = \min \{ \texttt{dp}[i][j-1]+1 ,\texttt{dp}[i-1][j-1]+1 ,\texttt{dp}[i-1][j-a[j]-1] + \texttt{range\_ans}[j-a[j]][j]) \}
$$

Note that if the indices are out of bounds, the value is not considered.

## Implementation

**Time Complexity:** $\mathcal{O}(N^2)$

<LanguageSection>

<CPPSection>

```cpp
#include <cstdio>
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int main() {
	freopen("taming.in", "r", stdin);
	freopen("taming.out", "w", stdout);

	int n;
	cin >> n;
	vector<int> a(n + 1);
	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}

	vector<vector<int>> range_ans(n + 1, vector<int>(n + 1));
	for (int i = 1; i <= n; i++) {
		for (int j = i; j <= n; j++) {
			range_ans[i][j] = range_ans[i][j - 1] + (a[j] == j - i ? 0 : 1);
		}
	}

	vector<vector<int>> dp(n + 1, vector<int>(n + 1, INT32_MAX));
	dp[0][0] = 0;
	for (int i = 1; i <= n; i++) {
		for (int j = i; j <= n; j++) {
			// Case 1
			if (dp[i][j - 1] != INT32_MAX) {
				dp[i][j] = dp[i][j - 1] + 1;
			}
	
			// Case 2
			if (a[j] && dp[i - 1][j - 1] != INT32_MAX) {
				dp[i][j] = min(dp[i][j], dp[i - 1][j - 1] + 1);
			}
	
			// Case 3
			if (j - a[j] - 1 >= 0 && dp[i - 1][j - a[j] - 1] != INT32_MAX) {
				dp[i][j] = min(dp[i][j], dp[i - 1][j - a[j] - 1] + range_ans[j - a[j]][j]);
			}
		}
	}
	
	for (int i = 1; i <= n; i++) {
		cout << dp[i][n] << endl;
	}
}
```

</CPPSection>

</LanguageSection>
