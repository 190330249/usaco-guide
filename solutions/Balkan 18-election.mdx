---
id: balkan-18-election
title: Balkan OI 2018 Election
author: Andi Qu
---

## A simpler case

Consider the case where we only care about counting votes from left to right.

Let a `C` vote count as $-1$ and a `T` vote count as $+1$ in an array $V$.

The answer to a query on the range $[l, r]$ is simply the maximum prefix sum in that range. (i.e. The largest $V_l + V_{l + 1} + \dots + V_k$)

If we count votes from right to left though, the answer is the maximum suffix sum instead.

We can use a segment tree to answer both of these types of queries efficiently.

## Combining values

It would be really convenient if we could just calculate the maximum prefix and suffix sums and add them. However, we would count some nullified votes twice if we do this.

In each node of the segment tree that stores information about the range $[l, r]$ we store the following information:

- The maximum prefix sum in the range $[l, r]$. (Let this be $L$)
- The maximum suffix sum in the range $[l, r]$. (Let this be $R$)
- The total sum of the range. (Let this be $S$)
- The answer to a query on the range $[l, r]$. (Let this be $A$)

When we combine two nodes $u$ (left child) and $v$ (right child) to make node $w$,

- $w.L = \max(u.L, u.S + v.L)$
- $w.R = \max(u.R + v.S, v.R)$
- $w.S = u.S + v.S$

To find $w.A$, we must consider three cases:

- Case 1: the endpoints of the maximum prefix and suffix sums in $w$'s range lie in $u$ and $v$ respectively.
    - In this case, we don't count any nullified votes twice.
    - $w.A = u.L + v.R$
- Case 2: the endpoints of the maximum prefix and suffix sums in $w$'s range both lie in either $u$ or $v$.
    - In this case, we would count some nullified votes twice if we apply case 1.
    - However, we know that all of Tony's votes must be nullified in $u$ and/or $v$.
    - $w.A = u.A + v.S$ or $w.A = u.S + v.A$
- Case 3: the endpoints of the maximum prefix and suffix sums in $w$'s range lie in $v$ and $u$ respectively.
    - In this case, all of Tony's votes must be nullified.
    - $w.A = u.L + v.R$

We can simply take the maximum from all three of these cases and that will be $w.A$.

## Code

```cpp
#include <bits/stdc++.h>
#define FOR(i, x, y) for (int i = x; i < y; i++)
typedef long long ll;
using namespace std;

struct Node {
    int l_max, r_max, tot, ans;

    Node operator+(Node b) {
        Node ret;
        ret.l_max = max(l_max, b.l_max + tot);
        ret.r_max = max(r_max + b.tot, b.r_max);
        ret.tot = tot + b.tot;
        ret.ans = max(max(ans + b.tot, b.ans + tot), l_max + b.r_max);
        return ret;
    }
};

Node segtree[2000001];
char s[500001];
int n;

void build(int node = 1, int l = 1, int r = n) {
    if (l == r) {
        if (s[l] == 'T') segtree[node] = {1, 1, 1, 1};
        else segtree[node] = {0, 0, -1, 0};
    } else {
        int mid = (l + r) / 2;
        build(node * 2, l, mid);
        build(node * 2 + 1, mid + 1, r);
        segtree[node] = segtree[node * 2] + segtree[node * 2 + 1];
    }
}

Node query(int a, int b, int node = 1, int l = 1, int r = n) {
    if (l > b || r < a) return {0, 0, 0, 0};
    if (l >= a && r <= b) return segtree[node];
    int mid = (l + r) / 2;
    return query(a, b, node * 2, l, mid) + query(a, b, node * 2 + 1, mid + 1, r);
}

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    cin >> n;
    FOR(i, 1, n + 1) cin >> s[i];
    build();
    int q;
    cin >> q;
    while (q--) {
        int a, b;
        cin >> a >> b;
        cout << query(a, b).ans << '\n';
    }
    return 0;
}
```
