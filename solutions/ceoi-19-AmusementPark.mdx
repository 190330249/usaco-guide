---
id: ceoi-19-AmusementPark
source: CEOI 2019
title: 2019 - Amusement Park
author: Shijie Ren
---

[CF Editorial](https://codeforces.com/blog/entry/68748)

<Spoiler title="Hint">

We can observe that for each legal proposal, reversing the direction of its
edges creates another legal proposal.

The costs of these two proposals will be $m$ because each edge was chosen once.

So the sum of costs will be $m\cdot\frac{\texttt{DAGCount}}2$,

where $\texttt{DAGCount}$ represents the number of directed acyclic graphs (DAG)
generated on the original graph.

</Spoiler>

<Spoiler title="Explanation">

Let $\texttt{dp}[S]$ be the number of ways of construct a directed acyclic
graphs (DAG) with vertex set $S$ , and $\texttt{indepset}[S]$ represents if $S$
is an independent set.

Since we're constructing a DAG, we can transfer the state by adding new points.
Adding 0-out-degree points (or 0-in-degree points is OK) will be easier.

Loop all non-empty subsets of S as points to be added, points are 0-out-degree
if and only if they don't have edges with each other in this subset. That is,
the subset is an independent set.

<Spoiler title="A Brief Explanation">

Let $A_S$ be the set of DAG configs of the induced subgraph of vertex set $S$.

$$
A_S = \bigcup_{\varnothing\not=P\subseteq S,P \text{ is an indep set}}A_{S\backslash P} \text{ with edges of points in }S\text{ to }S\backslash P
$$

It's obvious we cannot add all sizes of $A_{S\backslash P}$ directly, because when we
assign $S$ to be 0-out-degree points, there might be 0-out-degree points in
$A_{S\backslash P}$ previously which might be 0-out-degree in $A_S$ still (no edges to
points in $S$ from them ).

So fix $S$, let $B_P$ (empty if $P$ doesn't satisfy conditions above) to be
$A_{S\backslash P} \text{ with edges of points in }S\text{ to }S\backslash P$, so $|B_P|=|A_{S\backslash P}|$.

Thus, $B_P$ will be the set of DAG configs of the induced subgraph of vertex set
$S$ satisfies $P$ is **included** in 0-out-degree points.

What we want to know is $|B_\varnothing|$.

The form of this equation can be calculated by
[inclusion-exclusion principle](https://en.wikipedia.org/wiki/Inclusion-exclusion_principle).

Consider every single-element subset $Q$ of $P$ to construct a series of sets
$B_Q$, and it will be just as same as the formula of principle!

$$
B_P = \bigcap_{|Q|\leq1,Q\subseteq P}B_Q
$$

Since $B_\varnothing$ could be the universe set, ignore $Q=\varnothing$ when
$P\not=\varnothing$

$$
B_\varnothing = \bigcup_{|Q|=1,Q\subseteq S}B_Q
$$

Then,

$$
\left|\bigcup_{|Q|=1,Q\subseteq S}B_Q\right| = \sum_{\varnothing\not=P\subseteq S}(−1)^{|P|+1}\left|\bigcap_{|Q|=1,Q\subseteq P}B_Q\right|
$$

$$
|B_\varnothing| = \sum_{\varnothing\not=P\subseteq S}(−1)^{|P|+1}|B_P|
$$

$$
|A_S| = \sum_{\varnothing\not=P\subseteq S,P \text{ is an indep set}}(−1)^{|P|+1}|A_{S\backslash P}|
$$

DP equation form:

$$
dp[S]=\sum_{\varnothing\not=P\subseteq S,\texttt{indepset}[P]=\texttt{true}}(−1)^{|P|+1}dp[S\backslash P]
$$

</Spoiler>

The time complexity of enumerating subsets could be $\mathcal{O}(3^n)$.

<!--
<Optional title="FWT">

It can be optimized further through FWT to be an $\mathcal{O}(n^22^n)$ algorithm.

</Optional>
-->

</Spoiler>

<Spoiler title="Implementation">

**Time Complexity:** $\mathcal{O}(3^n)$

<LanguageSection>

<CPPSection>

```cpp
#include <cstring>
#include <iostream>
using namespace std;
const int N = 18;
const int M = 998244353;
int a[N];
bool indepset[1 << N];
int popcount[1 << N];
int arg[1 << N];
int nodeid[1 << N];
long long f[1 << N];
int main() {
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		int u, v;
		cin >> u >> v;
		u--;
		v--;
		a[u] |= 1 << v;
		a[v] |= 1 << u;
	}
	for (int i = 0; i < n; i++) {
		nodeid[1 << i] = i;
	}
	for (int i = 0; i < (1 << n); i++) {
		popcount[i] = popcount[i >> 1] + (i & 1);
		arg[i] = (popcount[i] % 2) * 2 - 1;
	}
	indepset[0] = 1;
	for (int i = 1; i < (1 << n); i++) {
		if (indepset[i & (i - 1)] &&
		    (a[nodeid[i & (-i)]] & (i & (i - 1))) == 0) {
			indepset[i] = true;
		}
	}
	f[0] = 1;
	for (int i = 1; i < (1 << n); i++) {
		for (int j = i; j; j = (j - 1) & i) {
			if (indepset[j]) {
				f[i] = (f[i] + arg[j] * f[i ^ j]) % M;
			}
		}
	}
	f[(1 << n) - 1] = (f[(1 << n) - 1] + M) % M;
	cout << f[(1 << n) - 1] * m % M * ((M + 1) / 2) % M;
	return 0;
}
```

</CPPSection>

</LanguageSection>

</Spoiler>
