---
id: ceoi-19-AmusementPark
source: CEOI 2019
title: 2019 - Amusement Park
author: Shijie Ren
---

[CF Editorial](https://codeforces.com/blog/entry/68748)

<Spoiler title="Hint">

We can observe that for each legal proposal , reverse direction of every edges ,
then we'll get another legal proposal.

So the sum of costs will be $m\cdot\texttt{DAGCount}$.

$\texttt{DAGCount}$ represents the number of directed acyclic graphs (DAG)
generated on the original graph.

</Spoiler>

<Spoiler title="Explanation">

Let $\texttt{dp}[S]$ be the number of ways of construct a directed acyclic
graphs (DAG) with vertex set $S$ , and $\texttt{indepset}[S]$ represents if $S$
is an independent set.

Since we'll construct a DAG, we can transfer the state by adding new points.
Adding 0-out-degree points (or 0-in-degree points is OK) will be easier.

So loop all non-empty subsets of S as points to be added, They could be
0-out-degree points if and only if they don't have edges with each other in this
subset. That is, the subset is an independent set.

Also we need to use clusion-exclusion principle.

$$
dp[S]=\sum_{P \subset S,P\not=\emptyset,\texttt{indepset}[P]=\texttt{true}}(âˆ’1)^{|P|+1}dp[S / P]
$$

Time complexity of enumerating subsets could be $\mathcal{O}(3^n)$.

<Optional>
It can be optimized further through FWT.
</Optional>

</Spoiler>

<Spoiler title="Implementation">

**Time Complexity:** $\mathcal{O}(3^n)$

<LanguageSection>

<CPPSection>

```cpp
#include <cstring>
#include <iostream>
using namespace std;
const int N = 18;
const int M = 998244353;
int a[N];
bool indepset[1 << N];
int popcount[1 << N];
int arg[1 << N];
int nodeid[1 << N];
long long f[1 << N];
int main() {
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= m; i++) {
		int u, v;
		cin >> u >> v;
		u--;
		v--;
		a[u] |= 1 << v;
		a[v] |= 1 << u;
	}
	for (int i = 0; i < n; i++) {
		nodeid[1 << i] = i;
	}
	for (int i = 0; i < (1 << n); i++) {
		popcount[i] = popcount[i >> 1] + (i & 1);
		arg[i] = (popcount[i] % 2) * 2 - 1;
	}
	indepset[0] = 1;
	for (int i = 1; i < (1 << n); i++) {
		if (indepset[i & (i - 1)] &&
		    (a[nodeid[i & (-i)]] & (i & (i - 1))) == 0) {
			indepset[i] = true;
		}
	}
	f[0] = 1;
	for (int i = 1; i < (1 << n); i++) {
		for (int j = i; j; j = (j - 1) & i) {
			if (indepset[j]) {
				f[i] = (f[i] + arg[j] * f[i ^ j]) % M;
			}
		}
	}
	f[(1 << n) - 1] = (f[(1 << n) - 1] + M) % M;
	cout << f[(1 << n) - 1] * m % M * ((M + 1) / 2) % M;
	return 0;
}
```

</CPPSection>

</LanguageSection>

</Spoiler>
