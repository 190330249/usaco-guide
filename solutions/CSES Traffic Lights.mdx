---
id: cses-1163
source: CSES
title: Traffic Lights
author: Danh Ta Chi Thanh
---

In this problem, we are given an empty interval length $x$ starting from 0 to $x$, and there are $n$ points being added to the interval chronologically. We want to find the maximum lenght of the gaps between the points at each step.

## Solution

First you can read and think more about the solution here: 
[Unofficial Editorial](https://codeforces.com/blog/entry/83295) (and also here: [Sketch](https://codeforces.com/blog/entry/86096?#comment-739122))

I will try to explain it: Let's create a set and a multiset. The set is used for storing the positions of the traffic lights, while the multiset will keep track of the "gaps" between the lights. After each addition, the multiset keeps expanding because more lights are put and your work is just to print "the length of the longest passage without traffic lights after each addition" or the max elements of that multiset which is the last element by default. Note that when placing a new traffic light on the road, that light will split the gap between two $adjacent$ lights into 2 smallers pieces, and you also have to remove the length of that gap in the multiset and add 2 new lenghts to the multiset.

## Code Implementation

```cpp
#include <sstream>
#include <iostream>
#include <fstream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cctype>
#include <climits>
#include <cfloat>
#include <string>
#include <algorithm>
#include <functional>
#include <vector>
#include <list>
#include <array>
#include <set>
#include <map>
#include <stack>
#include <queue>
#include <deque>
#include <bitset>
#include <unordered_set>
#include <unordered_map>
#include <utility>
#include <iterator>
#include <ctime>
#include <tuple>
#include <numeric>
 
using namespace std;
 
using ll = long long;
using si = short int;
using uint = unsigned int;
using ull = unsigned long long;
using ld = long double;
 
#define ar array
#define endl "\n" 
#define hash_set unordered_set 
#define hash_map unordered_map
 
//vector
#define vt vector
#define all(x) begin(x), end(x) 
#define rall(x) (x).rbegin(), (x).rend()
#define sz(x) (int)(x).size()
#define rsz resize
#define pb push_back
#define pf push_front
#define ft front()
#define bk back()
#define ins insert
#define lb lower_bound
#define ub upper_bound
 
//pairs and tuples
#define f first
#define s second
#define mp make_pair
#define mtp make_tuple
 
void setIO(string name =""){
//Compile with those flags and to get the fastest performance
//g++.exe -std=c++11 -DLOCAL ${file} -o ${file_base_name}.exe -Wl,--stack,268435456 -O2 && ${file_base_name}.exe
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	if (name.size()){
		freopen((name+".in").c_str(),"r",stdin);
		freopen((name+".out").c_str(),"w",stdout);
	}
	else {
		#ifdef LOCAL
		freopen("input.txt", "r", stdin);  
		freopen("output.txt", "w", stdout); 
		freopen("error.txt", "w", stderr);
		#endif 
	}
	return;
}
 
//constant initialization
const string yes="YES",no="NO";
const int mod=1e9+7;
const int maxn=2e5+10;
 
//variables used for the current problem
int x,n,p; set<int> lights; multiset<int> dist;
 
void solve() {
	cin >> x >> n;
    //I add the first point and the last point because when we place the very first light, 
    //it will creates two smaller intervals, which are 0-light1 and light1-x.
    lights.ins(0); lights.ins(x);
    dist.ins(x);     //It is obvious that initially the longest passage has the lenght equal to x. 
	for (int i=0;i<n;++i){
		cin >> p;
        //Read the input position of the traffic light
        //Next, I find the traffic light lying in the right of the current traffic light (p) using upper_bound function
        // And I find the traffic light to the left of the traffic light p by decrement the iterator
		auto it1 = lights.lb(p),it2 = it1; --it2;
        //Then I delete the lenghts of that left and right lights because it now has been split by the new light.
		dist.erase(dist.find(*it1-*it2));
        //After that, I insert the two new gaps which have just been created by adding a light between the 2 old lights.
		dist.ins(p-*it2); dist.ins(*it1-p);
        //Insert the position of the new light to the "lights" set
		lights.ins(p);
        //the answer in this current step is the last element off the multiset
		auto ans= dist.end(); --ans;
		cout << *ans << " ";
	}
}
int main(){
	setIO("");
	solve();
	return 0;
}
``` 

P/S: I found another solution by reversing all the steps and calculate the maximum lenght at each step. Here is my implementation.

## Solution 2 - Reversing the steps

```cpp
#include <sstream>
#include <iostream>
#include <fstream>
#include <iomanip>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <cctype>
#include <climits>
#include <cfloat>
#include <string>
#include <algorithm>
#include <functional>
#include <vector>
#include <list>
#include <array>
#include <set>
#include <map>
#include <stack>
#include <queue>
#include <deque>
#include <bitset>
#include <unordered_set>
#include <unordered_map>
#include <utility>
#include <iterator>
#include <ctime>
#include <tuple>
#include <numeric>
 
using namespace std;
 
using ll = long long;
using si = short int;
using uint = unsigned int;
using ull = unsigned long long;
using ld = long double;
 
#define ar array
#define endl "\n" 
#define hash_set unordered_set 
#define hash_map unordered_map
 
//vector
#define vt vector
#define all(x) begin(x), end(x) 
#define rall(x) (x).rbegin(), (x).rend()
#define sz(x) (int)(x).size()
#define rsz resize
#define pb push_back
#define pf push_front
#define ft front()
#define bk back()
#define ins insert
#define lb lower_bound
#define ub upper_bound
 
//pairs and tuples
#define f first
#define s second
#define mp make_pair
#define mtp make_tuple
 
void setIO(string name =""){
//Compile with those flags and to get the fastest performance
//g++.exe -std=c++11 -DLOCAL ${file} -o ${file_base_name}.exe -Wl,--stack,268435456 -O2 && ${file_base_name}.exe
	ios_base::sync_with_stdio(false);
	cin.tie(nullptr);
	if (name.size()){
		freopen((name+".in").c_str(),"r",stdin);
		freopen((name+".out").c_str(),"w",stdout);
	}
	else {
		#ifdef LOCAL
		freopen("input.txt", "r", stdin);  
		freopen("output.txt", "w", stdout); 
		freopen("error.txt", "w", stderr);
		#endif 
	}
	return;
}
 
//constant initialization
const string yes="YES",no="NO";
const int mod=1e9+7;
const int maxn=2e5+10;
 
//variables used for the current problem
int x,n,p[maxn],mx; set<int> st; vector<int> ans;
 
void solve() {
	cin >> x >> n;
	st.ins(0); st.ins(x);
	for (int i=0;i<n;++i){
		cin >> p[i]; st.ins(p[i]);
	}
	for (auto it = ++st.begin(); it != st.end();++it){
		auto it2=it; --it2;
		mx=max(*it-*it2,mx);
	}
	ans.pb(mx);
	for (int i=n-1;i>0;--i){
		auto it = st.ub(p[i]),it2=it; --it2; if (*it2) --it2;
		mx=max(*it-*it2,mx);
		ans.pb(mx);
		st.erase(st.find(p[i]));
	}
	reverse(all(ans));
	for (int res : ans) cout << res << " ";
}

int main(){
	setIO("");
	solve();
	return 0;
}
```

