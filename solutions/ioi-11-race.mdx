---
id: ioi-11-race
source: IOI 2011
title: Race
author: Timothy Gao
---

[Official Analysis (Centroid Decomposition)](https://ioinformatics.org/page/ioi-2011/37)

## Alternative Solution: Small to Large Merging

We are tasked with finding a path with the minimum number of traversed edges such that the path sum is $s$.
First, we root the tree arbitrarily.
Let $lca(u, v) = w$.
We can break $path(u, v)$ into $path(u, w)$ and $path(v, w)$.

Because $w$ must be an ancestor of both $u$ and $v$, $sum(u, w) = sum(u, root) - sum(w, root)$ and $sum(v, w) = sum(v, root) - sum(w, root)$ where $sum(a, b)$ is the sum of the path betwen the 2 nodes $a$ and $b$. We can compute $sum(i, root)$ for all $i$ in $O(N)$ with a simple DFS. We also compute $dist(i, root)$ where is the number of edges between $i$ and $root$ in similar fashion. 

We perform small to large merging to find an $lca$ $i$ such that $sum(u, root) + sum(v, root) - 2 \cdot sum(i, root) = s$, and $dist(u, root) + dist(v, root) - 2 \cdot dist(i, root) = s$ is minimized. 

To accomplish this, we can use small to large merging. For each $i$, we maintain a map of key to value pair of $sum(root, j) : dist(root, j)$ for  distinct $sum(root, j)$ for all $j$ in the subtree of $i$. If there are duplicate $sum(root, j)$ we take the minimum $dist(root, j)$.

As we combine the maps of two nodes, we iterate through each key-pair $(sum_s, dist_s)$ of the smaller size map, find if there exists a key-pair $sum_l = s - sum_s$ in the larger map, and obtain $dist_s + dist_l$. Our answer would be minimum $dist_s + dist_l$ over all mergings. During this process we also merge all key-value pairs of the smaller map.


## Implementation

**Time Complexity:** $\mathcal{O}(N\log^2N)$

The log factors come from small-to-large merging and the map operations.

```cpp
#include <bits/stdc++.h>
 
using namespace std;
 
typedef long long ll;
typedef pair<ll, ll> pii;
 
#define pb push_back
 
#define f first
#define s second
 
const int maxn = 2e5+20;
vector<pii> adj[maxn];
map<ll, ll> info[maxn]; 
ll dist[maxn], sum[maxn]; //define these relative to root
int N, K, u, v; ll ret;
 
void dfs1(int u, int p, ll c, int h){
	info[u][c] = h; 
	sum[u] = c; dist[u] = h;
	for(auto n : adj[u]){
		if(p == n.f) continue;
		dfs1(n.f, u, c + n.s, h + 1);
	}
}
 
void dfs(int u, int p){
	ll target = K + 2*sum[u];
	for(auto n : adj[u]){
		if(n.f == p) continue;
		dfs(n.f, u);
		if(info[n.f].size() > info[u].size()){
			swap(info[n.f], info[u]);
		}
		for(auto i : info[n.f]){
			if(info[u].find(target - i.f) != info[u].end()){
				ret = min(ret, info[u][target - i.f] + i.s - 2*dist[u]);
			}
		}
		for(auto i : info[n.f]){
			if(info[u].find(i.f) == info[u].end()){
				info[u].insert(i);
			}else{
				info[u][i.f] = min(info[u][i.f], i.s);
			}
		}
	} 
}

int best_path(int n, int k, int edges[][2], int weights[]){
	if(k == 1) return 0;
	N = n; K = k; ret = INT_MAX;
	for(int i = 0; i<n-1; i++){
		u = edges[i][0]; v = edges[i][1];
		adj[u].pb(pii(v, weights[i])); adj[v].pb(pii(u, weights[i]));
	}
	dfs1(0, -1, 0, 0);
	dfs(0, -1);
	return ret == INT_MAX ? -1 : ret;
}
```