---
id: ioi-11-race
source: IOI 2011
title: Race
author: Timothy Gao
---

[Official Analysis with Centroid Decomposition Downloaded Here](https://ioinformatics.org/page/ioi-2011/37)

## Alternative Solution: Small to Large Merging

In this problem, we are looking for the minimum number of edges needed to create a path weighted $v$.
Consider rooting the tree arbitrarily. All paths in this tree must have a unique lowest node in the rooted tree
As a result, we can break any path in the tree into two paths from nodes to the root. Consider for each node,
computing it's distance from the root(number of edges used) and the weight of its path from the root.
We can store this in a map, with key to value pairs of weight : distance
Now, consider doing small to large merging on the nodes. When we combine a smaller map s to a larger map b at node u,
as we iterate through each key $a$ the map in s, we want a path weight of exactly $(K+2*path[u]-a)$, where
$path[u]$ indicates the weight of the path from root to u.
The motivation behind this is that through the process of small to large merging, we can effectively consider every node as being
 that "unique lowest node" as mentioned earlier.
Note that in the code below, height is the distance, and dist is the weight of the path for each node.


## Implementation

**Time Complexity:** $\mathcal{O}(N\log^2N)$


```cpp
#include <bits/stdc++.h>
 
using namespace std;
 
typedef long long ll;
typedef pair<ll, ll> pii;
 
#define pb push_back
 
#define f first
#define s second
 
const int maxn = 2e5+20;
vector<pii> adj[maxn];
map<ll, ll> info[maxn]; 
ll dist[maxn], height[maxn]; //define dist relative to root
int N, K, u, v; ll ret;
 
void dfs1(int u, int p, ll c, int h){
	info[u][c] = h; 
	dist[u] = c; height[u] = h;
	for(auto n : adj[u]){
		if(p == n.f) continue;
		dfs1(n.f, u, c + n.s, h + 1);
	}
}
 
void dfs(int u, int p){
	ll target = K + 2*dist[u];
	for(auto n : adj[u]){
		if(n.f == p) continue;
		dfs(n.f, u);
		if(info[n.f].size() > info[u].size()){
			swap(info[n.f], info[u]);
		}
		for(auto i : info[n.f]){
			if(info[u].find(target - i.f) != info[u].end()){
				ret = min(ret, info[u][target - i.f] + i.s - 2*height[u]);
			}
		}
		for(auto i : info[n.f]){
			if(info[u].find(i.f) == info[u].end()){
				info[u].insert(i);
			}else{
				info[u][i.f] = min(info[u][i.f], i.s);
			}
		}
	} 
}

int best_path(int n, int k, int edges[][2], int weights[]){
	if(k == 1) return 0;
	N = n; K = k; ret = INT_MAX;
	for(int i = 0; i<n-1; i++){
		u = edges[i][0]; v = edges[i][1];
		adj[u].pb(pii(v, weights[i])); adj[v].pb(pii(u, weights[i]));
	}
	dfs1(0, -1, 0, 0);
	dfs(0, -1);
	return ret == INT_MAX ? -1 : ret;
}
```