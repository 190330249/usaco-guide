---
id: usaco-1181
source: USACO Bronze 2022 January
title: Drought
author: Chongtian Ma
---

[Official Analysis (C++)](http://www.usaco.org/current/data/sol_prob3_bronze_jan22.html)

## Explanation

We can solve this problem greedily using one linear sweep and making prefixes of cows have equal hunger as we sweep from left to right. Thus, we can break this
problem up into cases:

Suppose we are currently looking at cow $i$, and cow $i+1$ has a greater hunger value - then it is sufficient to decrease cow $i+1$ to the same hunger value
as cow $i$. To do this we will pick the pair of cows $i+1$ and $i+2$ and decrease their hungers until cow $i+1$ has the same hunger value as cow $i$.
Of course, if cow $i+2$ has a negative hunger value, then it is impossible and we output $-1$.

Now suppose cow $i$ has a greater hunger value than cow $i+1$, we obviously cannot decrease the hunger for cow $i+1$ any further since it will never be
equal - we only can decrease the hunger for all the cows before $i+1$. To do this we select adjacent pairs of cows starting with the odd numbered cows and
have their hunger decreased together (cow 1 and 2 get their, cow 3 and 4 ... cow $i-1$ and cow $i$). After this, all the cows before $i+1$ will be decreased to the same hunger value as cow $i+1$. However, there is the case where $i$ is odd, in which it is impossible to decrease unless we also decrease the hunger value for cow $i+1$, so we output -1.

Note that at every step we are always making sure cows from 1 to $i+1$ have the same hunger values. 

## Implementation

Time Complexity: $\mathcal{O}(N)$

<LanguageSection>
  
<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

void solve(){
	int n;
	cin >> n;
	vector<ll> hunger(n+1); // hunger for each cow, one indexed
	for(int i = 1; i <= n; i++){
		cin >> hunger[i];
	}

	ll bags_needed = 0;
	for(int i = 1; i < n; i++){
		if(hunger[i+1] > hunger[i]){
			// if the i+1'th cow has more hunger than cow i
			if(i + 2 > n){
				// if the i+2'th cow doesn't exist, then we can't
				// possibly decrease the pair of cows starting with i+1.
				cout<<-1<<"\n";
				return;
			}
			ll difference = hunger[i+1] - hunger[i];
			hunger[i+1] -= difference;
			hunger[i+2] -= difference;
			if(hunger[i+2] < 0){
				// cow i+2 can't possibly have negative hunger value
				cout<<-1<<"\n";
				return;
			}
			// it takes difference * 2 bags to feed cows i+1 and i+2 to equal hunger as i
			bags_needed += difference * 2;

		}
		else if(hunger[i] > hunger[i+1]){
			// if the i'th cow has more hunger than the i+1'th cow
			if(i % 2 == 1){
				// if i is an odd index then it is impossible.
				cout<<-1<<"\n";
				return;
			}
			ll difference = hunger[i] - hunger[i+1];
			// it takes difference * i bags to feed every cow from 1 to i to the same
			// hunger value as cow i+1
			bags_needed += difference * i;
		}
	}
	cout<<bags_needed<<"\n";
}

int main(){
	int tests;
	cin >> tests;
	for(int t = 0; t < tests; t++){
		solve();
	}
}
```
        
</CPPSection>
        
</LanguageSection>
