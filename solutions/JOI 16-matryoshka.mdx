---
id: joi-16-matryoshka
source: JOISC 2016
title: Matryoshka
author: Andi Qu
---

**Time Complexity**: $\mathcal O((N + Q) \log N)$

First, let's consider a single query - what's the minimum number of dolls left over? A single nested doll consists of some dolls of increasing
$R_i$ and $H_i$. If we sort the dolls by $H_i$ and only consider their $R_i$, then the answer is the minimum number of increasing subsequences
needed to "cover" all the dolls.

It's well-known that the minimum number of increasing subsequences is equal to the longest non-increasing subsequence (see [the LIS module](https://usaco.guide/gold/lis/#application-2---minimum-number-of-increasing-sequences)
for more details.) This gives us a way to answer a single query in $\mathcal O(N \log N)$ time!

But what if we need to answer multiple queries?

Since we don't have to answer the queries online, let's sort them in decreasing order of $A_i$.
If $B_i = \infty$ for each query, then we can simply do a line sweep on the dolls and queries,
inserting dolls into the sequence and updating the longest non-increasing subsequence as we get to them.

For variable $B_i$s, we only want the longest non-increasing subsequence for some prefixes
of the sequence of dolls (not the whole sequence like before). We can thus binary search on the LIS
array to find this answer, since the LDS array stores for each $i$, the doll with the smallest $B_j$
with a non-increasing subsequence ending on it.

```cpp
#include <bits/stdc++.h>
using namespace std;

pair<int, int> doll[200000];
pair<pair<int, int>, int> query[200000];
int ans[200000];

int main() {
	cin.tie(0)->sync_with_stdio(0);
	int n, q;
	cin >> n >> q;
	for (int i = 0; i < n; i++) {
		cin >> doll[i].first >> doll[i].second;
		doll[i].second = -doll[i].second;
	}
	for (int i = 0; i < q; i++) {
		cin >> query[i].first.first >> query[i].first.second;
		query[i].second = i;
	}
	sort(doll, doll + n, greater<pair<int, int>>());
	sort(query, query + q, greater<pair<pair<int, int>, int>>());

	vector<pair<int, int>> dp;
	for (int i = 0, j = 0; i < q; i++) {
		while (j < n && doll[j].first >= query[i].first.first) {
			int lis = upper_bound(dp.begin(), dp.end(), make_pair(-doll[j].second, INT_MAX)) - dp.begin();
			if (lis == dp.size()) dp.push_back({-doll[j].second, doll[j].first});
			else dp[lis] = {-doll[j].second, doll[j].first};
			j++;
		}
		ans[query[i].second] = upper_bound(dp.begin(), dp.end(), make_pair(query[i].first.second, INT_MAX)) - dp.begin();
	}

	for (int i = 0; i < q; i++) cout << ans[i] << '\n';
	return 0;
}
```

Alternatively, we use a segment tree to store, for each doll $i$, what that length is when considering only dolls with $H_j \leq H_i$.

Since the coordinates can get very big, one must use either a sparse segment tree or coordinate
compression to fit the segment tree in the memory. I used a sparse segment tree in my implementation below.
The time complexity is $\mathcal O((N + Q) \log(\max H_i))$

```cpp
#include <bits/stdc++.h>
using namespace std;

struct Node {
	int l, r, val;
	Node *lc, *rc;

	Node(int L, int R): l(L), r(R), val(0), lc(nullptr), rc(nullptr) {}

	void update(int p, int v) {
		val = max(val, v);
		if (l != r) {
			int mid = (l + r) / 2;
			if (p > mid) {
				if (!rc) rc = new Node(mid + 1, r);
				rc->update(p, v);
			} else {
				if (!lc) lc = new Node(l, mid);
				lc->update(p, v);
			}
		}
	}

	int query(int a, int b) {
		if (r < a || l > b) return 0;
		if (r <= b && l >= a) return val;
		int ret = 0;
		if (lc) ret = max(ret, lc->query(a, b));
		if (rc) ret = max(ret, rc->query(a, b));
		return ret;
	}
};

pair<int, int> doll[200000];
pair<pair<int, int>, int> query[200000];
int ans[200000];

int main() {
	ios_base::sync_with_stdio(0);
	cin.tie(0);
	int n, q;
	cin >> n >> q;
	for (int i = 0; i < n; i++) {
		cin >> doll[i].first >> doll[i].second;
		doll[i].second = -doll[i].second;
	}
	for (int i = 0; i < q; i++) {
		cin >> query[i].first.first >> query[i].first.second;
		query[i].second = i;
	}
	sort(doll, doll + n, greater<pair<int, int>>());
	sort(query, query + q, greater<pair<pair<int, int>, int>>());

	vector<int> dp;
	Node *segtree = new Node(1, 1000000000);
	for (int i = 0, j = 0; i < q; i++) {
		while (j < n && doll[j].first >= query[i].first.first) {
			int lis = upper_bound(dp.begin(), dp.end(), -doll[j].second) - dp.begin();
			if (lis == dp.size()) dp.push_back(-doll[j].second);
			else dp[lis] = -doll[j].second;
			segtree->update(-doll[j].second, lis + 1);
			j++;
		}
		ans[query[i].second] = segtree->query(1, query[i].first.second);
	}

	for (int i = 0; i < q; i++) cout << ans[i] << '\n';
	return 0;
}
```