---
id: cf-mahmoud-and-ehab-and-the-bipartiteness
source: CF
title: Mahmoud and Ehab and the bipartiteness
author: Pavan Yeddanapudi
---

[Official Editorial](https://codeforces.com/blog/entry/54590)

This problem is basically asking the number of edges we can add to a tree graph such that it should remain bipariate afterward. Suppose $c1$ and $c2$ are the colors that each node can be. The total number of edges possible with the graph remaining bipariate is $c1\cdot c2$. This is because 

```cpp
#include <bits/stdc++.h>
using namespace std;
const int mn = 1e5;
int n;
bool vis[mn+1], pi[mn+1];//to check if a node has been visited and which color a node is
vector<int> adj[mn+1];//adjacency list for the graph
void dfs(int node,bool g=0){
    pi[node]=g;//assigns each node a color
    vis[node]=1;//it has been visited
    for(int i:adj[node])
        if(!vis[i])
            dfs(i,!g);
    /*Note:
     * We don't have to worry about the graph not being bepariate because the graph is a tree. 
     All trees are bipariate. Try to figure out why by yourself.
    */
}
int main(){
    cin.tie(0)->sync_with_stdio(0);
    cin>>n;
    set<pair<int,int>> edges;
    for(int i=0;i<n-1;i++){
        int a,b;
        cin >> a>>b;
        edges.insert({a,b});
        edges.insert({b,a});
        adj[a].push_back(b);
        adj[b].push_back(a);
    }
    dfs(1);
    long long  c1=0,c2=0;
    for(int i=1;i<=n;i++){//sees how many of each color are there
        if(pi[i]) c1++;
        else c2++;
    } 
    cout << c1*c2-(n-1) << "\n"; //final answer
}
```
