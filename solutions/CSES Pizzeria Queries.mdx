---
id: cses-2206
source: CSES
title: Pizzeria Queries
author: Dong Liu
---

# Solution

When we query the minimum cost to buy a pizza at point $i$, we can split it into two cases ($i$$\rightarrow$$j$)
1. going downwards ($j < i$): the cost would be $p_j-j+i$
2. going upwards ($j > i$): the cost would be $p_j+j-i$

Notice that we can caculate the $+i$ or $-i$ after the query since it is constant.

Thus, if we keep two min segtrees (one for going downwards and one for going upwards), we can keep track of the minumum cost by setting each value in the downwards segtree to $p_j-j$ and each value in the upwards segtree to $p_j+j$.

To query, we can query the minimum value in the
1. downwards segtree: $min(1,\dots,i)$ + i
2. upwards segtree: $min(i,\dots,N)$ - i

# Code

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

template<class T> struct SegTree {
	T U = 1e9; T F(T a, T b) { return min(a,b); }
	int N; vector<T> t; SegTree() {}
	SegTree(int N) : N(N), t(4*N,U) {}
	void upd(int I, T V) { upd(I,V,1,1,N); }
	void upd(int I, T V, int i, int l, int r) {
		if(l==r) { t[i]=V; return; } int m=(l+r)/2;
		if(l<=I && I<=m) upd(I,V,i*2,l,m);
		if(m+1<=I && I<=r) upd(I,V,i*2+1,m+1,r);
		t[i] = F(t[i*2], t[i*2+1]); }
	T qry(int L, int R) { return qry(L,R,1,1,N); }
	T qry(int L, int R, int i, int l, int r) {
		if(L<=l && r<=R) return t[i];
		if(R<l || L>r) return U; int m=(l+r)/2;
		return F(qry(L,R,i*2,l,m), qry(L,R,i*2+1,m+1,r)); }
};
const int maxn = 2e5+5;

int n, q, p[maxn];
SegTree<int> down, up;

void pull(int i) {
	down.upd(i, p[i]-i);
	up.upd(i, p[i]+i);
}

int main() {

	cin >> n >> q;
	for(int i=1; i<=n; i++) cin >> p[i];

	down = up = SegTree<int>(n);
	for(int i=1; i<=n; i++) pull(i);
	while(q--) {
		int t; cin >> t;
		if(t == 1) {
			int k, x; cin >> k >> x;
			p[k]=x; pull(k);
		} else {
			int k; cin >> k;
			int D = down.qry(1,k) + k;
			int U = up.qry(k,n) - k;
			cout << min(D, U) << '\n';
		}
	}
}
```

</CPPSection>

</LanguageSection>
