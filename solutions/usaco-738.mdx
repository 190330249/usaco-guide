---
id: usaco-738
source: USACO Silver 2017 US Open
title: Paired Up
author: Sofia Yang, Ryan Chou

---

[Official Analysis (C++)](http://www.usaco.org/current/data/sol_pairup_silver_open17.html)

Let's say we have three distinct values in our dataset, 

$A < B < C$

In this case, pairing up $B + C$ would always be greater than $A + C$.

Therefore, we should pair up the greatest value ($C$), with the smallest value ($A$), in order to achieve the most optimal milking time.

## Implementation
**Time Complexity:** $\mathcal{O}(N\log N)$

(Because it requires sorting the input, which is $\mathcal{O}(N\log N)$). 


<LanguageSection>

<PySection>
```py
import sys
sys.stdin = open("pairup.in", 'r')
sys.stdout = open("pairup.out", 'w')

n = int(input())
all_cows = []

for _ in range(n):
    num_cows, milk_time = map(int, input().split())
    all_cows.append([milk_time, num_cows])

# sort by the amount of time the cows take to milk.
all_cows.sort()

left, right = 0, n - 1

ans = 0 

while left <= right:
    # how many cows have been grouped together.
    sub = min(all_cows[left][1], all_cows[right][1])
    """
    since we have to take account of the total time
    to milk all cows, we're getting the maximum time
    out of all the milkings.
    """
    ans = max(ans, all_cows[left][0] + all_cows[right][0])
    if left == right:
        sub /= 2
    all_cows[left][1] -= sub
    all_cows[right][1] -= sub
    # if there are no more cows which have this milk output,
    # we can increment/decrement the left/right pointer(s).
    if all_cows[left][1] == 0: left += 1
    if all_cows[right][1] == 0: right -= 1
print(ans)
```
</PySection>
<JavaSection>


``` java
import java.io.*;
import java.util.*;

public class PairUp {
	CodeSnip{Kattio}
	
	public static void main(String[] args) throws IOException {
		Kattio io = new Kattio("pairup");
		int N = io.nextInt();
		List<Pair> events = new ArrayList<>();
		for (int i = 0; i < N; i++) {
			int freq = io.nextInt();
			int amt = io.nextInt();
			events.add(new Pair(freq, amt));
		}

		Collections.sort(events);
		int ret = 0;
		int left = 0, right = N - 1;
		while (left <= right) {
			/*
			 * Pair up the cows with the least output
			 * with the cows with the highest output.
			 */
			int numPaired = Integer.min(events.get(left).freq, events.get(right).freq);
			if (left == right) {
				numPaired /= 2;
			}
			// Update the maximum time used, and remove the paired cows.
			ret = Integer.max(ret, events.get(left).amt + events.get(right).amt);
			events.get(left).freq -= numPaired;
			events.get(right).freq -= numPaired;
			if (events.get(left).freq == 0) {
				left++;
			}
			if (events.get(right).freq == 0) {
				right--;
			}
		}
		io.println(ret);
		io.close();
	}
}

class Pair implements Comparable<Pair> {
	public int freq, amt;

	public Pair(int freq, int amt) {
		this.freq = freq;
		this.amt = amt;
	}

	public int compareTo(Pair other) {
		return Integer.compare(this.amt, other.amt);
	}
}
```

</JavaSection>

</LanguageSection>
