---
id: intro-ds
title: Introduction to Data Structures
author: Darren Yao, Benjamin Qi, Nathan Wang, Abutalib Namazov
description: 'Introduces the concept of a data structure, dynamic arrays, pairs.'
frequency: 4
---

import { Problem } from '../models';

export const problems = {
	
};

<!--
  new Problem("Silver", "Teleportation", "812", "Very Hard", false, [], ""),
 -->


A **data structure** determines how data is stored (is it sorted? indexed? what operations does it support?). Each data structure supports some operations efficiently, while other operations are either inefficient or not supported at all.

## Data Structures

<LanguageSection>

<CPPSection>

The C++ [standard library data structures](http://www.cplusplus.com/reference/stl/) are designed to store any type of data. We put the desired data type within the `<>` brackets when declaring the data structure, as follows:

```cpp
vector<string> v;
```

This creates a `vector` structure that only stores objects of type `string`.

For our examples below, we will primarily use the `int` data type, but note that you can use any data type including `string` and user-defined structures.

Essentially every standard library data structure supports the `size()` method, which returns the number of elements in the data structure, and the `empty()` method, which returns `true` if the data structure is empty, and `false` otherwise.

</CPPSection>

<JavaSection>

Java default [`Collections`](https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html) data structures are designed to store any type of object. However, we usually don't want this; instead, we want our data structures to only store one type of data, like integers, or strings. We do this by putting the desired data type within the `<>` brackets when declaring the data structure, as follows:

```java
ArrayList<String> list = new ArrayList<String>();
```

This creates an `ArrayList` structure that only stores objects of type `String`.

For our examples below, we will primarily use the `Integer` data type, but note that you can have Collections of any object type, including `Strings` , other Collections, or user-defined objects.

`Collections` data types always contain an `add` method for adding an element to the collection, and a `remove` method which removes and returns a certain element from the collection. They also support the `size()` method, which returns the number of elements in the data structure, and the `isEmpty()` method, which returns `true` if the data structure is empty, and `false` otherwise.

</JavaSection>

</LanguageSection>

## Dynamic Arrays

<Resources>
	<Resource source="IUSACO" title="4.1 - Dynamic Arrays">
		module is based off this
	</Resource>
	<Resource source="CPH" title="4.1 - Dynamic Arrays" starred>
		vectors, strings
	</Resource>
	<Resource source="PAPS" title="3.1 - Vectors, 6.1 - Dynamic Arrays">
		how dynamic arrays work
	</Resource>
</Resources>

<!-- <Resource source="CPC" title="2 - Data Structures" url="02_data_structures">
	assumes prior experience
</Resource> -->

<br />

You're probably already familiar with regular (static) arrays. Now, there are also dynamic arrays ([`vector`](http://www.cplusplus.com/reference/vector/vector/) in C++, [`ArrayList`](https://docs.oracle.com/javase/8/docs/api/java/util/ArrayList.html) in Java) that support all the functions that a normal array does, and can repeatedly reallocate storage to accommodate more elements as they are added.

In a dynamic array, we can also add and delete elements at the end in $O(1)$ time. For example, the following code creates a dynamic array and adds the numbers $1$ through $10$ to it:

<LanguageSection>

<CPPSection>

```cpp
vector<int> v;
for(int i = 1; i <= 10; i++){
    v.push_back(i);
}
```

</CPPSection>

<JavaSection>

```java
ArrayList<Integer> list = new ArrayList<Integer>();
for(int i = 1; i <= 10; i++){
    list.add(i);
}
```

</JavaSection>

</LanguageSection>

In C++, we can give a dynamic array an initial size. The code below creates a dynamic array with $30$ zeroes.

<LanguageSection>

<CPPSection>

```cpp
vector<int> v(30); // one way
vector<int> v; v.resize(30); // another way
```

</CPPSection>

<JavaSection>

Unfortunately, there is no Java equivalent; just use a for loop.

```java
ArrayList<Integer> list = new ArrayList<Integer>();
for (int i = 1; i <= 30; i++) list.add(0);
```

</JavaSection>

</LanguageSection>

We can ensure that a dynamic array's **capacity** must be at least $x$, meaning that it will not reallocate storage until we add more than $x$ elements to it. If the dynamic array's capacity is already at least $x$, then nothing occurs. Note that capacity is **not** the same thing as size. For example, if you declare a dynamic array with initial capacity $30$ and try to edit the element at index $5$, this will throw an error since the size of the dynamic array is still zero.

The following code initializes a dynamic array with initial capacity $30$:

<LanguageSection>

<CPPSection>

```cpp
vector<int> v; v.reserve(30);
```

</CPPSection>

<JavaSection>

```java
ArrayList<Integer> list = new ArrayList<Integer>(30); // one way
ArrayList<Integer> list = new ArrayList<Integer>(); list.ensureCapacity(30); // another way
```

</JavaSection>

</LanguageSection>

We can add and remove at any index of a dynamic array in $O(n)$ time.

<LanguageSection>

<CPPSection>

```cpp
vector<int> v;
v.push_back(2); // [2]
v.push_back(3); // [2, 3]
v.push_back(7); // [2, 3, 7]
v.push_back(5); // [2, 3, 7, 5]
v[1] = 4; // sets element at index 1 to 4 -> [2, 4, 7, 5]
v.erase(v.begin() + 1); // removes element at index 1 -> [2, 7, 5]
// this remove method is O(n); to be avoided
v.push_back(8); // [2, 7, 5, 8]
v.erase(v.end()-1); // [2, 7, 5]
// here, we remove the element from the end of the list; this is O(1).
v.push_back(4); // [2, 7, 5, 4]
v.push_back(4); // [2, 7, 5, 4, 4]
v.push_back(9); // [2, 7, 5, 4, 4, 9]
cout << v[2]; // 5
v.erase(v.begin(), v.begin()+3); // [4, 4, 9]
// this erases the first three elements; O(n)
```

</CPPSection>

<JavaSection>

```java
ArrayList<Integer> list = new ArrayList<Integer>();
list.add(2); // [2]
list.add(3); // [2, 3]
list.add(7); // [2, 3, 7]
list.add(5); // [2, 3, 7, 5]
list.set(1, 4); // sets element at index 1 to 4 -> [2, 4, 7, 5]
list.remove(1); // removes element at index 1 -> [2, 7, 5]
// this remove method is O(n); to be avoided
list.add(8); // [2, 7, 5, 8]
list.remove(list.size()-1); // [2, 7, 5]
// here, we remove the element from the end of the list; this is $O(1)$.
System.out.println(list.get(2)); // 5
```

</JavaSection>

</LanguageSection>
    
To iterate through a static or dynamic array, we can use either the regular for loop or the for-each loop.

<LanguageSection>

<CPPSection>

```cpp
vector<int> v;
v.push_back(1); v.push_back(7); v.push_back(4); v.push_back(5); v.push_back(2);
int arr[] = {1, 7, 4, 5, 2};
for(int i = 0; i < v.size(); i++){
    cout << v[i] << " ";
}
cout << endl;
for(int element : arr){
    cout << element << " ";
}
cout << endl;
```

</CPPSection>

<JavaSection>

```java
ArrayList<Integer> list = new ArrayList<Integer>();
list.add(1); list.add(7); list.add(4); list.add(5); list.add(2);
int[] arr = {1, 7, 4, 5, 2};
for(int i = 0; i < list.size(); i++){ // regular
    System.out.println(list.get(i));
}
for(int element : arr){ // for-each
    System.out.println(element);
}
```

</JavaSection>

</LanguageSection>
 
In array-based contest problems, we'll use one-, two-, and three-dimensional static arrays most of the time. However, we can also have static arrays of dynamic arrays, dynamic arrays of static arrays, and so on. Usually, the choice between a static array and a dynamic array is just personal preference.

## Iterators

An **iterator** allows you to traverse a container by pointing to an object within the container.

<LanguageSection>

<CPPSection>

However, they are **not** the same thing as pointers. For example, `vector.begin()` returns an iterator pointing to the first element of the vector. Apart from the standard way of traversing a vector (by treating it as an array), you can also use iterators:

```cpp
for (vector<int>::iterator it = myvector.begin(); it != myvector.end(); ++it) {
    cout << *it;
}
```

C++11 and later versions can automatically infer the type of an object if you use the keyword `auto`, so the following are okay:

```cpp
for (auto it = myvector.begin(); it != myvector.end(); ++it) {
    cout << *it;
}
for(auto element : v) {
    cout << element;
}
```

</CPPSection>

</LanguageSection>

## Pairs & Tuples

Storing multiple elements as a single unit allows you to change the order of the elements (e.g. sorting) without mixing one component with another.

**Example:** Given some points on a plane where the $i$-th point has coordinates $(x_i,y_i)$, sort these points in increasing order of $x$ coordinate and increasing order of $y$ in case there is a tie.

If you sort one of $x_i$ and $y_i$ without considering the other, the points will not be in the correct order. We need to consider the pair $(x_i,y_i)$ as a single unit.

<LanguageSection>
<CPPSection />
<PySection>

<Warning title="Language Note">

**Pairs are not available in Python.** Just use tuples; no need for pairs!

</Warning>

</PySection>
<JavaSection>

<Warning title="Language Note">

**Pairs and tuples are not available in Java.** Just create your own class! If you are using Java, just skip this module.

</Warning>

</JavaSection>
</LanguageSection>

<LanguageSection>
<CPPSection>

### [Pairs](http://www.cplusplus.com/reference/utility/pair/pair/)

- `pair<type1, type2> p`: Creates a pair `p` with two elements with the first one being of `type1` and the second one being of `type2`.
- `make_pair(a, b)`: Returns a pair with values `a`, `b`.
- `{a, b}`: With C++11 and above, this can be used as to create a pair, which is easier to write than `make_pair(a, b)`.
- `pair.first`: The first value of the pair.
- `pair.second`: The second value of the pair.

Example:

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	pair<string, int> myPair1 = make_pair("Testing", 123);
	cout << myPair1.first << " " << myPair1.second << endl;
	myPair1.first = "It is possible to edit pairs after declaring them";
	cout << myPair1.first << " " << myPair1.second << endl;

	pair<string, string> myPair2 = {"Testing", "curly braces"};
	cout << myPair2.first << " " << myPair2.second << endl;
}

/* Output:
Testing 123
It is possible to edit pairs after declaring them 123
Testing curly braces
*/
```

### [Tuples](http://www.cplusplus.com/reference/tuple/)

Of course, we can hold more than two values with something like `pair<int,pair<int,int>>`, but it gets messy when you need a lot of elements. In this case, using **tuples** might be more convenient.

- `tuple<type1, type2, ..., typeN> t`: Creates a tuple with `N` elements, i'th one being of `typei`.
- `make_tuple(a, b, c, ..., d)`: Returns a tuple with values written in the brackets.
- `get<i>(t)`: Returns the `i`'th element of the tuple `t`. Can also be used to change the element of a tuple.

This operation only works for constant `i`. Namely, it is **not** allowed to do something like the following since `i` is not constant:

```cpp
tuple<int,int,int> t{3,4,5};
int i = 1; cout << get<i>(t);
```

- `tie(a, b, c, ..., d) = t`: Equals `a, b, c, ..., d` to the elements of the tuple $t$ accordingly.

<!-- This is not frequently used by competitive programmers, but it is good to know and can help simplify things sometimes.  -->

Example:

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	int a = 3, b = 4, c = 5;
	tuple<int, int, int> t = tie(a, b, c);
	cout << get<0>(t) << " " << get<1>(t) << " " << get<2>(t) << endl;
	get<0>(t) = 7;
	cout << get<0>(t) << " " << get<1>(t) << " " << get<2>(t) << endl;

	tuple<string, string, int> tp2 = make_tuple("Hello", "world", 100);
	string s1, s2; int x;
	tie(s1, s2, x) = tp2;
	cout << s1 << " " << s2 << " " << x << endl;
}

/* Output:
3 4 5
7 4 5
Hello world 100
*/
```


</CPPSection>

<JavaSection></JavaSection>

<PySection>

## Python Tuples

Use the link below (if you know of a better one, please let us know!) to learn about tuples.

Python automatically sorts a list of tuples by the first element, then the second, and so on. This can save you time and keystrokes for certain problems like the one above.

<Resources>

<Resource
	source="Tutorialspoint"
	title="Python Tuples"
	url="https://www.tutorialspoint.com/python/python_tuples.htm"
	starred
/>

</Resources>

</PySection>

</LanguageSection>

<!-- ## Problems

There aren't any problems in this section because Dynamic Arrays can be used in almost any problem, and doesn't directly solve any USACO problems. -->

<!-- Unless someone has any. I really can't find anything... -->

