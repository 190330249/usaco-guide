---
id: intro-sets
title: Introduction to Sorting
author: Darren Yao, Benjamin Qi, Allen Li
description: 'Sorting, and maintaining collections of distinct elements with ordered sets.'
frequency: 2
prerequisites:
  - intro-ds
---

import { Problem } from '../models';

export const problems = {
	bubble: [
		new Problem(
			'HR',
			'Bubble Sort',
			'https://www.hackerrank.com/challenges/ctci-bubble-sort/problem',
			'Very Easy',
			false,
			[],
			''
		),
	],
	dis: [
		new Problem(
			'CSES',
			'Distinct Numbers',
			'1621',
			'Easy',
			false,
			[],
			'cses-1621',
			'ok'
		),
	],
	ex: [new Problem('YS', 'Associative Array', 'associative_array', 'Easy')],
	standard: [
		new Problem(
			'CF',
			'Kayaking',
			'contest/863/problem/B',
			'Easy',
			false,
			[],
			"Loop over all pairs of people too put in the single Kayaks. Then, sort the remaining people and pair $a_i$ with $a_{i + 1}$ because this minimizes the sum of absolute values (draw some cases if you're confused why)."
		),
		new Problem(
			'Bronze',
			'Why Did the Cow Cross the Road III',
			'713',
			'Easy',
			false,
			[],
			''
		),
		new Problem(
			'CSES',
			'Sum of Two Values',
			'1640',
			'Easy',
			false,
			[],
			'cses-1640'
		),
		new Problem('Bronze', 'Not Last', '687', 'Easy'),
		new Problem(
			'Bronze',
			'Where Am I?',
			'964',
			'Easy',
			false,
			[],
			'Store all substrings in a map of <string, count>, and then find the longest length such that no substring of that length appears twice.'
		),
		new Problem('Silver', 'Bovine Genomics', '739', 'Normal', false, [], ''),
		new Problem(
			'Silver',
			'Cities & States',
			'667',
			'Normal',
			false,
			[],
			'Store two maps of counts for the first two letters of a city and state code, then iterate over the cities and use the maps to efficently query for the corresponding counts.'
		),
	],
};

<Warning>

Bronze problems are designed that you shouldn't need to sort, though the concept can come in very handy for some problems. This module is optional for Bronze contestants.

</Warning>

<Resources>
	<Resource source="IUSACO" title="4.4 - Sets & Maps">
		module is based off this
	</Resource>
	<Resource source="CPH" title="4.2, 4.3 - Sets, Maps" starred></Resource>
</Resources>

## Sorting

<Problems problems={problems.bubble} />

**Sorting** refers to arranging items in some particular order.

<Resources>
	<Resource source="CPH" title="3.1 - Sorting Theory"></Resource>
	<Resource source="CSA" title="Sorting" url="sorting">
		{' '}
	</Resource>
</Resources>

<!-- No bronze problem should require you to sort an array in $O(N\log N)$ time for Bronze,  -->

### Sorting (Dynamic) Arrays

Although you usually do **not** need to know how sorting is implemented, you should know how to use built-in methods to sort a (possibly dynamic) array.

<LanguageSection>

<CPPSection>

<Resources>
	<Resource source="CPH" title="3.2 - Sorting in C++" starred>
		can stop before comparison operators, which are covered in silver
	</Resource>
	<Resource
		source="CPP"
		title="std::sort"
		url="https://en.cppreference.com/w/cpp/algorithm/sort"
	>
		reference
	</Resource>
	<Resource source="CF" title="C++ Tricks" url="74684">
		first two related to sorting
	</Resource>
</Resources>

In order to sort a dynamic array, use `sort(v.begin(), v.end())` (or `sort(begin(v),end(v))`), whereas static arrays require `sort(arr, arr + N)` where $N$ is the number of elements to be sorted. The default sort function sorts the array in ascending order.

</CPPSection>

<JavaSection>

In order to sort a static or dynamic array, use `Arrays.sort(arr)` or `Collections.sort(list)` respectively. The default sort function sorts the array in ascending order.

- [Arrays.sort](<https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#sort(java.lang.Object[])>)
- [Collections.sort](<https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#sort(java.util.List)>)

<Warning>

The `Arrays.sort()` function uses quicksort on primitive data types such as `long`s. This is fine for USACO, but in other contests such as CodeForces, it may time out on test cases specifically engineered to trigger worst-case $\Theta(N^2)$ behavior in quicksort.

</Warning>

See [here](https://codeforces.com/contest/1324/hacks/625031/) for an example of a solution that was hacked on CodeForces.

Two ways to avoid this:

- Declare the underlying array as an array of objects, for example `Long` instead of `long`. This forces the `Arrays.sort()` function to use mergesort, which is always $O(N \log N)$.
- [Shuffle](https://pastebin.com/k6gCRJDv) the array beforehand.

</JavaSection>

<PySection>

- [Sorting Basics](https://docs.python.org/3/howto/sorting.html)

</PySection>

</LanguageSection>

### Sorting Pairs & Tuples

<LanguageSection>

<CPPSection>

<Resources>
	<Resource source="CPH" title="3.2 - Comparison Operators" starred></Resource>
</Resources>

By default, C++ pairs are sorted by first element and then second element in case of a tie.

Example from CPH:

```cpp
#include <bits/stdc++.h>
using namespace std;

int main() {
	vector<pair<int,int>> v;
	v.push_back({1,5});
	v.push_back({2,3});
	v.push_back({1,2});
	sort(v.begin(), v.end());
	for (pair<int,int> p: v) cout << p.first << " " << p.second << "\n";
}

/* Output:
1 2
1 5
2 3
*/
```

Tuples are sorted similarly.

</CPPSection>

<JavaSection>

You'll need to define your own **custom comparator**. This is covered in [Silver](/silver/sorting-custom).

</JavaSection>

</LanguageSection>

## Problems

<Problems problems={problems.dis} />

<!-- <IncompleteSection>

what about USACO problems? (though sorting is _very_ rare in Bronze)

</IncompleteSection> -->

<!-- I added one, but I can't find anything else -->

## Ordered Sets & Maps

Both Java and C++ contain two versions of sets and maps; one using **sorting** and the other using **hashing**. We'll only introduce the former version in this module.

### Sets

<Problems problems={problems.dis} />

A **set** is a collection of objects that contains no duplicates. In ordered sets, the entries are sorted in order of key. Insertions, deletions, and searches are all $O(\log N)$, where $N$ is the number of elements in the set.

<LanguageSection>

<CPPSection>

The operations on a C++ [`set`](http://www.cplusplus.com/reference/set/set/) include:

- `insert`, which adds an element to the set if not already present.
- `erase`, which deletes an element if it exists.
- `count`, which returns `1` if the set contains the element and `0` if it doesn't.

```cpp
set<int> s;
s.insert(1); // [1]
s.insert(4); // [1, 4]
s.insert(2); // [1, 2, 4]
s.insert(1); // [1, 2, 4]
// the add method did nothing because 1 was already in the set
cout << s.count(1) << endl; // 1
s.erase(1); // [2, 4]
cout << s.count(5) << endl; // 0
s.erase(0); // [2, 4]
// if the element to be removed does not exist, nothing happens

for (int element : s) {
    cout << element << " ";
}
cout << endl;
// You can iterate through an set in sorted order
```

</CPPSection>

<JavaSection>

The operations on a `TreeSet` are `add`, which adds an element to the set if not already present, `remove`, which deletes an element if it exists, and `contains`, which checks whether the set contains that element.

```java
Set<Integer> set = new TreeSet<Integer>();
set.add(1); // [1]
set.add(4); // [1, 4]
set.add(2); // [1, 2, 4]
set.add(1); // [1, 2, 4]
// the add method did nothing because 1 was already in the set
System.out.println(set.contains(1)); // true
set.remove(1); // [2, 4]
System.out.println(set.contains(5)); // false
set.remove(0); // [2, 4]
// if the element to be removed does not exist, nothing happens

for(int element : set){
  System.out.println(element);
}
// You can iterate through an set in sorted order
```

</JavaSection>

<PySection>

<Warning>

Ordered sets and maps are **not** built into Python. The Python [OrderedDict](https://docs.python.org/3/library/collections.html#collections.OrderedDict) stores keys in the same order as they were inserted in, **not** in sorted order.

</Warning>

</PySection>

</LanguageSection>

### Maps

<Problems problems={problems.ex} />

A **map** is a set of ordered pairs, each containing a **key** and a **value**. In a map, all keys are required to be unique, but values can be repeated. Maps have three primary methods:

- one to add a specified key-value pairing
- one to retrieve the value for a given key
- one to remove a key-value pairing from the map

Insertions, deletions, and searches are all $O(\log N)$, where $N$ is the number of elements in the map.

<LanguageSection>

<CPPSection>

In a C++ [`map`](http://www.cplusplus.com/reference/map/map/) `m`:

- the `m[key] = value` operator assigns a value to a key and places the key and value pair into the map. The operator `m[key]` returns the value associated with the key. If the key is not present in the map, then `m[key]` is set to 0.
- The `count(key)` method returns the number of times the key is in the map (which is either one or zero), and therefore checks whether a key exists in the map.
- Lastly, `erase(key)` removes the map entry associated with the specified key.

```cpp
map<int, int> m;
m[1] = 5; // [(1, 5)]
m[3] = 14; // [(1, 5); (3, 14)]
m[2] = 7; // [(1, 5); (2, 7); (3, 14)]
m.erase(2); // [(1, 5); (3, 14)]
cout << m[1] << '\n'; // 5
cout << m.count(7) << '\n' ; // 0
cout << m.count(1) << '\n' ; // 1
```

</CPPSection>

<JavaSection>

In a `TreeMap`, the `put(key, value)` method assigns a value to a key and places the key and value pair into the map. The `get(key)` method returns the value associated with the key. The `containsKey(key)` method checks whether a key exists in the map. Lastly, `remove(key)` removes the map entry associated with the specified key. All of these operations are $O(1)$, but again, due to the hashing, this has a high constant factor.

```java
Map<Integer, Integer> map = new TreeMap<Integer, Integer>();
map.put(1, 5); // [(1, 5)]
map.put(3, 14); // [(1, 5); (3, 14)]
map.put(2, 7); // [(1, 5); (2, 7); (3, 14)]
map.remove(2); // [(1, 5); (3, 14)]
System.out.println(map.get(1)); // 5
System.out.println(map.containsKey(7)); // false
System.out.println(map.containsKey(1)); // true
```

</JavaSection>

<PySection>

Colloquially, maps are referred to as **dicts** in python. They act as hash maps, so they actually have $O(1)$ insertion, deletion, and searches.

```py
dict = {}
dict[1] = 5 # [(1, 5)]
dict[3] = 14 # [(1, 5); (3, 14)]
dict[2] = 7 # [(1, 5); (2, 7); (3, 14)]
del dict[2] # [(1, 5); (3, 14)]
print(dict[1]) # 5
print(7 in dict.keys()) # False
print(1 in dict.keys()) # True
```

</PySection>

</LanguageSection>

<IncompleteSection>

What about iterating over map?

</IncompleteSection>

## Problems

<Problems problems={problems.standard} />
