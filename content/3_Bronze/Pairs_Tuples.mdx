---
id: pairs-tuples
title: Pairs & Tuples
author: Aaron Chew, Benjamin Qi, Nathan Wang, Darren Yao, Abutalib Namazov
description: Introduces pairs, which allow you to store two objects (possibly of different types) as a single unit, as well as tuples, which are a generalization of pairs.
prerequisites:
 - Bronze - Introduction to Data Structures
---

Storing multiple elements as a single unit allows you to change the order of the elements (e.g. sorting) without mixing one component with another.

**Example:** Given some points on a plane where the $i$-th point has coordinates $(x_i,y_i)$, sort these points in increasing order of $x$ coordinate and increasing order of $y$ in case there is a tie.

If you sort one of $x_i$ and $y_i$ without considering the other, the points will not be in the correct order. We need to consider the pair $(x_i,y_i)$ as a single unit.

## Pairs

### [C++](http://www.cplusplus.com/reference/utility/pair/pair/)

 - `pair<type1, type2> p`: Creates a pair `p` with two elements with the first one being of `type1` and the second one being of `type2`.
 - `make_pair(a, b)`: Returns a pair with values `a`, `b`.
 - `{a, b}`: With C++11 and above, this can be used as to create a pair, which is easier to write than `make_pair(a, b)`.
 - `pair.first`: The first value of the pair.
 - `pair.second`: The second value of the pair.

By default, pairs are sorted by first element and then second element in case of a tie, which is precisely what we need for the example above.

Example:

```cpp
#include <iostream>

using namespace std;

int main() {
  pair<string, int> myPair1 = make_pair("Testing", 123);
  cout << myPair1.first << " " << myPair1.second << endl; // Testing 123
  myPair1.first = "It is possible to edit pairs after declaring them";
  cout << myPair1.first << " " << myPair1.second << endl;
  
  pair<string, string> myPair2 = {"Testing", "curly braces"};
  cout << myPair2.first << " " << myPair2.second << endl; // Testing curly braces
}

/* Output
 * Testing 123
 * Testing curly braces
 * It is possible to edit pairs after declaring them 123
 */
```

(example code with sorting?)

### Java

Unfortunately, there is no default class for pairs in java, so you have to create your own.

```java
class pair implements Comparable <pair>{
    int first;
    int second;
    public int compareTo(pair other) {
        return first==other.first?second-other.second:first-other.first;
    }
    pair(int a, int b) {
        first=a;
        second=b;
    }
}

```
If you have an array ```pair[]arr=new pair[100]```, make sure each element of this array is not null. You can call ```Arrays.sort(arr);``` on this array and it will sort it by all the ```first``` of the array and if there is a tie in ```first``` it will sort by ```second```.

You can also use an `int[]` as a pair, or if you're using a pair of two different types, you can use `Object[]`.

If you want to sort by 3 or more elements, it's a simple change. Just add a new variable in ```pair``` and make sure the comparable compares in the right order you want. 

## [Tuples](http://www.cplusplus.com/reference/tuple/)

Of course, we can hold more than two values with something like `pair<int,pair<int,int>>`, but it gets messy when you need a lot of elements. In this case, using tuples or [custom classes/structs](https://usaco-guide.netlify.app/silver/sorting-custom) might be more convenient.

 - `tuple<type1, type2, ..., typeN> t`: Creates a tuple with `N` elements, i'th one being of `typei`.
 - `make_tuple(a, b, c, ..., d)`: Returns a tuple with values written in the brackets.
 - `get<i>(t)`: Returns the i'th element of the tuple `t`. Only works for constant i (must be some number, not variable). Apperantly, can be used to change the element of a tuple.
 - `tie(a, b, c, ..., d) = t`: Equals `a, b, c, ..., d` to the elements of the tuple t accordingly.

This is not frequently used by competitive programmers, but it is good to know and can help you to simplify things sometimes. Also, it is possible to sort an array of tuples. Without using any comparator, sorting tuples will first sort by the first element, then the second, and so on.

Example:

```cpp
#include <iostream>
#include <tuple> /// needs additional library
#include <string>

using namespace std;

int main() {
    int a = 3, b = 4, c = 5;
    tuple<int, int, int> t = tie(a, b, c);
    cout << get<0>(t) << " " << get<1>(t) << " " << get<2>(t) << endl;
    get<0>(t) = 7;
    cout << get<0>(t) << " " << get<1>(t) << " " << get<2>(t) << endl;

    tuple<string, string, int> tp2 = make_tuple("Hello", "world", 100);
    string s1, s2; int x;
    tie(s1, s2, x) = tp2;
    cout << s1 << " " << s2 << " " << x << endl;
}
/* Output
 * 3 4 5
 * 7 4 5
 * Hello world 100
 */
```

Note that it is illegal to do something like the following since $z$ is not constant:

```cpp
tuple<int,int,int> t{3,4,5};
int z = 1; cout << get<z>(t);
```
