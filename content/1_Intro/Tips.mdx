---
id: cpp-tips
title: C++ Tips & Tricks
author: Benjamin Qi
description: "?"
---

## `#include <bits/stdc++.h>`

Use in place of separately including libraries.

<resources>
  <resource source="CPH" title="1.1 - C++ Code Template" starred></resource>
  <resource source="GFG" title="GFG - <bits/stdc++.h>" url="bitsstdc-h-c"> </resource>
</resources>

## Macros

<resources>
  <resource source="CPH" title="1.4 - Shortening Code" starred></resource>
  <resource source="GFG" url="cc-preprocessors" title="Macros"></resource>
  <resource
    source="GCC"
    url="https://gcc.gnu.org/onlinedocs/cpp/Macros.html"
    title="Online Docs - Macros"
  >
    reference
  </resource>
</resources>

## `typedef`, `using`

[Quora](https://www.quora.com/What-is-the-difference-between-typedef-and-using-in-C++)

## Template

[My Template](https://github.com/bqi343/USACO/blob/master/Implementations/content/contest/template.cpp)

### Pairs

```cpp
typedef pair<int,int> pi;
#define mp make_pair
#define f first
#define s second
```

Pretty annoying to keep typing `first` and `second` (especially if you have nested pairs ...)

### Vectors

```cpp
typedef vector<int> vi;

#define sz(x) (int)x.size()
#define all(x) begin(x), end(x)
```

It's generally a good idea to convert a size to a signed integer before doing anything with it to avoid cases like the following.

```cpp
vi x;
cout << x.size()-1 << "\n"; // 18446744073709551615
cout << sz(x)-1 << "\n"; // -1
```

`all(v)` makes sorting part or all of a vector a bit shorter.

```cpp
vi v = {2,4,1,5,3};
sort(1+all(v)); // {2,1,3,4,5}
sort(all(v)); // {1,2,3,4,5}
```

### Constants

```cpp
const int MOD = 1e9+7; // 998244353;
const int MX = 2e5+5;
const ll INF = 1e18;
const ld PI = acos((ld)-1);
```

$10^9+7$ is a prime that appears quite frequently in programming contests. Interestingly, $(10^9+7-1)/2=5\cdot 10^8+3$ is also prime. On the other hand, $998244353-1$ is divisible by $2^{23}$, which is useful for [NTT](<https://en.wikipedia.org/wiki/Discrete_Fourier_transform_(general)#Number-theoretic_transform>).

Almost all USACO problems satisfy $N\le 2\cdot 10^5$, so that's what `MX` is for.

### Generating Random Numbers

```cpp
mt19937 rng((uint32_t)chrono::steady_clock::now().time_since_epoch().count());
```

See [neal's blog](https://codeforces.com/blog/entry/61587) about why `rand()` is bad. Use `rng()` instead.

### Generating Sublime Snippets

[Snippets](https://www.granneman.com/webdev/editors/sublime-text/top-features-of-sublime-text/quickly-insert-text-and-code-with-sublime-text-snippets)

I use [this python script](https://github.com/bqi343/USACO/blob/master/Contests/Tools/Other/makeSnip.py) to automatically update snippets for all of my templates.

Instructions (Mac):

  1. Install `python3`.
  2. Clone [my USACO repository](https://github.com/bqi343/USACO) to  `~/Documents/USACO`.
  3. Add the following to your `~/.zshenv`.

    ```
    export USACO=~/Documents/USACO
    makeSnip() {
      cd $USACO/Implementations/content/contest
      python3 genShort.py
      python3 genLong.py
      python3 $USACO/Contests/Tools/Other/makeSnip.py
    }
    ```

  4. Run `makeSnip` from terminal. It should display a list of the templates that will be added as snippets.
  5. If this succeeded, then typing `Temp` in a cpp file will automatically load my template!


## Lambda Expressions

<resources>
  <resource
    source="GFG"
    url="lambda-expression-in-c"
    title="Lambda Expressions in C++"
  >
    {' '}
  </resource>
</resources>

(describe more)

### Recursive Lambdas

<resources>
  <resource source="open-std" url="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html" title="Y Combinator Proposal" starred> </resource>  
  <resource source="RIP Tutorial" url="https://riptutorial.com/cplusplus/example/8508/recursive-lambdas" title="Recursive Lambdas"> </resource>
</resources>

We can do stuff like the following in C++14:

```cpp
namespace std {
 
template<class Fun>
class y_combinator_result {
	Fun fun_;
public:
	template<class T>
	explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}
 
	template<class ...Args>
	decltype(auto) operator()(Args &&...args) {
		return fun_(std::ref(*this), std::forward<Args>(args)...);
	}
};
 
template<class Fun>
decltype(auto) y_combinator(Fun &&fun) {
	return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));
}
 
} // namespace std

int main() {
	cout << y_combinator([](auto gcd, int a, int b) -> int {
		return b == 0 ? a : gcd(b, a % b);
	})(20,30) << "\n"; // outputs 10
}
```

Looks like [ecnerwal](https://codeforces.com/contest/1375/submission/86008510) uses these a lot ...


<!-- 
import InputOutput from "../../additionalcontent/Input_Output.mdx";
import DebuggingCpp from "../../additionalContent/Debugging_Cpp.mdx";
import ShortenCpp from "../../additionalContent/Shorten_Cpp.mdx";

<InputOutput />

<LanguageSection>

<CPPSection>

<DebuggingCpp />
<ShortenCpp />

</CPPSection>

<JavaSection />
<PythonSection />

</LanguageSection> -->