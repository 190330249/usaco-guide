---
id: dp-more
title: Additional DP Optimizations and Techniques
author: Andi Qu
description: Techniques and optimizations like Knuth's optimization.
frequency: 1
---

export const problems = {
	connected_component: [
		new Problem(
			'CEOI',
			'2016 - Kangaroo',
			'CEOI16_kangaroo',
			'Easy',
			false,
			[],
			''
		),
		new Problem(
			'CF',
			'MCO - Magical Teleporter',
			'https://codeforces.com/group/R2SERIff4f/contest/213171/problem/R',
			'Normal',
			false,
			[],
			''
		),
		new Problem(
			'JOI',
			'2016 - Skyscraper',
			'JOI16_skyscraper',
			'Normal',
			true,
			[],
			'joi-16-skyscraper'
		),
	],
    brokenFocus: new Problem('CSES', 'Counting Tilings', '2181', 'Normal', false, ['Broken Profile'], 'cses-2181'),
	broken: [
		new Problem(
			'CF',
			'Guards in the Storehouse',
			'problemset/problem/845/F',
			'Normal',
			false,
			[],
			''
		),
		new Problem(
			'COCI',
			'2020 - Selotejp',
			'https://evaluator.hsin.hr/tasks/HONI202136selotejp/',
			'Normal',
			false,
			[],
			''
		),
		new Problem(
			'CEOI',
			'2006 - Connect',
			'http://oj.uz/problem/view/CEOI06_connect',
			'Hard',
			false,
			[],
			''
		),
		new Problem(
			'Plat',
			'Compound Escape',
			'949',
			'Very Hard',
			false,
			[],
			'usaco-949'
		),
	],
};

## Knuth's Optimization

<IncompleteSection />

### Tutorials

<Resources>
	<Resource
		source="Jeffrey Xiao"
		title="Knuth's Optimization"
		url="https://jeffreyxiao.me/blog/knuths-optimization"
	></Resource>
	<Resource source="GCP" title="15.4.3 - Knuth's Optimization">
		{' '}
	</Resource>
</Resources>

## Miscellaneous Techniques

<Resources>
	<Resource source="CF" title="zscoder - Nontrivial DP Techniques" url="47764">
		Miscellaneous techniques
	</Resource>
</Resources>

<!-- <Optional title="Application">

Queue with 2 stacks is used to remove a factor of $\mathcal{O}(\log N)$ in [USACO Plat - Mowing Mischief](http://www.usaco.org/index.php?page=viewproblem2&cpid=926).

</Optional> -->

### "Connected Component" DP Problems

<Problems problems={problems.connected_component} />

## DP on Broken Profile

<!-- <Resources>
	<Resource
		source="cp-algo"
		title="DP on Broken Profile"
		url="dynamic_programming/profile-dynamics.html"
	>
		{' '}
	</Resource>
</Resources> -->

Broken profile DP is a subset of bitmask DP. Problems falling under this category generally have the following properties:
1. They're about filling a 2D grid.
2. One of the dimensions (usually rows) is much smaller than the other.
3. When filling the grid, each cell depends only on adjacent cells.
4. The cells don't have many possible values (usually only 2).

The third property is especially important, as it means that we can process the cells column-by-column (imagine a snake wrapping around the grid). We then only need to care about the rightmost processed cell in each row (hence the name "broken profile").

The fourth property suggests that we should use a bitmask to represent that broken profile.

<Warning>

Note that the bitmask doesn't necessarily have to represent the state of the *cells*. In some problems (e.g. CEOI 2006 Connect), it can represent the state of the cell *borders* instead.

</Warning>

<FocusProblem problem={problems.brokenFocus} />

### Tutorial

Let $\texttt{dp}[i][j][mask]$ be the number of ways to tile the grid so that:
- All cells from cell $(0, 0)$ to cell $(i - 1, j)$ are **covered**.
- All cells from cell $(i, j + 1)$ to cell $(N, M)$ are **empty**.
- $mask$ represents whether each of the remaining $N$ cells are **empty**, with the $k$-th bit corresponding to the cell in column $k$.

For example, the following state would contribute toward $\texttt{dp}[4][2][10100_2]$:
![](broken-profile-state-example.png)

We now have two cases when calculating $\texttt{dp}[i][j][mask]$:
- The $j$-th bit of mask is 0, meaning that cell $(i, j)$ is **covered**.
    - Case 1: we used a vertical tile to cover it.
        - Cell $(i - 1, j)$ must have been empty before this, so there are $\texttt{dp}[i - 1][j][mask \oplus 2^j]$ ways to do this.
    - Case 2: we used a horizontal tile to cover it.
        - This is only possible if $j > 1$.
        - Cell $(i, j - 1)$ must have been empty before this, while cells $(i - 1, j - 1)$ and $(i - 1, j)$ must have been covered,
          so there are $\texttt{dp}[i][j - 2][mask]$ to do this.
- The $j$-th bit of the mask is 1, meaning that cell $(i, j)$ is **empty**.
    - Cell $(i - 1, j)$ must have been covered before this, so there are $\texttt{dp}[i - 1][j][mask \oplus 2^j]$ ways to do this.

Note that the indices we need to use may become negative and will thus require wrapping. To simplify calculations and bypass this, simply drop
the first two dimensions of the DP array, as $\texttt{dp}[i][j]$ depends only on $\texttt{dp}[i][j - 1]$ and $\texttt{dp}[i][j - 2]$.

### Code

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;

const ll MOD = 1e9 + 7;

ll dp[1 << 10][3];

int main() {
    cin.tie(0)->sync_with_stdio(0);
    int n, m;
    cin >> n >> m;
    dp[0][1] = 1;
    for (int i = 0; i < m; i++) for (int j = 0; j < n; j++) {
        for (int mask = 0; mask < (1 << n); mask++) {
            dp[mask][2] = dp[mask ^ (1 << j)][1]; // Vertical/no tile
            if (j && !(mask & (1 << j)) && !(mask & (1 << j - 1))) // Horizontal tile
                dp[mask][2] += dp[mask][0];

            if (dp[mask][2] >= MOD) dp[mask][2] -= MOD;
        }
        for (int mask = 0; mask < (1 << n); mask++) {
            dp[mask][0] = dp[mask][1];
            dp[mask][1] = dp[mask][2];
        }
    }
    cout << dp[0][1];
    return 0;
}
```

</CPPSection>

</LanguageSection>

### Broken profile DP Problems

<Problems problems={problems.broken} />
