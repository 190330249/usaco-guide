---
id: meet-in-the-middle
title: 'Meet In The Middle'
author: Chongtian Ma
description:
  'Divide the search space into two'
frequency: 1
prerequisites:
---

## Meet In The Middle

<FocusProblem problem="sample" />


### Tutorial

<Resources>
	<Resource source="CPH" title="5.5 - Meet in the Middle" />
	<Resource
		source="Errichto"
		title="Meet in the Middle | Tutorial & Problems"
		url="https://www.youtube.com/watch?v=18sJ3mK173s"
		starred= "true"
	/>
</Resources>

<Info title="Pro Tip">

Meet in the middle problems often have double the constraints of an already optimized solution.

</Info>

### Naive Solution

Loop through all subsets in the array and if the sum is equal to $x$, then increase our answer. Worst case this does about $4^{40}$ operations, which is way too slow.

### Meet in the Middle Solution

We can divide the given array into two separate arrays. Let's say that the $left$ array runs from indexes $0$ to $n/2-1$, and the $right$ array runs from indexes $n/2$ to $n-1$. Both arrays will have at most $20$ elements, so we can loop through all subsets of these two arrays in at most $2^{21}$ operations, which is perfectly fine.

Now that we've got the subset sums of these two separate arrays, we need to recombine them to search for our answer. For every sum in the $left$, we can simply check how many elements of $x - $sum there are in $right$. This can be done using simple binary search.


<Spoiler title = "Implementation">

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;

int main(){
	int n, x;
	cin >> n >> x;
	vector<int> a(n);
	for (int i = 0; i < n; i++) {
		cin >> a[i];
	}
	
	// stores all possible subset sums from indexes [l,r]
	auto get_subset_sums = [&](int l, int r) -> vector<ll> {
		int len = r - l + 1;
		vector<ll> res;
		
		// loop through all subsets
		for (int i = 0; i < (1 << len); i++) {
			ll sum = 0;
			for (int j = 0; j < len; j++) {
				if (i & (1 << j)) {
					sum += a[l + j];
				}
			}
			res.push_back(sum);
		}
		
		return res;
	};
	
	vector<ll> left = get_subset_sums(0, n / 2 - 1);
	vector<ll> right = get_subset_sums(n / 2, n - 1);
	sort(left.begin(), left.end());
	sort(right.begin(), right.end());
	
	ll ans = 0;
	for (ll i: left) {
		int start_index = lower_bound(right.begin(), right.end(), x - i) - right.begin();
		int end_index = upper_bound(right.begin(), right.end(), x - i) - right.begin();
		ans += end_index - start_index;
	}
	
	cout << ans << endl;
}

```

</Spoiler>
	
### Problems

<Problems problems="general" />
