---
id: interactive
title: Interactive and Communication Problems
author: Andi Qu
description: Some tips and tricks
frequency: 1
---

export const problems = {
	interactiveDnC: new Problem(
		'InfO(1) Cup',
		'2017 - Easter Eggs',
		'https://oj.uz/problem/view/info1cup17_eastereggs',
		'Easy',
		false,
		[],
		''
	),
	interactiveGeneral: [
		new Problem(
			'IOI',
			'2013 - Cave',
			'https://oj.uz/problem/view/IOI13_cave',
			'Easy',
			false,
			[],
			''
		),
		new Problem(
			'IOI',
			'2018 - Combo',
			'https://oj.uz/problem/view/IOI18_combo',
			'Easy',
			false,
			[],
			''
		),
		new Problem(
			'IOI',
			'2017 - The Big Prize',
			'https://oj.uz/problem/view/IOI17_prize',
			'Normal',
			false,
			[],
			''
		),
		new Problem(
			'IOI',
			'2016 - Messy Bug',
			'https://oj.uz/problem/view/IOI16_messy',
			'Normal',
			true,
			[],
			''
		),
		new Problem(
			'APIO',
			'2016 - Gap',
			'https://oj.uz/problem/view/APIO16_gap',
			'Normal',
			false,
			[],
			''
		),
		new Problem(
			'IOI',
			'2014 - Rail',
			'https://oj.uz/problem/view/IOI14_rail',
			'Hard',
			false,
			[],
			''
		),
		new Problem(
			'IOI',
			'2015 - Scales',
			'https://oj.uz/problem/view/IOI15_scales',
			'Hard',
			false,
			[],
			''
		),
		new Problem(
			'IOI',
			'2015 - Towns',
			'https://oj.uz/problem/view/IOI15_towns',
			'Very Hard',
			true,
			[],
			''
		),
		new Problem(
			'IOI',
			'2018 - Highway',
			'https://oj.uz/problem/view/IOI18_highway',
			'Very Hard',
			true,
			[],
			''
		),
		new Problem(
			'IOI',
			'2017 - Simurgh',
			'https://oj.uz/problem/view/IOI17_simurgh',
			'Very Hard',
			true,
			[],
			''
		),
		new Problem(
			'APIO',
			'2017 - Koala Game',
			'https://oj.uz/problem/view/APIO17_koala',
			'Very Hard',
			false,
			[],
			''
		),
	],
	communicationCareLess: new Problem(
		'IOI',
		'2010 - Saveit!',
		'https://oj.uz/problem/view/IOI10_saveit',
		'Normal',
		false,
		[],
		''
	),
	communicationPermutations: new Problem(
		'IOI',
		'2011 - Parrots',
		'https://oj.uz/problem/view/IOI11_parrots',
		'Easy',
		false,
		[],
		''
	),
	communicationXOR: new Problem(
		'IOI',
		'2017 - Coins',
		'https://oj.uz/problem/view/IOI17_coins',
		'Normal',
		false,
		[],
		''
	),
	communicationGeneral: [
		new Problem(
			'CEOI',
			'2014 - Question',
			'https://oj.uz/problem/view/CEOI14_question_grader',
			'Easy',
			false,
			[],
			''
		),
		new Problem(
			'Balkan OI',
			'2011 - cmp',
			'https://oj.uz/problem/view/balkan11_cmp',
			'Easy',
			false,
			[],
			''
		),
		new Problem(
			'IOI',
			'2019 - Transfer',
			'https://oj.uz/problem/view/IOI19_transfer',
			'Easy',
			false,
			[],
			''
		),
		new Problem(
			'IOI',
			'2012 - Last Supper',
			'https://oj.uz/problem/view/IOI12_supper',
			'Normal',
			false,
			[],
			''
		),
		new Problem(
			'JOI',
			'2015 - Navigation',
			'https://dunjudge.me/analysis/problems/762/',
			'Normal',
			false,
			[],
			''
		),
		new Problem(
			'JOI',
			'2020 - Stray Cat',
			'https://oj.uz/problem/view/JOI20_stray',
			'Normal',
			false,
			[],
			''
		),
		new Problem(
			'JOI',
			'2019 - Two Transportations',
			'https://oj.uz/problem/view/JOI19_transportations',
			'Hard',
			true,
			[],
			''
		),
		new Problem(
			'JOI',
			'2018 - Airline',
			'https://oj.uz/problem/view/JOI18_airline',
			'Hard',
			false,
			[],
			''
		),
		new Problem(
			'Egyptian OI',
			'2019 - Problemset',
			'https://codeforces.com/group/swEqtABRxe/contest/253465/problem/C',
			'Very Hard',
			false,
			[],
			''
		),
		new Problem(
			'JOI',
			'2014 - Kanji Shiritori',
			'https://dunjudge.me/analysis/problems/1042/',
			'Insane',
			true,
			[],
			''
		),
	],
};

In this module, we assume that "interactive" means problems that allow a limited number of queries and "communication" means problems about communicating between two separate programs.

## Interactive Problems

### Tip 1: Exploit the Limits

Since almost all interactive problems have a limit on the number of queries you may ask, you should use that limit to guide your thinking. There's no point in trying to come up with a solution that uses $\log N$ queries when the limit is $N^2$!

There are three types of interactive problems:

1. Problems that directly tell you the target complexity of your solution (e.g. IOI 2014 Rail).
2. Problems that only tell you the maximum number of queries you may use (e.g. IOI 2013 Cave).
3. Problems that have a hidden limit on the number of queries (e.g. IOI 2015 Scales).

The first type is nice because we get an idea of what our solution should look like.

The second type is slightly less nice, but we can still approximate the target complexity (e.g. $N = 5000$ and $Q = 70000 \implies N \log N$ queries).

The third type is the least nice, but fortunately, we can sometimes still figure out the hidden limit. For example, in problems with relative scoring (like IOI 2015 Scales), we can submit a solution that uses a fixed number of queries for each input and then reverse-engineer the limit from our score.

### Tip 2: Divide and Conquer

In most interactive problems, the solution is to **divide and conquer**. This is usually either binary search ($\log N$ queries) or something like merge sort ($N \log N$ queries)

Whenever you see large input limits and small query limits, you should immediately think of binary search.

<FocusProblem problem={problems.interactiveDnC} />

In this problem, we have $N = 512$ and $Q \leq 9$. Notice how $2^9 = 512$ - this suggests that we should binary search.

Indeed, that's the solution - try to come up with it yourself!

<Spoiler title="Solution">

The solution is to binary search on the DFS order of the tree for the largest prefix without an easter egg. This works because any prefix of the DFS order is a connected component.

```cpp
#include <bits/stdc++.h>
#include "grader.h"
using namespace std;

vector<int> graph[513], ord;

void dfs(int node = 1, int parent = 0) {
    ord.push_back(node);
    for (int i : graph[node]) if (i != parent) dfs(i, node);
}

int findEgg(int N, vector<pair<int, int>> bridges) {
    for (int i = 1; i <= N; i++) graph[i].clear();
    ord.clear();
    for (pair<int, int> i : bridges) {
        graph[i.first].push_back(i.second);
        graph[i.second].push_back(i.first);
    }
    dfs();
    int l = 0, r = N - 1;
    while (l != r) {
        int mid = (l + r + 1) / 2;
        if (query(vector<int>(ord.begin(), ord.begin() + mid))) r = mid - 1;
        else l = mid;
    }
    return ord[l];
}
```

</Spoiler>

### Problems

<Problems problems={problems.interactiveGeneral} />

## Communication Problems

### Tip 1: Don't Send Everything

Don't worry about not being able to send all the available information - in most cases, you shouldn't be able to!

<FocusProblem problem={problems.communicationCareLess} />

In this problem, it appears that we have to send the shortest paths from each hub to each other node.

However, notice how the path $A \rightarrow C$ is never longer than the path $A \rightarrow B \rightarrow C$, so we can send $A \rightarrow B$ and $B \rightarrow C$ instead of $A \rightarrow B$ and $A \rightarrow C$ to potentially save some bits.

In fact, if we continue breaking down paths this way, we can end up only having to send a single bit for each shortest path!

```cpp
#include "grader.h"
#include <bits/stdc++.h>
#define FOR(i, x, y) for (int i = x; i < y; i++)
using namespace std;

vector<int> graph[1000];
int par[1000], dist[1000][36], state[1000];
bool visited[1000];

void e_dfs(int node = 0, int parent = 0) {
    par[node] = parent;
    visited[node] = true;
    for (int i : graph[node]) if (!visited[i]) e_dfs(i, node);
}

void encode(int nv, int nh, int ne, int *v1, int *v2) {
    FOR(i, 0, ne) {
        graph[v1[i]].push_back(v2[i]);
        graph[v2[i]].push_back(v1[i]);
    }
    e_dfs();
    FOR(i, 0, nv) FOR(j, 0, 10) encode_bit((par[i] & (1 << j)) >> j);

    FOR(hub, 0, nh) {
        dist[hub][hub] = 1;
        queue<int> q;
        q.push(hub);
        while (q.size()) {
            int curr = q.front();
            q.pop();
            for (int i : graph[curr]) if (!dist[i][hub]) {
                dist[i][hub] = dist[curr][hub] + 1;
                q.push(i);
            }
        }

        FOR(i, 0, nv) {
            if (dist[i][hub] == dist[par[i]][hub]) state[i] = 0;
            else if (dist[i][hub] > dist[par[i]][hub]) state[i] = 1;
            else state[i] = 2;
        }
        for (int i = 0; i < nv; i += 5) {
            int enc = 0;
            FOR(j, i, min(i + 5, nv)) enc = (enc * 3 + state[j]);
            FOR(j, 0, 8) encode_bit((enc & (1 << j)) >> j);
        }
    }
}

void d_dfs(int hub, int node = 0, int parent = 0) {
    dist[node][hub] = dist[par[node]][hub] + (state[node] + 1) % 3 - 1;
    for (int i : graph[node]) if (i != parent) d_dfs(hub, i, node);
}

void decode(int nv, int nh) {
    FOR(i, 0, nv) {
        FOR(j, 0, 10) par[i] += decode_bit() << j;
        graph[par[i]].push_back(i);
    }

    FOR(hub, 0, nh) {
        for (int i = 0; i < nv; i += 5) {
            int enc = 0;
            FOR(j, 0, 8) enc += decode_bit() << j;
            for (int j = min(i + 5, nv) - 1; j >= i; j--) {
                state[j] = enc % 3;
                enc /= 3;
            }
        }

        int curr = hub;
        while (curr != par[curr]) {
            dist[par[curr]][hub] = dist[curr][hub] - (state[curr] + 1) % 3 + 1;
            curr = par[curr];
        }
        d_dfs(hub);

        FOR(i, 0, nv) hops(hub, i, dist[i][hub]);
    }
}
```

### Tip 2: Brute Force

Sometimes, the amount of information that we can send is (slightly) more than the amount of information we need to decode.

In this case, we can simply map each piece of information we want to decode to a piece of information that we can send.

<FocusProblem problem={problems.communicationPermutations} />

In this problem, we want to encode and decode an array of 64 integers less than 256 using an unordered sequence of 320 integers less than 256.

The number of arrays of 64 integers less than 256 is slightly less than the number of increasing sequences of 320 integers less than 256, so we can just map each array to an increasing sequence (using bignums) and send that sequence.

### Tip 3: XOR

XOR has a nice property where $A \oplus B \oplus A = B$. This lets us solve many problems where the data sent is corrupted or the receiver doesn't know what data the sender sent.

<FocusProblem problem={problems.communicationXOR} />

### Problems

<Problems problems={problems.communicationGeneral} />
