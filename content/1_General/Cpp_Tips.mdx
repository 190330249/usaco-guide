---
id: cpp-tips
title: (Bonus) Additional C++ Tips
author: Benjamin Qi
description: 'Lambda Expressions, Vectorization'
---

## Lambda Expressions

### Introduction

<Resources>
	<Resource
		source="CPP"
		url="https://en.cppreference.com/w/cpp/language/lambda"
		title="Lambda expressions"
	>
		reference
	</Resource>
	<Resource
		source="UMich"
		url="http://www.umich.edu/~eecs381/handouts/Lambda.pdf"
		title="Using C++ Lambdas"
		starred
	>
		{' '}
	</Resource>
	<Resource
		source="SO"
		url="https://stackoverflow.com/questions/7627098/what-is-a-lambda-expression-in-c11"
		title="What is a lambda expression in C++11?"
	>
		{' '}
	</Resource>
	<Resource
		source="Microsoft"
		url="https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp?view=vs-2019"
		title="Lambda Expressions in C++"
	>
		{' '}
	</Resource>
</Resources>

Anything more beginner-friendly?

<IncompleteSection />

<Resources title="FAQ">
	<Resource
		source="SO"
		url="https://stackoverflow.com/questions/41121441/type-of-a-lambda-function-using-auto"
		title="Type of a lambda function using auto?"
	></Resource>
	<Resource
		source="SO"
		url="https://stackoverflow.com/questions/11323811/what-is-meant-by-retain-state-in-c"
		title="What is meant by 'retain state' in c++?"
	>
		{' '}
	</Resource>
</Resources>

### Recursive Lambdas

<Resources>
	<Resource
		source="open-std"
		url="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0200r0.html"
		title="Y Combinator Proposal"
		starred
	>
		{' '}
	</Resource>
	<Resource
		source="RIP Tutorial"
		url="https://riptutorial.com/cplusplus/example/8508/recursive-lambdas"
		title="Recursive Lambdas"
	>
		{' '}
	</Resource>
</Resources>

If we add the following from the link above in C++14:

```cpp
namespace std {

template<class Fun>
class y_combinator_result {
  Fun fun_;
public:
  template<class T>
  explicit y_combinator_result(T &&fun): fun_(std::forward<T>(fun)) {}

  template<class ...Args>
  decltype(auto) operator()(Args &&...args) {
    return fun_(std::ref(*this), std::forward<Args>(args)...);
  }
};

template<class Fun>
decltype(auto) y_combinator(Fun &&fun) {
  return y_combinator_result<std::decay_t<Fun>>(std::forward<Fun>(fun));
}

} // namespace std
```

Then we can have code like the following!

```cpp
int main() {
  cout << y_combinator([](auto gcd, int a, int b) -> int {
    return b == 0 ? a : gcd(b, a % b);
  })(20,30) << "\n"; // outputs 10
}
```

Looks like [ecnerwala](https://codeforces.com/contest/1375/submission/86008510) uses these a lot.

## Vectorization

Sometimes you'll see the following lines at the beginning of a program.

```cpp
#pragma GCC optimize ("Ofast")
#pragma GCC target ("avx2")
```

According to CodinGame,

> Modern CPUs can execute up to four instructions at the same time if they are independent.

### About

<Resources>
	<Resource source="KACTL" title="10.5.2 - Pragmas" url="https://github.com/kth-competitive-programming/kactl/blob/master/kactl.pdf"></Resource>
	<Resource source="CF" title="What do SSE/AVX do?" url="https://codeforces.com/blog/entry/54682?#comment-387553"> </Resource>
	<Resource source="CodinGame" title="Autovectorization" url="https://www.codingame.com/playgrounds/283/sse-avx-vectorization/autovectorization">some bugs :(, seems ok for most part?</Resource>
</Resources>

According to KACTL:

 - `#pragma GCC optimize ("Ofast")` will make GCC auto-vectorize for loops and optimizes floating points better (assumes associativity and turns off denormals).
 - `#pragma GCC target ("avx,avx2")` can double performance of vectorized code, but causes crashes on old machines. 
 - Also consider the older `#pragma GCC target ("sse4")`.
 
Can also check Wikipedia articles about [AVX](https://en.wikipedia.org/wiki/Advanced_Vector_Extensions) and [SSE](https://en.wikipedia.org/wiki/Streaming_SIMD_Extensions).

<IncompleteSection>

better source to learn about these?

</IncompleteSection>

### Examples from CF

The occasional Div 1 E is trivialized by this!

<!-- - [`unroll-loops`](https://codeforces.com/contest/855/submission/89815160): TLE 49 -->
<!-- - [`Ofast`, `unroll-loops`](https://codeforces.com/contest/855/submission/89815262): 3509ms -->

  - [Nagini](https://codeforces.com/contest/855/submission/47823825)
    - [no pragmas](https://codeforces.com/contest/855/submission/89815214): TLE 30
    - [`O3`](https://codeforces.com/contest/855/submission/89815479): 3509ms
    - [`Ofast`](https://codeforces.com/contest/855/submission/89815327): 3525ms
	- [`Ofast`, `avx`](https://codeforces.com/contest/855/submission/72962496): 2339ms
	- [`Ofast`, `avx2`](https://codeforces.com/contest/855/submission/72962508): 1544ms
	- [`Ofast`, `sse4`](https://codeforces.com/contest/855/submission/72962469): 2479ms
  - [Welcome home, Chtholly](https://codeforces.com/contest/896/submission/47824007)
	- only `Ofast`: TLE
	- `avx`: 2354ms
	- `avx2`: 1684ms
	- `sse4`: 2183ms
  - [Awesome Substrings](https://codeforces.com/contest/1270/submission/68018017)
	- `sse4` / `avx`: TLE
	- `avx2`: 6894ms

### Where Can I Use These?

 - Whether these pragmas are supported depends on the computer architecture (ex. see [here](https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html#x86-Options)).
 - As mentioned above, pragmas may cause runtime errors on some sites (ex. [Szkopu≈Ç](https://szkopul.edu.pl/)). 
 - `Ofast` with `avx2` works on both CF and DMOJ. 
 - I don't believe that these work on USACO. 
 - `#pragma GCC optimize("unroll-loops")` seems to work on InfoArena (ex. compare [this](https://www.infoarena.ro/job_detail/2641920) and [this](https://www.infoarena.ro/job_detail/2641921)).

<IncompleteSection />