---
id: io-speed
title: Input / Output Speed
author: Benjamin Qi
description: ""
---

Generally, input and output speed isn't an issue. However, some platinum tasks have relatively large input files. The [USACO Instructions Page](http://www.usaco.org/index.php?page=instructions) mentions some ways of speeding up I/O; let's check whether these actually make a difference.

## Fast Input

The largest USACO input file I know of is test case 11 of [USACO Platinum - Robotic Cow Herd](http://www.usaco.org/index.php?page=viewproblem2&cpid=674), which is 10.3 megabytes! The answer to this test case is $10^{18}$ (with $N=K=10^5$ and all microcontrollers costing $10^8$).

### C++

`freopen` with `cin` was the slowest method. 

<spoiler title="973ms">

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> P[100000];

int main() {
	freopen("roboherd.in","r",stdin);
	freopen("roboherd.out","w",stdout);
	int N,K; cin >> N >> K;
	for (int i = 0; i < N; ++i) {
		int M; cin >> M; P[i].resize(M);
		for (int j = 0; j < M; ++j) cin >> P[i][j];
	}
	if (N == 3) cout << 61;
	else cout << 1000000000000000000;
}
```

</spoiler>

However, adding `ios_base::sync_with_stdio(0); cin.tie(0);` as the first line of `main()` reduced the runtime to 254 ms.  See [this CodeForces blog](https://codeforces.com/blog/entry/5217) and [StackOverflow](https://stackoverflow.com/questions/31162367/significance-of-ios-basesync-with-stdiofalse-cin-tienull) for more information. 

 - Actually, the former link says that it is supposedly prohibited to use `freopen` to redirect `cin` and `cout` if `ios_base::sync_with_stdio(0); cin.tie(0);` is included, but it works properly as far as I know.

`freopen` with `scanf` is about as fast.

<spoiler title="281ms">

```cpp
#include <bits/stdc++.h> // 281 ms
using namespace std;

vector<int> P[100000];
int main() {
	freopen("roboherd.in","r",stdin);
	freopen("roboherd.out","w",stdout);
	int N,K; scanf("%d%d",&N,&K);
	for (int i = 0; i < N; ++i) {
		int M; scanf("%d",&M); P[i].resize(M);
		for (int j = 0; j < M; ++j) scanf("%d",&P[i][j]);
	}
	if (N == 3) printf("%d",61);
	else printf("%lld",1000000000000000000LL);
}
```
</spoiler>

Using `ifstream` and `ofstream` is also about as fast.

<spoiler title="258ms">

```cpp
#include <bits/stdc++.h>
using namespace std;

vector<int> P[100000];

int main() { // 258 ms
	ifstream fin("roboherd.in");
	ofstream fout("roboherd.out");
	int N,K; fin >> N >> K;
	for (int i = 0; i < N; ++i) {
		int M; fin >> M; P[i].resize(M);
		for (int j = 0; j < M; ++j) fin >> P[i][j];
	}
	if (N == 3) fout << 61;
	else fout << 1000000000000000000;
}
```

</spoiler>

Of course, there are faster methods. For example, if we use FastIO from [here](https://github.com/bqi343/USACO/blob/master/Implementations/content/various/FastIO.h) then the runtime is further reduced.

<spoiler title="91ms">

```cpp
using namespace FastIO;

vector<int> P[100000];

int main() {
	freopen("roboherd.in","r",stdin);
	freopen("roboherd.out","w",stdout);
	int N,K; ri(N,K);
	for (int i = 0; i < N; ++i) {
		int M; ri(M); P[i].resize(M);
		for (int j = 0; j < M; ++j) ri(P[i][j]);
	}
	if (N == 3) cout << 61;
	else cout << 1000000000000000000;
}
```

</spoiler>

### Java

(scanner?)

(buffered reader?)

(custom I/O?)

(streamtokenizer instead of stringtokenizer? see http://www.usaco.org/current/data/sol_threesum_gold_jan20.html)

### Python

Faster than the first C++ method! Significantly less if $P$ does not need to be stored.

<spoiler title="853ms">

```py
fin = open("roboherd.in","r")
fout = open("roboherd.out","w")
N,K = map(int,fin.readline().split())
P = [[] for i in range(N)]
for i in range(N):
	P[i] = map(int,fin.readline().split())
if N == 3:
	fout.write(str(61))
else:
	fout.write(str(1000000000000000000))
```

</spoiler>


## Fast Output

(not using endl?)

(printing out one thing at end?)