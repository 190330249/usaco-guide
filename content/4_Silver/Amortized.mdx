---
id: amortized
title: "Amortized Analysis"
author: Darren Yao
prerequisites:
 - Silver - Introduction to Sorting
 - Silver - Stacks & Queues
description: "?"
---

import { Problem } from "../models";

export const metadata = {
  problems: {
    sample: [
      new Problem("CSES", "Playlist", "1141", "Intro", false, []),
      new Problem("CSES", "Sum of Two Values", "1141", "Easy", false, []),
    ],
    general: [
      new Problem("Silver", "Diamond Collector", "643", "Normal", false, ["2P", "Sorting"], ""),
      new Problem("Silver", "Paired Up", "738", "Normal", false, ["2P", "Sorting"]),
      new Problem("Gold", "Haybale Feast", "767", "Normal", false, ["Set", "Sliding Window"]),
      new Problem("Plat", "Fort Moo", "600", "Normal", false, ["Sliding Window"]),
      new Problem("CF", "Books", "problemset/problem/279/B", "Normal", false, []),
      new Problem("CF", "Cellular Network", "problemset/problem/702/C", "Normal", false, []),
      new Problem("CF", "USB vs. PS/2", "problemset/problem/762/B", "Normal", false, []),
      new Problem("CF", "K-Good Segment", "problemset/problem/616/D", "Normal", false, []),
      new Problem("CF", "Garland", "problemset/problem/814/C", "Normal", false, []),
      new Problem("CF", "Jury Meeting", "problemset/problem/853/B", "Normal", false, []),
    ],
    qs: [
      new Problem("YS","Queue Composite","queue_operate_all_composite","Hard",false,[],""),
    ],
  }
};

## Sample

<problems-list problems={metadata.problems.sample} />

## Two Pointers

Two pointers refers to iterating two monotonic pointers across an array to search for a pair of indices satisfying some condition in linear time.

  - [CSES Playlist](https://cses.fi/problemset/task/1141)

### Tutorials

  - Intro to USACO 14.1
  - CPH 8.1 (Amortized Analysis)

## Sliding Window 

Let's envision a sliding window (or constant size subarray) of size $K$ moving left to right along an array, $a$. For each position of the window, we want to compute some information. 

Let's store a `std::set` of integers representing the integers inside the window. If the window currently spans the range $i \dots j$, we observe that moving the range forward to $i+1 \dots j+1$ only removes $a_i$ and adds $a_{j+1}$ to the window. We can support these two operations and query for the minimum/maximum in the set in $O(\log N)$. 

To compute the sum in the range, instead of using a set, we can store a variable $s$ representing the sum. As we move the window forward, we update $s$ by performing the operations $s -= a_i$ and $s += a_{j+1}$. 

### Min Queue

- [cp-algorithms: Min Stack + Queue](https://cp-algorithms.com/data_structures/stack_queue_modification.html)
  - learn about the "min queue" that CPH describes. 

### Queue w/ Two Stacks

<problems-list problems={metadata.problems.qs} />

<optional-content title="Application">

Used to remove a factor of $O(\log N)$ in [USACO Plat - Mowing Mischief](http://www.usaco.org/index.php?page=viewproblem2&cpid=926).

</optional-content>

### Further Reading

- [Medium](https://levelup.gitconnected.com/an-introduction-to-sliding-window-algorithms-5533c4fe1cc7)
- [G4G](https://www.geeksforgeeks.org/window-sliding-technique/)

## Problems

<problems-list problems={metadata.problems.general} />

<optional-content title="Better Memory with Two Passes">

- [Plat - Train Tracking](http://www.usaco.org/index.php?page=viewproblem2&cpid=841)
  - Extremely difficult.

</optional-content>