---
id: all-roots
title: DP on Trees - Solving For All Roots
author: Benjamin Qi, Andi Qu, Andrew Wang, Dong Liu
prerequisites:
  - dp-trees
description: Tree DP that uses the subtree from excluding each node's subtree.
frequency: 1
---

<FocusProblem problem="ex" />

## Solution - Tree Distances I

<Resources>
	<Resource source="CPH" title="14.3 - All Longest Paths" />
</Resources>

<Info title="Note">

This problem previously appeared in
[Intro to Trees](/silver/intro-tree/#problem-cses-1132). This is simply an
alternate solution to the problem.

</Info>

It is a common technique to calculate two DP arrays for some DP on trees problems. Usually one DP array is responsible for calculating results within the subtree rooted at $i$. The other DP array calculates results outside of the subtree rooted at $i$. 

The focus problem asks us to find for each node the maximum distance to another node. We can divide the problem into two parts. 

Define $f[x]$ as the maximum distance from node $x$ to any node in the subtree rooted at $x$.

Define $g[x]$ as the maximum distance from node $x$ to any node outside of the subtree rooted at $x$.

Then the answer for node $x$ = $max(f[x],g[x])$

$f[x]$ can be calculated using a DFS since $f[x]$ = $max(f[c])+1$, where $c$ is a child of $x$.

$g[x]$ can also be calculated using a DFS as $g[c]$ = $max(g[x]+1,f[d]+1)$, where $c$ and $d$ are both children of $x$ with $c \neq d$.

To calculate $g$ in linear time, we can define another array $h$ such that $h[x]$ is the second largest distance from node $x$ to any node in the subtree rooted at $x$. So if $f[x]$ is transitioned from the branch with $c$, $g[c]$ = $max(g[x]+1,h[x]+1)$. Otherwise $g[c]$ = $max(g[x]+1,f[x]+1)$.

<LanguageSection>

<CPPSection>

```cpp
#include <iostream>
#include <vector>
#define pii pair<int,int>
#define fi first
#define se second
#define pb push_back
using namespace std;

const int maxN = 2e5+5;


pii f[maxN]; //f[x].fi = maximum distance from x to a node in subtree with root x
             //f[x].se = the immediate child of x that f[x].fi used to transition
int h[maxN];//h[x] = second longest distance from x to a node in subtree with root x
int g[maxN]; //g[x] = maximum distance from x to a node outside of the subtree rooted at x
vector<int> adj[maxN];
int N;

int dfs1(int x, int fa){
    int val = -1;
    for(int i = 0; i < adj[x].size(); ++i){
        int c = adj[x][i];
        if(c == fa)continue;
        val = dfs1(c,x);
        if(f[x].fi <= val + 1){
           h[x] = f[x].fi;
           f[x].fi = val + 1;
           f[x].se = c;
        }
        else if(h[x] <= val + 1){
            h[x] = val + 1;
        }
    }
    return f[x].fi;
}

void dfs2(int x, int fa){
    for(int i = 0; i < adj[x].size(); ++i){
        int c = adj[x][i];
        if(c == fa)continue;
        if(f[x].se == c){
            g[c] = max(g[c],max(g[x]+1,h[x]+1));
        }
        else g[c] = max(g[c],max(g[x]+1,f[x].fi + 1));
        dfs2(c,x);
    }
    return;
}

signed main(){
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cin >> N;
    for(int i = 1; i < N; ++i){
        int a,b; cin >> a >> b;
        adj[a].pb(b);
        adj[b].pb(a);
    }
    dfs1(1,0); //Calculates results that derives from nodes inside the subtree
    dfs2(1,0); //Calculates results that derives from nodes outside of the subtree
    for(int i = 1; i <= N; ++i){
        cout << max(f[i].fi,g[i]) << '\n';
    }
    return 0;
}
```

</CPPSection>

<JavaSection>

```java
import java.util.*;
import java.io.*;

public class Main {
	public static ArrayList <Integer> g[];
	public static Pair maxl1[];
	public static Pair maxl2[];
	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		int N = Integer.parseInt(br.readLine());
		g = new ArrayList[N + 1];
		maxl1 = new Pair[N + 1];
		maxl2 = new Pair[N + 1];
		for (int i = 0; i <= N; i++) {
			g[i] = new ArrayList <Integer> ();
			maxl1[i] = new Pair(0, 0);
			maxl2[i] = new Pair(0, 0);
		}

		for (int i = 1; i < N; i++) {
			StringTokenizer st = new StringTokenizer(br.readLine());
			int a = Integer.parseInt(st.nextToken());
			int b = Integer.parseInt(st.nextToken());
			g[a].add(b);
			g[b].add(a);
		}
		dfs1(1, 0);
		dfs2(1, 0);
		for (int i = 1; i <= N; i++) {
			System.out.print(maxl1[i].f + " ");
		}
	}
	public static int dfs1(int i, int p) {
		int ret = 0;
		for (int next: g[i]) {
			if (next != p) {
				int c = dfs1(next, i);
				ret = Math.max(ret, c + 1);
				if (c + 1 > maxl1[i].f) {
					maxl2[i] = maxl1[i];
					maxl1[i] = new Pair(c + 1, next);

				} else if (c + 1 > maxl2[i].f) {
					maxl2[i] = new Pair(c + 1, next);
				}
			}
		}
		return ret;
	}
	public static void dfs2(int i, int p) {
		if (p != 0) {
			if (maxl1[p].s == i) {
				if (maxl2[p].f + 1 > maxl1[i].f) {
					maxl2[i] = maxl1[i];
					maxl1[i] = new Pair(maxl2[p].f + 1, p);

				} else if (maxl2[p].f + 1 > maxl2[i].f) {
					maxl2[i] = new Pair(maxl2[p].f + 1, p);
				}
			} else {
				if (maxl1[p].f + 1 > maxl1[i].f) {
					maxl2[i] = maxl1[i];
					maxl1[i] = new Pair(maxl1[p].f + 1, p);
				} else if (maxl1[p].f + 1 > maxl2[i].f) {
					maxl2[i] = new Pair(maxl1[p].f + 1, p);
				}
			}
		}
		for (int next: g[i]) {
			if (next != p) dfs2(next, i);
		}
	}
	static class Pair {
		public int f, s;
		public Pair(int f, int s) {
			this.f = f;
			this.s = s;
		}
	}
}
```

</JavaSection>

</LanguageSection>

## Problems

<Warning>

Although the intended solution for "Cow At Large" is extremely difficult, it is
not too hard to fakesolve! See the internal solution for details.

</Warning>

<Problems problems="roots" />

<IncompleteSection />
