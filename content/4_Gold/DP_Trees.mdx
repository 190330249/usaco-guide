---
id: dp-trees
title: "Introduction to Dynamic Programming on Trees"
author: Michael Cao
prerequisites: 
 - dfs
 - intro-dp
description: "Using subtrees as subproblems."
frequency: 2
---

import { Problem } from "../models";

export const problems = {
    sample: [
      new Problem("CSES", "Tree Matching", "1130", "Easy", false, ["DP"], ""),
    ],
    allRoots: [
      new Problem("AC", "Subtree", "https://atcoder.jp/contests/dp/tasks/dp_v", "Normal", false, [], ""),
    ],
    usaco: [
      new Problem("AC", "Independent Set", "https://atcoder.jp/contests/dp/tasks/dp_p", "Easy", false, [], ""),
      new Problem("Gold", "Barn Painting", "766", "Easy", false, ["DP"], "similar to independent set on tree"),
      new Problem("Gold", "Directory Traversal", "814", "Normal", false, [], ""),
      new Problem("CF", "BOI - Village (Minimum)", "contest/1387/problem/B1", "Normal", false, [], ""),
      new Problem("Gold", "Delegation", "1019", "Hard", false, ["Greedy"], ""),
      new Problem("Plat", "Delegation", "1020", "Very Hard", false, ["DP", "Binary Search"], ""),
      new Problem("Plat", "Cow At Large", "793", "Insane", false, [], "This is not too hard to fakesolve. First write an (optimized?) O(N^2) DP to pass test cases 1-6. This won't work for test cases 7-11, but in these test cases all trees have at most 20 leaves. Therefore it suffices to compress tree edges (repeatedly remove vertices of degree 2) and run the same solution. For a legit DP solution, see Eric Zhang's comment here: https://codeforces.com/blog/entry/57170?#comment-410179"),
      new Problem("CSES", "Creating Offices", "1752", "Insane", false, ["Greedy"], "equivalent to BOI - Cat in a Tree. Exists a greedy-ish strategy!"),
    ],
}

<Problems problems={problems.sample} />

## Tutorial

<Resources>
  <Resource source="CF" title="DP on Trees" url="blog/entry/20935"> </Resource>
  <Resource source="Philippines" title="DP on Trees and DAGs" url="https://noi.ph/training/weekly/week5.pdf">lol this code format is terrible </Resource>
</Resources>

## Solution - Tree Matching

<IncompleteSection />

## Solving for All Roots

<Problems problems={problems.allRoots} />

(dfs twice)

<Spoiler title="Solution">

<LanguageSection>

<CPPSection>

```cpp
template<int SZ> struct SubtreeDP {
  int par[SZ]; vi adj[SZ];
  void ae(int a, int b) { adj[a].pb(b), adj[b].pb(a); }
  struct T { 
    mi v = 1;
    T& operator+=(const T& b) { v *= b.v; return *this; }
    void tran() { ++v; }
  };
  T up[SZ], down[SZ];
  void dfs(int x) {
    trav(t,adj[x]) if (t != par[x]) {
      par[t] = x; dfs(t);
      down[x] += down[t];
    }
    down[x].tran();
  }
  void dfs2(int x) {
    {
      T pre = up[x];
      F0R(i,sz(adj[x])) {
        int c = adj[x][i]; if (c == par[x]) continue;
        up[c] += pre; pre += down[c];
      }
    }
    {
      T pre;
      R0F(i,sz(adj[x])) {
        int c = adj[x][i]; if (c == par[x]) continue;
        up[c] += pre; pre += down[c];
      }
    }
    F0R(i,sz(adj[x])) {
      int c = adj[x][i]; if (c == par[x]) continue;
      up[c].tran(); dfs2(c);
    }
  }
  T getSub(int x, int y) { return par[x] == y ? down[x] : up[y]; }
  void init(int n) {
    par[1] = 0; dfs(1); dfs2(1);
    FOR(i,1,n+1) {
      T p = T(); trav(t,adj[i]) p += getSub(t,i);
      ps(p.v);
    }
};

int main() {
  setIO(); int n; re(n,MOD);
  SubtreeDP<MX> S;
  F0R(i,n-1) {
    int a,b; re(a,b);
    S.ae(a,b);
  }
  S.init(n);
}
```

</CPPSection>

</LanguageSection>


</Spoiler>

## Problems

<Info title="Pro Tip">

Don't just dive into trying to figure out a DP state and transitions -- make some observations if you don't see any obvious DP solution! Also, sometimes a greedy strategy suffices.

</Info>

<Problems problems={problems.usaco} />