---
id: intro-nt
title: 'Introductory Number Theory'
author: Darren Yao, Michael Cao, Andi Qu
prerequisites:
  - intro-dp
description: Introduces divisibility and modular arithmetic. Includes Gold DP problems with number theoretic twists!
frequency: 1
---

import { Problem } from '../models';

export const problems = {
	sample: [new Problem('CSES', 'Counting Divisors', '1713', 'Easy', false, [])],
	kat: [new Problem('Kattis', 'Modular Arithmetic', 'modulararithmetic')],
	expo: [
		new Problem('CSES', 'Exponentiation', '1095', 'Easy', false, [], '@Below'),
	],
	general: [
		new Problem(
			'AC',
			'Div Game',
			'https://atcoder.jp/contests/abc169/tasks/abc169_d',
			'Easy',
			false,
			['Prime Factorization'],
			'Prime factorize the given number. Consider each prime in the factorization separately. For each prime, decrement the exponent by 1 the first time, 2 the second time, and so on, until we can no longer continue without repeating a previously used exponent.'
		),
		new Problem('CSES', 'Exponentiation II', '1712', 'Easy', false, [], ''),
		new Problem(
			'CF',
			'Orac and LCM',
			'1349/problem/A',
			'Normal',
			false,
			['Prime Factorization'],
			'Prime factorize each number. For each prime, the second-to-lowest exponent of the prime that occurs in any of the numbers in the input is the exponent of this prime that will appear in the final answer.'
		),
	],
	permutations: [
		new Problem(
			'Gold',
			'Exercise',
			'1043',
			'Normal',
			false,
			['Knapsack', 'Prime Factorization'],
			'Prime factorize $K$.'
		),
		new Problem(
			'POI',
			'Maximal',
			'https://szkopul.edu.pl/problemset/problem/lGqKS9urITMjTXhpdaHqyoEL/site/?key=statement',
			'Hard',
			false,
			['Knapsack, Prime Factorization']
		),
		new Problem(
			'Plat',
			'Exercise',
			'1045',
			'Insane',
			false,
			['Knapsack', 'Prime Factorization'],
			'Prime factorize $K$.'
		),
	],
	dp: [
		new Problem(
			'CF',
			'Round Subset',
			'http://codeforces.com/contest/837/problem/D',
			'Normal',
			false,
			['DP', 'Knapsack'],
			'dp[i][j][l] -> maximum amount of twos we can collect by checking first i numbers, taking j of them with total power of five equal to l'
		),
		new Problem(
			'Gold',
			'Cow Poetry',
			'897',
			'Normal',
			false,
			['Knapsack', 'Exponentiation'],
			'First consider the case where there are only two lines with the same class.'
		),
		new Problem('Plat', 'Sprinkers 2', '1044', 'Very Hard', false, [
			'dp, modular inverse',
		]),
	],
};

<Resources>
	<Resource source="IUSACO" title="13 - Elementary Number Theory">
		module is based off this
	</Resource>
	<Resource
		source="AoPS@Art of Problem Solving"
		title="Alcumus"
		url="https://artofproblemsolving.com/alcumus/problem"
		starred
	>
		practice problems, set focus to number theory!
	</Resource>
	<Resource
		source="AoPS@Art of Problem Solving"
		title="Intro to NT"
		url="https://artofproblemsolving.com/store/item/intro-number-theory?gtmlist=Bookstore_AoPS_Side"
	>
		good book :D
	</Resource>
	<Resource source="CPH" title="21.1, 21.2 - Number Theory">
		primes and factors, modular arithmetic
	</Resource>
	<Resource source="PAPS" title="16.1, 16.2, 16.4 - Number Theory"></Resource>
</Resources>

<!-- <Resource source="CF" title="CodeNCode - Number Theory Course" url="77137">lots of advanced stuff you don't need to know at this level</Resource>
   -->

## Prime Factorization

<Problems problems={problems.sample} />

A number $a$ is called a **divisor** or a **factor** of a number $b$ if $b$ is divisible by $a$, which means that there exists some integer $k$ such that $b = ka$. Conventionally, $1$ and $n$ are considered divisors of $n$. A number $n > 1$ is **prime** if its only divisors are $1$ and $n$. Numbers greater than \(1\) that are not prime are **composite**.

Every number has a unique **prime factorization**: a way of decomposing it into a product of primes, as follows:

$$
n = {p_1}^{a_1} {p_2}^{a_2} \cdots {p_k}^{a_k}
$$

where the $p_i$ are distinct primes and the $a_i$ are positive integers.

Now, we will discuss how to find the prime factorization of an integer.

<LanguageSection>

<CPPSection>

```cpp
vector<int> factor(int n) {
	vector<int> ret;
	for (int i = 2; i * i <= n; i++) {
		while (n % i == 0) {
			ret.push_back(i);
			n /= i;
		}
	}
	return ret;
}
```

</CPPSection>

<PySection>

```py
def factor(n):
	ret = []
	i = 2
	while i * i <= n:
		while n % i == 0:
			ret.append(i)
			n //= i
		i += 1
	return ret
```

</PySection>

</LanguageSection>

This algorithm runs in $O(\sqrt{n})$ time, because the for loop checks divisibility for at most $\sqrt{n}$ values. Even though there is a while loop inside the for loop, dividing $n$ by $i$ quickly reduces the value of $n$, which means that the outer for loop runs less iterations, which actually speeds up the code.

Let's look at an example of how this algorithm works, for $n = 252$.

![Example](factoralgorithm.png)

At this point, the for loop terminates, because $i$ is already 3 which is greater than $\lfloor \sqrt{7} \rfloor$. In the last step, we add $7$ to the list of factors $v$, because it otherwise won't be added, for a final prime factorization of $\{2, 2, 3, 3, 7\}$.

## Divisibility

### GCD

The **greatest common divisor (GCD)** of two integers $a$ and $b$ is the largest integer that is a factor of both $a$ and $b$. In order to find the GCD of two numbers, we use the **Euclidean Algorithm**, which is as follows:

$$
\gcd(a, b) = \begin{cases}
	 a & b = 0 \\
	 \gcd(b, a \bmod b) & b \neq 0 \\
\end{cases}
$$

This algorithm is very easy to implement using a recursive function, as follows:

<LanguageSection>

<JavaSection>

```java
public int gcd(int a, int b){
	if (b == 0) return a;
	return gcd(b, a % b);
}
```

</JavaSection>

<CPPSection>

```cpp
int GCD(int a, int b){
	if (b == 0) return a;
	return GCD(b, a % b);
}
```

For C++14 and below, use the built-in `__gcd(a,b)`. C++17 has built in `gcd(a,b)`.

</CPPSection>

<PySection>

```py
def gcd(a, b):
	if b == 0:
		return a
	return gcd(b, a % b)
```

</PySection>

</LanguageSection>

This function runs in $O(\log ab)$ time because $a\le b \implies b\%a <\frac{b}{2}$.

The worst-case scenario for the Euclidean algorithm is when $a$ and $b$ are consecutive Fibonacci numbers $F_n$ and $F_{n + 1}$. for an explanation). In this case, the algorithm will calculate $\gcd(F_n, F_{n + 1}) = \gcd(F_{n - 1}, F_n) = \dots = \gcd(0, F_1)$. This means that finding $\gcd(F_n, F_{n + 1})$ takes $n + 1$ steps, which is proportional to $\log \left(F_n F_{n+1}\right)$.

<!-- (See [this Math Stack Exchange answer](https://math.stackexchange.com/questions/2477328/why-are-fibonacci-numbers-bad-for-euclids-algorithm-and-how-to-derive-this-uppe) -->
<!-- ^ this doesn't seem very helpful -->
<!-- Since $F_n = O(\varphi^n)$, the worst-case complexity of this algorithm is $O(\log ab)$. -->

### LCM

The **least common multiple (LCM)** of two integers $a$ and $b$ is the smallest integer divisible by both $a$ and $b$. The LCM can easily be calculated from the following property with the GCD:

$$
\operatorname{lcm}(a, b) = \frac{a \cdot b}{\gcd(a, b)}=\frac{a}{\gcd(a,b)}\cdot b.
$$

<Warning>

Dividing by $\gcd(a,b)$ first might prevent integer overflow.

</Warning>

If we want to take the GCD or LCM of more than two elements, we can do so two at a time, in any order. For example,

$$
\gcd(a_1, a_2, a_3, a_4) = \gcd(a_1, \gcd(a_2, \gcd(a_3, a_4))).
$$

## Modular Arithmetic

<!-- Some silver problems involve $10^9+7$, should this be introduced in silver? -->

<Resources>
	<Resource
		source="David Altizio"
		title="Modular Arithmetic"
		url="https://davidaltizio.web.illinois.edu/ModularArithmetic.pdf"
		starred
	>
		plenty of examples from math contests
	</Resource>
</Resources>

In **modular arithmetic**, instead of working with integers themselves, we work with their remainders when divided by $m$. We call this taking modulo $m$. For example, if we take $m = 23$, then instead of working with $x = 247$, we use $x \bmod 23 = 17$. Usually, $m$ will be a large prime, given in the problem; the two most common values are $10^9 + 7$, and $998\,244\,353=119\cdot 2^{23}+1$. Modular arithmetic is used to avoid dealing with numbers that overflow built-in data types, because we can take remainders, according to the following formulas:

$$
(a+b) \bmod m = (a \bmod m + b \bmod m) \bmod m
$$

$$
(a-b) \bmod m = (a \bmod m - b \bmod m) \bmod m
$$

$$
(a \cdot b) \pmod{m} = ((a \bmod m) \cdot (b \bmod m)) \bmod m
$$

$$
a^b \bmod {m} = (a \bmod m)^b \bmod m
$$

### Modular Exponentiation

<Resources>
	<Resource
		source="cp-algo"
		title="Binary Exponentiation"
		url="algebra/binary-exp.html"
	>
		{' '}
	</Resource>
</Resources>

**Binary exponentiation** can be used to efficently compute $x ^ n \mod m$. To do this, let's break down $x ^ n$ into binary components. For example, $5 ^ {10}$ = $5 ^ {1010_2}$ = $5 ^ 8 \cdot 5 ^ 4$. Then, if we know $x ^ y$ for all $y$ which are powers of two ($x ^ 1$, $x ^ 2$, $x ^ 4$, $\dots$ , $x ^ {2^{\lfloor{\log_2n} \rfloor}}$, we can compute $x ^ n$ in $\mathcal{O}(\log n)$.

To deal with $m$, observe that modulo doesn't affect multiplications, so we can directly implement the above "binary exponentiation" algorithm while adding a line to take results $\pmod m$.

<!--
Finally, since $x ^ y$ for some $y \neq 1$ equals $x ^ {y - 1}$, and $x$ otherwise, we can compute these sums efficently.  -->

#### CSES - Exponentiation

To test your implementation of **Binary Exponentiation**, use the following problem, and check the example code if you're stuck.

<FocusProblem problem={problems.expo[0]} />

<Spoiler title="Solution">

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

using ll = long long;

ll binpow(ll x, ll n, ll m) {
	assert(n >= 0);
	x %= m; //note: m*m must be less than 2^63 to avoid ll overflow
	ll res = 1;
	while (n > 0) {
		if (n % 2 == 1) //if n is odd
			res = res * x % m;
		x = x * x % m;
		n /= 2; //divide by two
	}
	return res;
}

int main() {
	int TC; cin >> TC;
	for (int i = 0; i < TC; ++i) {
		int a, b; cin >> a >> b;
		cout << binpow(a,b,1e9+7) << "\n";
	}
}
```

</CPPSection>

</LanguageSection>

</Spoiler>

### Modular Inverse

The **modular inverse** is the equivalent of the reciprocal in real-number arithmetic; to divide $a$ by $b$, multiply $a$ by the modular inverse of $b$. We'll only consider prime moduli $p$ here.

For example, the inverse of $2$ modulo $p=10^9+7$ is $i=\frac{p+1}{2}=5\cdot 10^8+4$. This means that for any integer $x$,

$$
(2x)\cdot i\equiv x\cdot (2i)\equiv x\pmod{10^9+7}.
$$

For example, $10i\equiv 5\pmod{10^9+7}$.

<!-- #### Example: Sprinkers 2

There aren't many good examples of Modular Inverses in USACO. One problem where it was useful was the platinum problem "Sprinkers 2".

<FocusProblem problem={problems.dp[2]} />

For the sake of example, we'll skip the details of this problem. Also, if you want to attempt it yourself, you should probably do that first. In this problem, our DP transition relies on dividing our answer at some state by $2$, under a prime moduli.

To perform this, we'll instead multiply by $500000004$ or the modular inverse of $2$, and take it under the prime moduli for the same result.
 -->

<!-- To find a modular inverse of some number modulo $p$, simply raise it to the power of $p-2$. -->

<Resources>
	<Resource
		source="cp-algo"
		title="Modular Multiplicative Inverse"
		url="algebra/module-inverse.html"
		starred
	>
		Various ways to take modular inverse, we'll only discuss the second here
	</Resource>
</Resources>

#### With Exponentiation

[**Fermat's Little Theorem**](https://en.wikipedia.org/wiki/Fermat%27s_little_theorem) (not to be confused with Fermat's **Last** Theorem) states that all integers $a$ not divisible by $p$ satisfy $a^{p - 1} \equiv 1 \pmod{p}$. Consequently, $a^{p-2} \cdot a \equiv 1 \pmod{p}$. Therefore, $a^{p - 2}$ is a modular inverse of $a$ modulo $p$.

```cpp
int main() {
	ll m = 1e9+7;
	ll x = binpow(2,m-2,m);
	cout << x << "\n"; // 500000004
	assert(2*x%m == 1);
}
```

Because it takes $\mathcal{O}(\log p)$ time to compute a modular inverse modulo $p$, frequent use of division inside a loop can significantly increase the running time of a program. If the modular inverse of the same number(s) is/are being used many times, it is a good idea to precalculate it.

Also, one must always ensure that they do not attempt to divide by 0. Be aware that after applying modulo, a nonzero number can become zero, so be very careful when dividing by non-constant values.

<Optional title="Another Way to Compute Modular Inverses">

We can also use the extended Euclidean algorithm. See the module in the [Advanced](/adv/extend-euclid) section.

</Optional>

## Problems

### General

<Problems problems={problems.general} />

### DP

<Problems problems={problems.dp} />

### Permutations

<!-- Define the order of permutation $p$ as the number of times you need to apply $p$ to itself to get the identity permutation, or the permutation consisting of integers $1 \cdots N$ where $N$ is the length of permutation $p$.
 -->

<!-- We'll decompose the permutations into disjoint cycles. Then, observe that a cycle of length $l$ takes $l$ operations to match the identity permutation. That means that for $M$ cycles, the permutation requires $LCM(l_1, l_2, \cdots, l_M)$ operations for all the cycles to match the identity permutation.

For a more formal proof, see [this article](http://mathonline.wikidot.com/the-order-of-a-permutation).

</IncompleteSection> -->

<!--

#### Example: Exercise

<FocusProblem problem={problems.permutations[0]} />

Using the fact above, we can rephrase the problem as follows: find the sum of integers $K$ such that there exists an array of lengths $l$ such that

$$
\sum_{i = 1}^{sz(l)} l_i = N
$$

and

$$
LCM(l_1, l_2, \cdots l_{sz(l)}) = K
$$

-->

<Problems problems={problems.permutations} />
