---
id: sp
title: 'Shortest Paths with Non-Negative Edge Weights'
author: Benjamin Qi, Andi Qu
prerequisites:
  - bfs
  - intro-ordered
description: "Introduces Dijkstra's Algorithm for a single source shortest path as well as Floyd-Warshall for All-Pairs Shortest Path."
frequency: 3
---

import { Problem } from '../models';

export const problems = {
	sample: [
		new Problem(
			'CSES',
			'Shortest Routes I',
			'1671',
			'Easy',
			false,
			['SP'],
			'equivalent to [Kattis SSSP Non-Negative](https://open.kattis.com/problems/shortestpath1)'
		),
	],
	dijk: [
		new Problem(
			'CSES',
			'Flight Discount',
			'1195',
			'Easy',
			false,
			['SP'],
			'one edge modified'
		),
		new Problem(
			'CSES',
			'Flight Routes',
			'1196',
			'Easy',
			false,
			['SP'],
			'$k$ smallest paths'
		),
		new Problem('CSES', 'Investigation', '1202', 'Easy', false, ['SP'], ''),
		new Problem('Gold', 'Milk Pumping', '969', 'Easy', false, ['SP'], ''),
		new Problem('Gold', 'Why ... (visitfj)', '717', 'Easy', false, ['SP'], ''),
		new Problem('Gold', 'Shortcut', '899', 'Easy', false, ['SP'], ''),
		new Problem('Gold', 'Fine Dining', '861', 'Easy', false, ['SP'], ''),
		new Problem(
			'Kattis',
			'Robot Turtles',
			'robotturtles',
			'Easy',
			false,
			['SP'],
			''
		),
		new Problem(
			'IOI',
			'2011 - Crocodile',
			'https://oj.uz/problem/view/IOI11_crocodile',
			'Easy',
			false,
			['SP'],
			''
		),
		new Problem(
			'Kattis',
			'Lane Switching',
			'https://open.kattis.com/contests/acpc17open/problems/laneswitching',
			'Normal',
			false,
			['SP'],
			''
		),
		new Problem(
			'JOI',
			'2018 - Commuter Pass',
			'https://oj.uz/problem/view/JOI18_commuter_pass',
			'Hard',
			true,
			['SP', 'DP'],
			''
		),
		new Problem(
			'APIO',
			'2011 - Find the Path',
			'https://dmoj.ca/problem/apio11p2',
			'Hard',
			false,
			['SP', 'Geometry'],
			''
		),
		new Problem(
			'Balkan OI',
			'2012 - Shortest Paths',
			'https://www.acmicpc.net/problem/5250',
			'Very Hard',
			true,
			['SP', 'LCA'],
			''
		),
	],
	apspSam: [
		new Problem(
			'CSES',
			'Shortest Routes II',
			'1672',
			'Easy',
			false,
			['APSP'],
			''
		),
	],
	apsp: [
		new Problem(
			'Gold',
			'Moortal Cowmbat',
			'971',
			'Hard',
			false,
			['APSP', 'DP'],
			''
		),
		new Problem(
			'COCI',
			'2009 - Gremlini',
			'https://hsin.hr/coci/archive/2009_2010/contest6_tasks.pdf',
			'Hard',
			false,
			['APSP', 'DP'],
			''
		),
		new Problem(
			'APIO',
			'2017 - Traveling Merchant',
			'https://oj.uz/problem/view/APIO17_merchant',
			'Hard',
			true,
			['APSP', 'Binary Search'],
			''
		),
	],
};

## Single-Source Shortest Path

<Problems problems={problems.sample} />

### Tutorial

Use _Dijkstra's Algorithm_.

<Resources>
	<Resource source="CPH" title="13.2 - Dijkstra" starred>
		code
	</Resource>
	<Resource
		source="cp-algo"
		title="Dijkstra (Dense Graphs)"
		url="graph/dijkstra.html"
	></Resource>
	<Resource
		source="cp-algo"
		title="Dijkstra (Sparse Graphs)"
		url="graph/dijkstra_sparse.html"
	></Resource>
	<Resource source="CPC" title="8 - Graphs 2" url="08_graphs_2"></Resource>
	<Resource source="CP2" title="4.4.3 - SSSP on Weighted Graph"></Resource>
</Resources>

### Implementation

#### Part 1: $O(N^2)$

The USACO training pages present a $O(N^2)$ version, although this is rarely used nowadays. (but describe anyways?)

<IncompleteSection />

#### Part 2: $O(M\log N)$

<Resources>
	<Resource
		source="Benq"
		title="Dijkstra"
		url="https://github.com/bqi343/USACO/blob/master/Implementations/content/graphs%20(12)/Basics/Dijkstra%20(7.3).h"
	>
		{' '}
	</Resource>
</Resources>

<LanguageSection>

<CPPSection>

```cpp
vector<pair<int, int>> graph[100000]; // Adjacency list of (neighbour, edge weight)
int dist[100000];

int dijkstra(int src, int dest) { // Source and destination
	memset(dist, 0x3f, sizeof dist); // Set all distances to infinity

	// N.B. Priority queues sort in descending order, so we use negative distances
    priority_queue<pair<int, int>> pq;
    pq.push({0, src});
    dist[src] = 0; // The shortest path from a node to itself is 0

    while (pq.size()) {
        int dist, node;
        tie(dist, node) = pq.top();
        pq.pop();
        if (node == dest) return -dist; // We've found the shortest path

        for (pair<int, int> i : graph[node]) {
			// If we can reach a neighbouring node faster, we update its minimum distance
            if (i.second - dist < dist[i.first]) {
                dist[i.first] = i.second - dist;
                pq.push({dist - i.second, i.first});
            }
        }
    }

    return -1; // We can't reach dest from src :(
}
```

</CPPSection>

</LanguageSection>

<Optional title="Faster Dijkstra">

Can be done in $O(M+N\log N)$ with [Fibonacci heap](https://en.wikipedia.org/wiki/Fibonacci_heap). In practice though, this is rarely faster, since the Fibonacci heap has a bad constant factor.

</Optional>

### Problems

<Problems problems={problems.dijk} />

## All Pairs Shortest Path (APSP)

<Problems problems={problems.apspSam} />

Use the _Floyd-Warshall_ algorithm.

### Tutorial

<Resources>
	<Resource source="CPH" title="13.3 - Floyd-Warshall" starred>
		example calculation, code
	</Resource>
	<Resource source="PAPS" title="12.3.3"></Resource>
	<Resource
		source="cp-algo"
		title="Floyd-Warshall"
		url="graph/all-pair-shortest-path-floyd-warshall.html"
	></Resource>
	<Resource source="CP2" title="4.5 - All-Pairs Shortest Paths"></Resource>
</Resources>

<Optional title="Incorrect Floyd-Warshall">

[Paper](https://arxiv.org/pdf/1904.01210.pdf)

> A common mistake in implementing the Floyd–Warshall algorithm is to misorder the triply nested loops (The correct order is `KIJ`). The incorrect `IJK` and `IKJ` algorithms do not give correct solutions for some instance. However, we can prove that if these are repeated three times, we obtain the correct solutions.
>
> It would be emphasized that these fixes (repeating incorrect algorithms three times) have the same time complexity as the correct Floyd–Warshall algorithm up to constant factors. Therefore, our results suggest that, if one is confused by the order of the triply nested loops, one can repeat the procedure three times just to be safe.

</Optional>

### Problems

<Problems problems={problems.apsp} />
