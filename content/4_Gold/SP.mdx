---
id: sp
title: "Shortest Paths with Non-Negative Edge Weights"
author: Benjamin Qi
prerequisites: 
 - Gold - Breadth First Search
description: "Introduces Dijkstra's Algorithm for a single source shortest path as well as Floyd-Warshall for All-Pairs Shortest Path."
frequency: 3
---

import { Problem } from "../models";

export const metadata = {
  problems: {
    sample: [
      new Problem("CSES", "Shortest Routes I", "1671", "Easy", false, ["SP"], "equivalent to [Kattis SSSP Non-Negative](https://open.kattis.com/problems/shortestpath1)"),
    ],
    dijk: [
      new Problem("CSES", "Flight Discount", "1195", "Easy", false, ["SP"], "one edge modified"),
      new Problem("CSES", "Flight Routes", "1196", "Easy", false, ["SP"], "$k$ smallest paths"),
      new Problem("CSES", "Investigation", "1202", "Easy", false, ["SP"], ""),
      new Problem("Gold", "Milk Pumping", "969", "Easy", false, ["SP"], ""),
      new Problem("Gold", "Visit FJ", "717", "Easy", false, ["SP"], ""),
      new Problem("Gold", "Shortcut", "899", "Easy", false, ["SP"], ""),
      new Problem("Gold", "Fine Dining", "861", "Easy", false, ["SP"], ""),
      new Problem("Kattis", "Robot Turtles", "robotturtles", "Easy", false, ["SP"], ""),
      new Problem("Kat", "Lane Switching", "https://open.kattis.com/contests/acpc17open/problems/laneswitching", "Normal", false, ["SP"], ""),
    ],
    apspSam: [
      new Problem("CSES", "Shortest Routes II", "1672", "Easy", false, ["APSP"], ""),
    ],
    apsp: [
      new Problem("Gold", "Moortal Cowmbat", "971", "Hard", false, ["APSP", "DP"], ""),
    ],
  }
};

## Single-Source Shortest Path

<Problems problems={metadata.problems.sample} />

### Tutorial

Use *Dijkstra's Algorithm*. 

<Resources>
  <Resource source="CPH" title="13.2 - Dijkstra" starred>code</Resource>
  <Resource source="cp-algo" title="Dijkstra (Dense Graphs)" url="graph/dijkstra_dense.html"></Resource>
  <Resource source="cp-algo" title="Dijkstra (Sparse Graphs)" url="graph/dijkstra_sparse.html"></Resource>
  <Resource source="CPC" title="8 - Graphs 2" url="08_graphs_2"></Resource>
</Resources>


### Implementation

#### Part 1: $O(N^2)$

The USACO training pages present a $O(N^2)$ version, although this is rarely used nowadays. (but describe anyways?)

<IncompleteSection />

#### Part 2: $O(M\log N)$

<Resources>
  <Resource source="Benq" title="Dijkstra" url="https://github.com/bqi343/USACO/blob/master/Implementations/content/graphs%20(12)/Basics/Dijkstra%20(7.3).h"> </Resource>
</Resources>

<IncompleteSection />

(comments in code?)

<Optional title="Faster Dijkstra">

Can be done in $O(M+N\log N)$ with [Fibonacci heap](https://en.wikipedia.org/wiki/Fibonacci_heap).

</Optional>

### Problems 

<Problems problems={metadata.problems.dijk} />

## All Pairs Shortest Path (APSP)

<Problems problems={metadata.problems.apspSam} />

Use the *Floyd-Warshall* algorithm.

### Tutorial

<Resources>
  <Resource source="CPH" title="13.3 - Floyd-Warshall" starred>example calculation, code</Resource>
  <Resource source="PAPS" title="12.3.3"></Resource>
  <Resource source="cp-algo" title="Floyd-Warshall" url="graph/all-pair-shortest-path-floyd-warshall.html"></Resource>
</Resources>

<Optional title="Incorrect Floyd-Warshall">

[Paper](https://arxiv.org/pdf/1904.01210.pdf)

> A common mistake in implementing the Floyd–Warshall algorithm is to
misorder the triply nested loops (The correct order is `KIJ`). The incorrect
`IJK` and `IKJ` algorithms do not give correct solutions for some instance. However, we can prove that if these are repeated three times, we obtain the correct solutions.
>
> It would be emphasized that these fixes (repeating incorrect algorithms three
times) have the same time complexity as the correct Floyd–Warshall algorithm
up to constant factors. Therefore, our results suggest that, if one is confused by
the order of the triply nested loops, one can repeat the procedure three times
just to be safe.

</Optional>

### Problems

<Problems problems={metadata.problems.apsp} />

(more?)