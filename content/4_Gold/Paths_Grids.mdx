---
id: paths-grids
title: 'Paths on Grids'
author: Nathan Chen, Michael Cao, Benjamin Qi
prerequisites:
 - intro-dp
description: 'Counting the number of "special" paths on a grid, and how string problems can be solved with grids'
frequency: 2
---

export const problems = {
	sam: [
		new Problem(
			'CSES',
			'Grid Paths',
			'1638',
			'Easy',
			true,
			[],
			''
		)
	],
	pathSam: [
		new Problem(
			'LC',
			'Longest Common Subsequence',
			'https://leetcode.com/problems/longest-common-subsequence/',
			'Easy',
			true,
			['DP'],
			'dp[first i characters in first string][first j characters in second string] -> longest common subsequence, transition if s[i] = t[j] for strings s and t'
		),
	],
	pathsGrid: [
		new Problem(
			'AC',
			'Count Paths',
			'https://atcoder.jp/contests/dp/tasks/dp_h',
			'Easy',
			true,
			['DP'],
			'dp[x][y] = number of paths up to the point (x,y) in grid'
		),
		new Problem(
			'CSES',
			'Array Description',
			'1746',
			'Easy',
			false,
			[],
			''
		),
		new Problem(
			'CSES',
			'Edit Distance',
			'1639',
			'Easy',
			true,
			[],
			'@CPH 7.5'
		),
		new Problem(
			'Gold',
			'Cow Checklist',
			'670',
			'Easy',
			false,
			['DP'],
			'dp[visited i Hs][visited j Gs][last cow visited on left/right] -> min energy'
		),
		new Problem(
			'Gold',
			'Radio Contact',
			'598',
			'Easy',
			false,
			['DP'],
			'dp[up to ith step of Farmer John][up to jth step of bessie] = minimum distance'
		),
		new Problem(
			'Gold',
			'Why Did the Cow Cross the Road II',
			'718',
			'Normal',
			false,
			['DP'],
			'dp[up to ith field on left side][up to jth field on right side] = maximum number of disjoint crosswalks'
		),
		new Problem(
			'Old Gold',
			'Palindromic Paths',
			'553',
			'Hard',
			false,
			['DP'],
			'start from the middle, dp[row i][row j][length] = number of strings of length 2 * length + 1 with ends at row i and j'
		),
	],
};

<!-- 		new Problem(
			'HR',
			'Edit Distance',
			'contests/cse-830-homework-3/challenges/edit-distance',
			'Easy',
			true,
			['DP'],
			'dp[first i characters in first string][first j characters in second string] -> edit distance'
		),
 -->

<!-- ### Paths in a Grid (and related) -->

<!-- Interesting applications of "number of paths on a grid," some of which don't directly present a grid in the problem, but can be modelled as one. --> <!-- Asterisk> Such as Longest Common Subsequence. </Asterisk> -->

## Tutorial

<Resources>
	<Resource source="CPH" title="7.3 - Paths in a Grid" starred></Resource>
</Resources>

A common archetype of DP Problems involves a 2D grid of square cells (like graph paper), and we have to analyze "**paths**." A path is a sequence of cells whose movement is restricted to one direction on the x-axis and one direction on the y-axis (for example, you may only be able to move down or to the right). Usually, the path also has to start in one corner of the grid and end on another corner. The problem may ask you to count the number of paths that satisfy some property, or it may ask you to find the max/min of some quantity over all paths.

Usually, the sub-problems in this type of DP are a sub-rectangle of the whole grid. For example, consider a problem in which we count the number of paths from $(1, 1)$ to $(N, M)$ when we can only move in the positive x direction and the positive y direction. 

Let $dp(x, y)$ be the number of paths that go corner-to-corner in the sub-rectangle whose corners are $(1, 1)$ and $(x, y)$. We know that the first cell in a path counted by $dp(x, y)$ is $(1, 1)$, and we know the last cell is $(x, y)$. However, the second-to-last cell can either be $(x-1, y)$ or $(x, y-1)$. Thus, if we pretend to append the cell $(x, y)$ to the paths that end on $(x-1, y)$ or $(x, y-1)$, we can construct paths that end on $(x, y)$. Working backwards like that motivates the following recurrence: $dp(x, y) = dp(x-1, y) + dp(x, y-1)$. We can use this recurrence to calculate $dp(N, M)$. Keep in mind that $dp(1, 1) = 1$ because the path to $(1, 1)$ is just a single cell. In general, thinking about how you can append cells to paths will help you construct the correct DP recurrence.

When using the DP recurrence, it's important that you compute the DP values in an order such that the dp-value for a cell is known before you use it to compute the dp-value for another cell. In the example problem above, it's fine to iterate through each row from bottom to top:

<LanguageSection>

<CPPSection>

```cpp

for(int i = 0; i < M; i++) {
	for(int j = 0; j < N; j++) {
		if(j > 0) dp[j][i] += dp[j-1][i];
		if(i > 0) dp[j][i] += dp[j][i-1];
	}
}

```

</CPPSection>

<JavaSection>

```java

for(int i = 0; i < M; i++) {
	for(int j = 0; j < N; j++) {
		if(j > 0) dp[j][i] += dp[j-1][i];
		if(i > 0) dp[j][i] += dp[j][i-1];
	}
}

```

</JavaSection>

</LanguageSection>

Note how the coordinates in the code are in the form (x coordinate, y coordinate). Most of the time, it's more convenient to think of points as (row, column) instead, which swaps the order of the coordinates, though the code uses the former format to be consistent with the definition of $dp(x, y)$.

## Solution - Paths on a Grid

<FocusProblem problem={problems.sam[0]} />

In this problem, we are directly given a 2D grid of cells, and we have to count the number of paths from corner to corner that can only go down (positive $y$ direction) and to the right (positive $x$ direction), with a special catch. The path can't use a cell marked with an asterik.

We come close to being able to use our original recurrence, but we have to modify it. Basically, if a cell $(x, y)$ is normal, we can use the recurrence normally. But, if cell $(x, y)$ has an asterik, the dp-value is $0$.

$$
  dp(x, y) =
\begin{cases}
dp(x-1, y) + dp(x, y-1) & \text{if $(x, y)$ is not a trap} \\
0, & \text{if $(x, y)$ is a trap}
\end{cases}
$$

Our code doesn't change much:

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
 
using namespace std;

typedef long long ll;

bool ok[1000][1000];
ll dp[1000][1000];
 
int main() {
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);

	int n; cin >> n;
	for(int i = 0; i < n; i++) {
		string s;
		cin >> s;
		for(int j = 0; j < n; j++) {
			if(s[j] == '.') ok[i][j] = true;
			else ok[i][j] = false;
		}
	}

	dp[0][0] = 1;
	for(int i = 0; i < n; i++) {
		for(int j = 0; j < n; j++) {
			if(!ok[i][j]) dp[i][j] = 0;
			else {
				if(i > 0) dp[i][j] += dp[i-1][j];
				if(j > 0) dp[i][j] += dp[i][j-1];
				dp[i][j] %= 1000000007;
			}
		}
	}

	cout << dp[n-1][n-1] << "\n";

	return 0;
}
```

</CPPSection>

<JavaSection>

```java

import java.util.*;
import java.io.*;

public class Main {

	public static void main(String[] args) throws Exception {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

		int N = Integer.parseInt(br.readLine());
		long dp[][] = new long[N][N];
		boolean ok[][] = new boolean[N][N];
		for(int i = 0; i < N; i++) {
			String s = br.readLine();
			for(int j = 0; j < N; j++) {
				if(s.charAt(j) == '.') ok[i][j] = true;
				else ok[i][j] = false;
			}
		}

		dp[0][0] = 1;
		for(int i = 0; i < N; i++) {
			for(int j = 0; j < N; j++) {
				if(!ok[i][j]) dp[i][j] = 0;
				else {
					if(i > 0) dp[i][j] += dp[i-1][j];
					if(j > 0) dp[i][j] += dp[i][j-1];
					dp[i][j] %= 1000000007;
				}
			}
		}

		System.out.println(dp[N-1][N-1]);
	}

}

```

</JavaSection>

</LanguageSection>

Note how the coordinates are now in the form (row, column) when reading in the input.

## Solution - Longest Common Subsequence

<FocusProblem problem={problems.pathSam[0]} />

The longest common subsequence is a classical string problem, but where's the grid? We can create a grid to solve it. 

|   | x | a | b | c | d |
|---|---|---|---|---|---|
| y | **0** | 0 | 0 | 0 | 0 |
| a | 0 | **1** | 1 | 1 | 1 |
| z | 0 | **1** | 1 | 1 | 1 |
| c | 0 | 1 | 1 | **2** | **2** |

<IncompleteSection />

## Problems

<Problems problems={problems.pathsGrid} />
