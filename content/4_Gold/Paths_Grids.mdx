---
id: paths-grids
title: 'Paths on Grids'
author: Nathan Chen, Michael Cao, Benjamin Qi
prerequisites:
 - intro-dp
description: 'Counting the number of "special" paths on a grid, and how string problems can be solved with grids'
frequency: 2
---

export const problems = {
	sam: [
		new Problem(
			'CSES',
			'Grid Paths',
			'1638',
			'Easy',
			true,
			[],
			''
		)
	],
	pathSam: [
		new Problem(
			'LC',
			'Longest Common Subsequence',
			'https://leetcode.com/problems/longest-common-subsequence/',
			'Easy',
			true,
			['DP'],
			'dp[first i characters in first string][first j characters in second string] -> longest common subsequence, transition if s[i] = t[j] for strings s and t'
		),
	],
	pathsGrid: [
		new Problem(
			'AC',
			'Count Paths',
			'https://atcoder.jp/contests/dp/tasks/dp_h',
			'Easy',
			true,
			['DP'],
			'dp[x][y] = number of paths up to the point (x,y) in grid'
		),
		new Problem(
			'CSES',
			'Array Description',
			'1746',
			'Easy',
			false,
			[],
			''
		),
		new Problem(
			'CSES',
			'Edit Distance',
			'1639',
			'Easy',
			true,
			[],
			'@CPH 7.5'
		),
		new Problem(
			'Gold',
			'Cow Checklist',
			'670',
			'Easy',
			false,
			['DP'],
			'dp[visited i Hs][visited j Gs][last cow visited on left/right] -> min energy'
		),
		new Problem(
			'Gold',
			'Radio Contact',
			'598',
			'Easy',
			false,
			['DP'],
			'dp[up to ith step of Farmer John][up to jth step of bessie] = minimum distance'
		),
		new Problem(
			'Gold',
			'Why Did the Cow Cross the Road II',
			'718',
			'Normal',
			false,
			['DP'],
			'dp[up to ith field on left side][up to jth field on right side] = maximum number of disjoint crosswalks'
		),
		new Problem(
			'Old Gold',
			'Palindromic Paths',
			'553',
			'Hard',
			false,
			['DP'],
			'start from the middle, dp[row i][row j][length] = number of strings of length 2 * length + 1 with ends at row i and j'
		),
	],
};

<!-- 		new Problem(
			'HR',
			'Edit Distance',
			'contests/cse-830-homework-3/challenges/edit-distance',
			'Easy',
			true,
			['DP'],
			'dp[first i characters in first string][first j characters in second string] -> edit distance'
		),
 -->

<!-- ### Paths in a Grid (and related) -->

<!-- Interesting applications of "number of paths on a grid," some of which don't directly present a grid in the problem, but can be modelled as one. --> <!-- Asterisk> Such as Longest Common Subsequence. </Asterisk> -->

<FocusProblem problem={problems.sam[0]} />

<FocusProblem problem={problems.pathSam[0]} />

## Tutorial

<Resources>
	<Resource source="CPH" title="7.3 - Paths in a Grid" starred></Resource>
</Resources>

A common archetype of DP Problems involves a 2D grid of square cells (like graph paper), and we have to analyze "paths." A path is a sequence of cells whose movement is restricted to one direction on the x-axis and one direction on the y-axis (for example, you may only be able to move down or to the right). Usually, the path also has to start in one corner of the grid and end on another corner. The problem may ask you to count the number of paths that satisfy some property, or it may ask you to find the max/min of some quantity over all paths.

Usually, the sub-problems in this type of DP are a sub-rectangle of the whole grid. For example, consider a problem in which we count the number of paths from $(1, 1)$ to $(N, M)$ when we can only move in the positive x direction (right) and the positive y direction (up). 

Let $dp(x, y)$ be the number of paths in the sub-rectangle whose corners are $(1, 1)$ and $(x, y)$. We know that the first cell in a path counted by $dp(x, y)$ is $(1, 1)$, and we know the last cell is $(x, y)$. However, the second-to-last cell can either be $(x-1, y)$ or $(x, y-1)$. Thus, if we pretend to append the cell $(x, y)$ to the paths that end on $(x-1, y)$ or $(x, y-1)$, we can construct paths that end on $(x, y)$. This counting idea motivates the following recurrence: $dp(x, y) = dp(x-1, y) + dp(x, y-1)$. We can use this recurrence to calculate $dp(N, M)$.

When using the DP recurrence, it's important that you compute the DP values in an order such that the dp-value for a cell is known before you use it to compute the dp-value for another cell. In the example problem above, it's fine to iterate through each row from bottom to top:

<LanguageSection>

<CPPSection>

```cpp

for(int i = 0; i < M; i++) {
	for(int j = 0; j < N; j++) {
		if(j > 0) dp[j][i] += dp[j-1][i];
		if(i > 0) dp[j][i] += dp[j][i-1];
	}
}

```

</CPPSection>

<JavaSection>

```java

for(int i = 0; i < M; i++) {
	for(int j = 0; j < N; j++) {
		if(j > 0) dp[j][i] += dp[j-1][i];
		if(i > 0) dp[j][i] += dp[j][i-1];
	}
}

```

</JavaSection>

</LanguageSection>

Note how the coordinates in the code are in the form $\[x_{coordinate}\]\[y_{coordinate}\]$. Most of the time, it's more convenient to think of points as $\[row\]\[column\]$ instead, which basically swaps the order of the coordinates, though the code uses the former format to be consistent with the definition of $dp(x, y)$.

In general, thinking about how you can append cells to paths will help you construct the correct DP recurrence.

## Solution - Paths on a Grid

In this problem, we are directly given a 2D grid of cells, and we have to count the number of paths from corner to corner that can only go down and to the right, with a special catch. The path can't use a cell marked with an asterik.

We come close to being able to use our original recurrence, but we have to modify it. Basically, if a cell $(x, y)$ is normal, we can use the recurrence normally. But, if cell $(x, y)$ has an asterik, the dp-value is $0$.

$dp(x, y)$ =
\begin{cases}
dp(x-1, y) + dp(x, y-1),  & \text{if $(x, y)$ is not a bomb} \\
0, & \text{if $(x, y)$ is a bomb}
\end{cases}

<IncompleteSection />

## Solution - Longest Common Subsequence

The longest common subsequence is a classical string problem which has no grid, but we can analyze it with a grid to solve it. 

Imagine one axis has the letters of the first string written along it, and the other axis has the letters of the second string written along it. A common subsequence can be modeled as a path ... (to be added)

<IncompleteSection />

## Problems

<Problems problems={problems.pathsGrid} />
