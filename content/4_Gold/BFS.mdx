---
id: bfs
title: 'Breadth First Search (BFS)'
author: Benjamin Qi, Michael Cao
prerequisites:
  - dfs
description: 'Traversing a graph in a way such that vertices closer to the starting vertex are processed first.'
frequency: 2
---

import { Problem } from '../models';

export const problems = {
	sample: [
		new Problem('CSES', 'Message Route', '1667', 'Easy', false, ['BFS']),
	],
	general: [
		new Problem(
			'Silver',
			'Milk Pails',
			'620',
			'Very Easy',
			false,
			['BFS'],
			'There is an easier solution in XYK time, but you can use BFS to solve it in XY time.'
		),
		new Problem('CSES', 'Monsters', '1194', 'Easy', false, ['BFS']),
		new Problem('CSES', 'Graph Girth', '1707', 'Normal', false, ['Cycle']),
		new Problem('CSA', 'BFS-DFS', 'bfs-dfs', 'Normal', false, ['BFS', 'DFS']),
		new Problem('Gold', 'Cow Navigation', '695', 'Normal', false, ['BFS'], 'usaco-695'),
		new Problem('Gold', 'Lasers', '671', 'Normal', false, ['BFS']),
		new Problem('Gold', 'Dream', '575', 'Hard', false, ['BFS']),
		new Problem('Gold', 'A Pie for a Pie', '765', 'Very Hard', false, [], ''),
	],
};

<Problems problems={problems.sample} />

## Resources

<Resources>
	<Resource
		source="CSA"
		title="Breadth First Search"
		url="breadth_first_search"
		starred
	>
		interactive
	</Resource>
	<Resource source="CPH" title="12.2 - Breadth-First Search"></Resource>
	<Resource source="PAPS" title="12.1 - Breadth-First Search"></Resource>
	<Resource
		source="KA@KhanAcademy"
		title="Breadth First Search and Its Uses"
		url="https://www.khanacademy.org/computing/computer-science/algorithms/breadth-first-search/a/breadth-first-search-and-its-uses"
	></Resource>
	<Resource
		source="cp-algo"
		title="Breadth First Search"
		url="graph/breadth-first-search.html"
	></Resource>
	<Resource source="cp-algo" title="0/1 BFS" url="graph/01_bfs.html"></Resource>
	<Resource
		source="IUSACO"
		title="10.4 - Graph Traversal Algorithms"
	></Resource>
	<Resource source="CP2" title="4.2.2 - BFS">
		{' '}
	</Resource>
</Resources>

<IncompleteSection>

remove some if they're not useful

</IncompleteSection>

## Implementation

<LanguageSection>

<CPPSection>

From the CSA article:

```cpp
#include <algorithm>
#include <fstream>
#include <iostream>
#include <queue>
using namespace std;
const int MAX_N = 100005;

vector<int> graph[MAX_N];
int dist[MAX_N];
bool visited[MAX_N];

void bfs(int startNode) {
    dist[startNode] = 0;
    queue<int> bfsQueue;
    bfsQueue.push(startNode);
    visited[startNode] = true;
    while (!bfsQueue.empty()) {
        int currentNode = bfsQueue.front();
        bfsQueue.pop();
        for (auto neighbour: graph[currentNode]) {
            if (!visited[neighbour]) {
                visited[neighbour] = true;
                dist[neighbour] = dist[currentNode] + 1;
                bfsQueue.push(neighbour);
            }
        }
    }
}

int main() {
    int N, M, v, x, y;
    cin >> N >> M >> v;
    for (int i = 1; i <= M; i += 1) {
        cin >> x >> y;
        graph[x].push_back(y);
    }
    for (int i = 1; i <= N; i += 1) {
        dist[i] = -1;
    }
    bfs(v);
    for (int i = 1; i <= N; i += 1) {
        cout << dist[i] << " ";
    }
    return 0;
}
```

</CPPSection>

<JavaSection>
 
Implementation of the CSAcademy article's problem in Java:

```java
import java.util.*;
import java.io.*;

class Main {

    static ArrayList<Integer> edges[];
    static int dist[];
    static boolean visited[];

    static void bfs(int startNode) {
        Queue<Integer> q = new ArrayDeque<Integer>(); //You can choose any implementation of Queue (such as LinkedList), though I believe ArrayDeque is faster (?)

        q.add(startNode);
        visited[startNode] = true;
        dist[startNode] = 0;

        while(!q.isEmpty()) {
            int currentNode = q.poll();

            for(int adj : edges[currentNode]) {
                if(!visited[adj]) {
                    visited[adj] = true;
                    dist[adj] = dist[currentNode]+1;
                    q.add(adj);
                }
            }
        }
    }

    public static void main (String[] args) throws Exception {
	BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); //Read about fast Java input in "General - Fast I/O"

	StringTokenizer st = new StringTokenizer(br.readLine());
	int N = Integer.parseInt(st.nextToken());
	int M = Integer.parseInt(st.nextToken());

	int start = Integer.parseInt(st.nextToken());
	start--;

	edges = new ArrayList[N];
	dist = new int[N];
	visited = new boolean[N];
	for(int i = 0; i < N; i++) {
	    edges[i] = new ArrayList<Integer>();
	    dist[i] = -1;
	}

	for(int i = 0; i < M; i++) {
	    st = new StringTokenizer(br.readLine());
	    int a = Integer.parseInt(st.nextToken());
	    int b = Integer.parseInt(st.nextToken());

	    a--; b--;
	    edges[a].add(b);
	}

	bfs(start);

	PrintWriter pw = new PrintWriter(System.out);

	for(int i : dist) pw.print(i + " ");
	    pw.println();
	    pw.close();
	}
}
```

</JavaSection>

</LanguageSection>

<Warning>

In the gold division, the problem statement will almost never directly be, "Given an unweighted graph, find the shortest path between node $u$ and $v$." Instead, the difficulty in many BFS problems are converting the problem into a graph on which we can run BFS and get the answer.

</Warning>

## Problems

<Problems problems={problems.general} />
