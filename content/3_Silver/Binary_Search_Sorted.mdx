---
id: binary-search-sorted
title: 'Binary Search on a Sorted Array'
author: Siyong Huang, Michael Cao, Nathan Chen
description: 'Quickly finding elements in a sorted array.'
prerequisites:
  - intro-ds
frequency: 2
---

import { Problem } from '../models';

export const problems = {
	bubble: [
		new Problem(
			'HR',
			'Bubble Sort',
			'https://www.hackerrank.com/challenges/ctci-bubble-sort/problem',
			'Easy',
			false,
			[],
			'O(N^2)'
		),
		new Problem('Silver', 'Out of Sorts', '834', 'Very Hard', false, []),
	],
	count: [
		new Problem('Silver', 'Counting Haybales', '666', 'Normal', false, []),
	],
};

Suppose that we want to find an element in a sorted array of size $N$ in $O(\log N)$ time. We can do this with [**binary search**](https://en.wikipedia.org/wiki/Binary_search_algorithm); each iteration of the binary search cuts the search space in half, so the algorithm tests $O(\log N)$ values. This is efficient and much better than testing every element in an array.

<Resources>
	<Resource
		source="KA"
		title="Binary Search"
		url="https://www.khanacademy.org/computing/computer-science/algorithms/binary-search/a/binary-search"
		starred
	>
		animations!
	</Resource>
	<Resource source="CSA" title="Binary Search" url="binary_search" starred>
		animation!
	</Resource>
	<Resource source="CPH" title="3.3 - Binary Search" starred></Resource>
	<Resource source="TC" title="Binary Search" url="binary-search"></Resource>
	<Resource source="GFG" title="Binary Search" url="binary-search"></Resource>
</Resources>

## Library Functions

<LanguageSection>

<CPPSection>

<Resources>
	<Resource
		source="CPP"
		url="http://www.cplusplus.com/reference/algorithm/lower_bound/"
		title="lower_bound"
	>
		{' '}
	</Resource>
	<Resource
		source="CPP"
		url="http://www.cplusplus.com/reference/algorithm/upper_bound/"
		title="upper_bound"
	>
		{' '}
	</Resource>
</Resources>

</CPPSection>

<JavaSection>

<Resources>
	<Resource
		source="JAVA"
		url="https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html#binarySearch(int[],%20int)"
		title="Arrays.binarySearch"
	>
		{' '}
	</Resource>
	<Resource
		source="JAVA"
		url="https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html#binarySearch(java.util.List,%20T)"
		title="Collections.binarySearch"
	>
		{' '}
	</Resource>
</Resources>

</JavaSection>

</LanguageSection>

## Coordinate Compression

A related topic is **coordinate compression**, which takes some points and reassigns them to remove wasted space.

<Problems problems={problems.count} />

> Farmer John has just arranged his $N$ haybales $(1\le N \le 100,000)$ at various points along the one-dimensional road running across his farm. To make sure they are spaced out appropriately, please help him answer $Q$ queries ($1 \le Q \le 100,000$), each asking for the number of haybales within a specific interval along the road.

However, each of the points are in the range $0 \ldots 1,000,000,000$, meaning you can't store locations of haybales in, for instance, a boolean array.

Let's place all of the locations of the haybales into a list and sort it. Now, let's map each integer to an integer in the range $1 \ldots N$. To do this, we can place the locations of haybales into a set along with the queries.

Then, for a query $(q_l, q_r)$, we can set $q_l$ to the closest haybale $x$ such that $x \geq q_l$, and $q_r$ to the closest haybale such that $x \leq q_r$, since this won't affect the answers to the queries.

Now we have a set of at most $N$ distinct integers, so we can iterate through with a counter and increment every time you map a position to the counter.

<Spoiler title="Example Code">

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;
using ll = long long;
using vi = vector<int>;
#define pb push_back
#define rsz resize
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()
using pi = pair<int,int>;
#define f first
#define s second
#define mp make_pair
void setIO(string name = "") { // name is nonempty for USACO file I/O
    ios_base::sync_with_stdio(0); cin.tie(0); // see Fast Input & Output
    if(sz(name)){
        freopen((name+".in").c_str(), "r", stdin); // see Input & Output
        freopen((name+".out").c_str(), "w", stdout);
    }
}

const int maxn = 100005;

set<int> pos; map<int, int> compress; int psums[maxn];

int main() {
    setIO("haybales");
    int n, q; cin >> n >> q;
    vector<int> vals;
    for (int i = 0; i < n; i++) {
        int x; cin >> x;
        vals.pb(x);
        pos.insert(x);
    }
    int cnt = 0;
    for(int x : pos){
        compress[x] = cnt++;
    }
    for(int x : vals){
        psums[compress[x]]++;
    }
    for(int i = 1; i < n; i++){
        psums[i] += psums[i - 1];
    }
    for(int i = 0; i < q; i++){
        int ql, qr; cin >> ql >> qr;
        auto it1 = pos.lower_bound(ql);
        auto it2 = pos.upper_bound(qr);
        if(it1 == pos.end() || it2 == pos.begin()){
            cout << 0 << '\n';
        }
        else{
            ql = *it1;
            qr = *(--it2);
            ql = compress[ql], qr = compress[qr];
            cout << psums[qr] - psums[ql - 1] << '\n';
        }
    }
}
```

</CPPSection>

</LanguageSection>

</Spoiler>
