---
id: intro-ordered
title: 'More Operations on Ordered Sets'
author: Darren Yao, Benjamin Qi
prerequisites:
  - intro-sets
description: 'Using iterators with sets, finding the next element smaller or larger than a specified key in a set.'
frequency: 2
---

import { Problem } from '../models';

export const problems = {
	standard: [
		new Problem(
			'CSES',
			'Concert Tickets',
			'1091',
			'Easy',
			false,
			['iterators'],
			'just do upper_bound'
		),
		new Problem(
			'CSES',
			'Traffic Lights',
			'1163',
			'Normal',
			false,
			['set'],
			'just insert into set one at a time'
		),
	],
	sample: [new Problem('CSES', 'Bit Inversions', '1188', 'Normal', false, [])],
	general: [
		new Problem('Silver', 'Milk Measurement', '763', 'Normal', false, []),
		new Problem('Silver', 'Convention II', '859', 'Normal', false, []),
		new Problem('Gold', 'Snow Boots', '813', 'Normal', false, []),
		new Problem(
			'CF',
			'Jury Marks',
			'contest/831/problem/C',
			'Hard',
			false,
			[],
			'Hard, would recommend skipping (1700 on CF)'
		),
		new Problem(
			'CF',
			'Mahmoud & Ehab & Function',
			'contest/862/problem/E',
			'Hard',
			false,
			[],
			'Hard, do not attempt until Gold/Plat (2100 on CF)'
		),
		new Problem(
			'CF',
			'Tournament',
			'contest/878/problem/C',
			'Very Hard',
			false,
			[],
			'First solve problem for $n$-th tournament only. Extremely hard, do not attempt (2700 on CF)'
		),
	],
};

<Resources>
	<Resource source="IUSACO" title="4.3 - Sets & Maps">
		module is based off this
	</Resource>
	<Resource source="CPH" title="4.4 - Iterators & Ranges" starred>
		set iterators
	</Resource>
</Resources>

<br />

In ordered sets and maps, accessing or removing the next key higher or lower than some input `k` is also supported.

## Using Iterators

<LanguageSection>

<CPPSection>

next(), prev(), ++, --

</CPPSection>

</LanguageSection>

<IncompleteSection />

## Ordered Sets

<LanguageSection>

<CPPSection>

The ordered `set` also allows:

- `lower_bound`: returns an iterator to the least element greater than or equal to some element `k`
- `upper_bound`: returns an iterator to the least element strictly greater than some element `k`.

```cpp
set<int> s;
s.insert(1); // [1]
s.insert(14); // [1, 14]
s.insert(9); // [1, 9, 14]
s.insert(2); // [1, 2, 9, 14]
cout << *s.upper_bound(7) << '\n'; // 9
cout << *s.upper_bound(9) << '\n'; // 14
cout << *s.lower_bound(5) << '\n'; // 9
cout << *s.lower_bound(9) << '\n'; // 9
cout << *s.begin() << '\n'; // 1
auto it = s.end();
cout << *(--it) << '\n'; // 14
s.erase(s.upper_bound(6)); // [1, 2, 14]
```

</CPPSection>

<JavaSection>

The ordered set also allows four additional operations: `first`, which returns the lowest element in the set, `last`, which returns the highest element in the set, `lower`, which returns the greatest element strictly less than some element, and `higher`, which returns the least element strictly greater than it.

```java
TreeSet<Integer> set = new TreeSet<Integer>();
set.add(1); // [1]
set.add(14); // [1, 14]
set.add(9); // [1, 9, 14]
set.add(2); // [1, 2, 9, 14]
System.out.println(set.higher(7)); // 9
System.out.println(set.higher(9)); // 14
System.out.println(set.lower(5)); // 2
System.out.println(set.first()); // 1
System.out.println(set.last()); // 14
set.remove(set.higher(6)); // [1, 2, 14]
System.out.println(set.higher(23); // ERROR, no such element exists
```

</JavaSection>

</LanguageSection>

One limitation of the ordered set is that we can't efficiently access the $k^{th}$ largest element in the set, or find the number of elements in the set greater than some arbitrary $x$. These operations can be handled using a data structure called an [order statistic tree](../gold/PURS#order-statistic-tree).

## Ordered Maps

<LanguageSection>

<CPPSection>

The ordered `map` also allows:

- `lower_bound`: returns the iterator pointing to the lowest entry not less than the specified key
- `upper_bound`: returns the iterator pointing to the lowest entry strictly greater than the specified key respectively.

```cpp
map<int, int> m;
m[3] = 5; // [(3, 5)]
m[11] = 4; // [(3, 5); (11, 4)]
m[10] = 491; // [(3, 5); (10, 491); (11, 4)]
cout << m.lower_bound(10)->first << " " << m.lower_bound(10)->second << '\n'; // 10 491
cout << m.upper_bound(10)->first << " " << m.upper_bound(10)->second << '\n'; // 11 4
m.erase(11); // [(3, 5); (10, 491)]
if (m.upper_bound(10) == m.end())
{
    cout << "end" << endl; // Prints end
}
```

</CPPSection>

<JavaSection>

The ordered map additionally supports `firstKey` / `firstEntry` and `lastKey` / `lastEntry`, returning the lowest key/entry and the highest key/entry, as well as `higherKey` / `higherEntry` and `lowerKey` / `lowerEntry`, returning the lowest key/entry strictly higher than the specified key, or the highest key/entry strictly lower than the specified key.

```java
TreeMap<Integer, Integer> map = new TreeMap<Integer, Integer>();
map.put(3, 5); // [(3, 5)]
map.put(11, 4); // [(3, 5); (11, 4)]
map.put(10, 491); // [(3, 5); (10, 491); (11, 4)]
System.out.println(map.firstKey()); // 3
System.out.println(map.firstEntry()); // (3, 5)
System.out.println(map.lastEntry()); // (11, 4)
System.out.println(map.higherEntry(4)); // (10, 491)
map.remove(11); // [(3, 5); (10, 491)]
System.out.println(map.lowerKey(4)); // 3
System.out.println(map.lowerKey(3)); // ERROR
```

</JavaSection>

</LanguageSection>

## Multisets

A **multiset** is a sorted set that allows multiple copies of the same element.

<LanguageSection>

<CPPSection>

In addition to all of the regular set operations,

- the `count()` method returns the number of times an element is present in the multiset. However, this method takes time **linear** in the number of matches so you shouldn't use it in a contest.
- If you want to remove a value _once_, make sure to use `multiset.erase(multiset.find(val))` rather than `multiset.erase(val)`. The latter will remove _all_ instances of `val`.

```cpp
multiset<int> ms;
ms.insert(1); // [1]
ms.insert(14); // [1, 14]
ms.insert(9); // [1, 9, 14]
ms.insert(2); // [1, 2, 9, 14]
ms.insert(9); // [1, 2, 9, 9, 14]
ms.insert(9); // [1, 2, 9, 9, 9, 14]
cout << ms.count(4) << '\n'; // 0
cout << ms.count(9) << '\n'; // 3
cout << ms.count(14) << '\n'; // 1
ms.erase(ms.find(9));
cout << ms.count(9) << '\n'; // 2
ms.erase(9);
cout << ms.count(9) << '\n'; // 0
```

</CPPSection>

<JavaSection>

While there is no multiset in Java, we can implement one using the `TreeMap` from values to their respective frequencies. We declare the `TreeMap` implementation globally so that we can write functions for adding and removing elements from it. The `first`, `last`, `higher`, and `lower` operations still function as intended; just use `firstKey`, `lastKey`, `higherKey`, and `lowerKey` respectively.

```java
static TreeMap<Integer, Integer> multiset = new TreeMap<Integer, Integer>();

public static void main(String[] args){
    ...
}

static void add(int x){
    if(multiset.containsKey(x)){
        multiset.put(x, multiset.get(x) + 1);
    } else {
        multiset.put(x, 1);
    }
}

static void remove(int x){
    multiset.put(x, multiset.get(x) - 1);
    if(multiset.get(x) == 0){
        multiset.remove(x);
    }
}
```

</JavaSection>

</LanguageSection>

## Priority Queues

A **priority queue** supports the following operations: insertion of elements, deletion of the element considered highest priority, and retrieval of the highest priority element, all in $O(\log N)$ time according to the number of elements in the priority queue.

Of course, all of these functions are supported by multisets, but priority queues are simpler and faster.

<LanguageSection>

<CPPSection>

### [C++](http://www.cplusplus.com/reference/queue/priority_queue/)

```cpp
priority_queue<int> pq;
pq.push(7); // [7]
pq.push(2); // [2, 7]
pq.push(1); // [1, 2, 7]
pq.push(5); // [1, 2, 5, 7]
cout << pq.top() << endl; // 7
pq.pop(); // [1, 2, 5]
pq.pop(); // [1, 2]
pq.push(6); // [1, 2, 6]
```

</CPPSection>

<JavaSection>

### Java

In Java, we delete and retrieve the element of **lowest** rather than highest priority.

```java
PriorityQueue<Integer> pq = new PriorityQueue<Integer>();
pq.add(7); // [7]
pq.add(2); // [7, 2]
pq.add(1); // [7, 2, 1]
pq.add(5); // [7, 5, 2, 1]
System.out.println(pq.peek()); // 1
pq.poll(); // [7, 5, 2]
pq.poll(); // [7, 5]
pq.add(6); // [7, 6, 5]
```

</JavaSection>

</LanguageSection>

## Introductory Problems

<Problems problems={problems.standard} />

## Harder Example: Bit Inversions

<Problems problems={problems.sample} />

### Solution

<Spoiler title="Solution">

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
using namespace std;

#define sz(x) (x).size()

string s;
int m;
multiset<int> ans, ret;

void modify(int x) {
  if (x == 0 || x == sz(s)) return;
  auto it = ans.find(x);
  if (it != end(ans)) {
    int a = *prev(it), b = *next(it);
    ret.erase(ret.find(x-a)), ret.erase(ret.find(b-x));
    ret.insert(b-a);
    ans.erase(it);
  } else {
    it = ans.insert(x);
    int a = *prev(it), b = *next(it);
    ret.erase(ret.find(b-a));
    ret.insert(x-a), ret.insert(b-x);
  }
}

int main() {
  ios_base::sync_with_stdio(0); cin.tie(0);
  cin >> s >> m;
  ans.insert(0); ans.insert(sz(s));
  for (int i = 0; i < sz(s)-1; ++i)
    if (s[i] != s[i+1]) ans.insert(i+1);
  for (auto it = ans.begin(); next(it) != ans.end(); it ++)
    ret.insert(*next(it)-*it);
  for (int i = 0; i < m; ++i) {
    int x; cin >> x;
    modify(x-1); modify(x);
    cout << *ret.rbegin() << " ";
  }
}
```

<br />

Note that `multiset` has a high constant factor, so replacing `ret` with an array and a `priority_queue` reduces the runtime by a factor of 2.

```cpp
#include <bits/stdc++.h>
using namespace std;

#define sz(x) (int)(x).size()

string s;
int m;
set<int> ans;
priority_queue<int> ret;
int cnt[200005];

void ad(int x) { cnt[x] ++; ret.push(x);  }
void modify(int x) {
  if (x == 0 || x == sz(s)) return;
  auto it = ans.find(x);
  if (it != end(ans)) {
    int a = *prev(it), b = *next(it); ans.erase(it);
    cnt[x-a] --, cnt[b-x] --; ad(b-a);
  } else {
    it = ans.insert(x).first;
    int a = *prev(it), b = *next(it);
    cnt[b-a] --, ad(x-a), ad(b-x);
  }
}

int main() {
  ios_base::sync_with_stdio(0); cin.tie(0);
  cin >> s >> m;
  ans.insert(0); ans.insert(sz(s));
  for (int i = 0; i < sz(s)-1; ++i)
    if (s[i] != s[i+1]) ans.insert(i+1);
  for (auto it = ans.begin(); next(it) != ans.end(); it ++)
    ad(*next(it)-*it);
  for (int i = 0; i < m; ++i) {
    int x; cin >> x;
    modify(x-1); modify(x);
    while (!cnt[ret.top()]) ret.pop();
    cout << ret.top() << " ";
  }
}
```

</CPPSection>

</LanguageSection>

</Spoiler>

## Harder Problems

<Problems problems={problems.general} />
