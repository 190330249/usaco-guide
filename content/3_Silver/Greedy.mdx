---
id: greedy
title: "Greedy Algorithms with Sorting"
author: Darren Yao
prerequisites: 
 - intro-greedy
 - sorting-custom
 - intro-ordered
description: "Continuation of greedy problems that were introduced in Bronze."
frequency: 3
---

import {Problem} from "../models"

export const metadata = {
  problems: {
    movie: [
      new Problem("CSES", "Movie Festival", "1629", "Easy", false, [], ""),
    ],
    cses: [
      new Problem("CSES", "Apartments", "1084", "Easy", false, [], "Sort applicants and apartments, then greedily assign applicants"),
      new Problem("CSES", "Ferris Wheel", "1090", "Easy", false, [], "Sort children, keep a left pointer and a right pointer. Each gondola either is one child from the right pointer or two children, one left and one right."),
      new Problem("CSES", "Towers", "1073", "Easy", false, ["multiset", "greedy"]),
      new Problem("CSES", "Room Allocation", "1164", "Normal", false, ["multiset", "greedy"], "similar to above"),
      new Problem("CSES", "Tasks & Deadlines", "1630", "Easy", false, [], ""),
      new Problem("CSES", "Movie Festival II", "1632", "Easy", false, [], ""),
      new Problem("CSES", "Stick Division", "1161", "Hard", false, [], ""),
    ],
    usaco: [
      new Problem("Silver", "Paired Up", "738", "Easy", false, ["2P", "Sorting"]),
      new Problem("Silver", "Lemonade Line", "835", "?", false, [], ""),
      new Problem("Silver", "Why ... (helpcross)", "714", "?", false, [], "first step: sort!"),
      new Problem("Silver", "Berry Picking", "990", "?", false, [], ""),
      new Problem("Silver", "Rest Stops", "810", "?", false, [], ""),
      new Problem("Silver", "High Card Wins", "571", "?", false, [], ""),
    ],
    other: [
      new Problem("CSA", "Sure Bet", "sure-bet", "?", false, [], ""),
      new Problem("CF", "Did you Mean...", "contest/860/problem/A", "?", false, [], ""),
      new Problem("CF", "Bus", "contest/864/problem/C", "?", false, [], ""),
      new Problem("CF", "Permutation", "contest/864/problem/D", "?", false, [], ""),
      new Problem("CF", "Kayaking", "contest/863/problem/B", "?", false, [], "Huffman Coding?"),
      new Problem("CF", "New Year and Three Musketeers", "contest/611/problem/E", "Hard", false, [], "needs maps"),
    ]
  }
};

<Resources>
  <Resource source="IUSACO" title="9 - Greedy Algorithms">Module is based off this.</Resource>
  <Resource source="CPH" title="6 - Greedy Algorithms" starred></Resource>
  <Resource source="PAPS" title="8 - Greedy Algorithms"></Resource>
  <Resource source="CPC" title="5 - Greedy Algorithms" url="05_greedy_algorithms"></Resource>
</Resources>

<br />

Usually, when using a greedy algorithm, there is a **heuristic** or **value function** that determines which choice is considered most optimal. 

(what's a heuristic or value function?)

<IncompleteSection />

Here, we'll focus on problems where some sorting step is involved.

## Example: The Scheduling Problem

<Problems problems={metadata.problems.movie} />

There are $N$ events, each described by their starting and ending times. You can only attend one event at a time, and if you choose to attend an event, you must attend the entire event. Traveling between events is instantaneous. What's the maximum number of events you can attend?

### Bad Greedy: Earliest Starting Next Event

One possible ordering for a greedy algorithm would always select the next possible event that begins as soon as possible. Let's look at the following example, where the selected events are highlighted in red:

<svg viewBox="0 0 200 40">
  <line x1="10" y1="5" x2="80" y2="5" style="stroke:rgb(255,0,0);stroke-width:1" />
  <line x1="40" y1="15" x2="120" y2="15" style="stroke:rgb(0,0,0);stroke-width:1" />
  <line x1="110" y1="25" x2="180" y2="25" style="stroke:rgb(255,0,0);stroke-width:1" />
  <line x1="150" y1="35" x2="180" y2="35" style="stroke:rgb(0,0,0);stroke-width:1" />
</svg>

In this example, the greedy algorithm selects two events, which is optimal. However, this doesn't always work, as shown by the following counterexample:

<svg viewBox="0 0 200 40">
  <line x1="10" y1="5" x2="160" y2="5" style="stroke:rgb(255,0,0);stroke-width:1" />
  <line x1="40" y1="15" x2="80" y2="15" style="stroke:rgb(0,0,0);stroke-width:1" />
  <line x1="100" y1="25" x2="135" y2="25" style="stroke:rgb(0,0,0);stroke-width:1" />
  <line x1="150" y1="35" x2="180" y2="35" style="stroke:rgb(0,0,0);stroke-width:1" />
</svg>

In this case, the greedy algorithm selects to attend only one event. However, the optimal solution would be the following:

<svg viewBox="0 0 200 40">
  <line x1="10" y1="5" x2="160" y2="5" style="stroke:rgb(0,0,0);stroke-width:1" />
  <line x1="40" y1="15" x2="80" y2="15" style="stroke:rgb(255,0,0);stroke-width:1" />
  <line x1="100" y1="25" x2="135" y2="25" style="stroke:rgb(255,0,0);stroke-width:1" />
  <line x1="150" y1="35" x2="180" y2="35" style="stroke:rgb(255,0,0);stroke-width:1" />
</svg>

### Correct Greedy: Earliest Ending Next Event

Instead, we can select the event that ends as early as possible. This correctly selects the three events.

<svg viewBox="0 0 200 40">
  <line x1="10" y1="5" x2="160" y2="5" style="stroke:rgb(0,0,0);stroke-width:1" />
  <line x1="40" y1="15" x2="80" y2="15" style="stroke:rgb(255,0,0);stroke-width:1" />
  <line x1="100" y1="25" x2="135" y2="25" style="stroke:rgb(255,0,0);stroke-width:1" />
  <line x1="150" y1="35" x2="180" y2="35" style="stroke:rgb(255,0,0);stroke-width:1" />
</svg>

In fact, this algorithm always works. A brief explanation of correctness is as follows. If we have two events $E_1$ and $E_2$, with $E_2$ ending later than $E_1$, then it is always optimal to select $E_1$. This is because selecting $E_1$ gives us more choices for future events. If we can select an event to go after $E_2$, then that event can also go after $E_1$, because $E_1$ ends first. Thus, the set of events that can go after $E_2$ is a subset of the events that can go after $E_1$, making $E_1$ the optimal choice.

For the following code, let's say we have the array `events` of events, which each contain a start and an end point. 

<LanguageSection>

<CPPSection>

We'll be using the C++ built in container pair to store each event. Note that since the standard sort in C++ sorts by first element, we will store each event as `pair<end, start>`. 

```cpp
// read in the input, store the events in pair<int, int>[] events.
sort(events, events + n); // sorts by first element (ending time)
int currentEventEnd = -1; // end of event currently attending
int ans = 0; // how many events were attended?
for(int i = 0; i < n; i++){ // process events in order of end time
	if(events[i].second >= currentEventEnd){ // if event can be attended
	// we know that this is the earliest ending event that we can attend
	// because of how the events are sorted
		currentEventEnd = events[i].first;
		ans++;
	}
}
cout << ans << endl;
```

</CPPSection>

<JavaSection>

We'll be using the following static class to store each event:

```java
static class Event implements Comparable<Event>{
	int start; int end;
	public Event(int s, int e){
		start = s; end = e;
	}
	public int compareTo(Event e){
		return Integer.compare(this.end, e.end);
	}
}
```


```java
// read in the input, store the events in Event[] events.
Arrays.sort(events); // sorts by comparator we defined above
int currentEventEnd = -1; // end of event currently attending
int ans = 0; // how many events were attended?
for(int i = 0; i < n; i++){ // process events in order of end time
	if(events[i].start >= currentEventEnd){ // if event can be attended
	// we know that this is the earliest ending event that we can attend
	// because of how the events are sorted
		currentEventEnd = events[i].end;
		ans++;
	}
}
pw.println(ans);
pw.close();
```

</JavaSection>

</LanguageSection>


## CSES Problems

<Problems problems={metadata.problems.cses} />

## USACO Problems

<Problems problems={metadata.problems.usaco} />

## Other Problems

<Problems problems={metadata.problems.other} />