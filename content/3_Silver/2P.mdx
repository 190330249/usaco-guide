---
id: 2P
title: 'Two Pointers'
author: Darren Yao, Qi Wang
prerequisites:
  - sorting-custom
description:
  'Iterating two monotonic pointers across an array to search for a pair of
  indices satisfying some condition in linear time.'
frequency: 2
---

<Problems problems="sample" />

## Resources

<Resources>
	<Resource source="CPH" title="8.1 - Two Pointers" starred>
		solutions to the problems above
	</Resource>
	<Resource source="IUSACO" title="14.1 - Two Pointers">
		above + mention of max subarray sum
	</Resource>
	<Resource
		source="CF"
		title="CF Edu"
		url="https://codeforces.com/edu/course/2/lesson/9"
		starred
	>
		video explanation of two pointers
	</Resource>
</Resources>

## Two Pointers

The two pointers method iterates two pointers across an array, to track the start and end
of an interval, or two values in a sorted array that we are currently checking. 
Typically, each pointer starts at seperate ends and moves strictly in one direction. 
However, as shown in the focus problem below, the two pointers do not have to start at seperate ends.


<FocusProblem problem="book" />

## Solution - Books

We want to find the longest continuous segment of books that can be read within $t$ minutes. 

To accomplish this, we can define $\texttt{left}$ and $\texttt{right}$ as the start and end of the segment respectively.

Since being able to read segment $\texttt{left} \dots \texttt{right}$ implies we can read segment $\texttt{left} \dots \texttt{right}-1$, we can use two-pointers (or, alternatively, [binary search](/silver/binary-search)).

For every $\texttt{left}$ index, we need to increase our $\texttt{right}$ pointer until the total time for that segment exceeds $t$.

We will keep track of the max segment size with $\texttt{ans}$, and take the maximum $\texttt{right} - \texttt{left}$ value.

We can then remove the $\texttt{left}$-indexed book from $\texttt{cur}$ and increment $\texttt{left}$ by 1.

**The $\texttt{right}$ pointer does not restart after an iteration, it simply keeps moving right.**

<Info title="Pro-tip">

You can visualize these pointers as maintaing a sliding window of books for this problem.

</Info>

### Implementation

<LanguageSection>

<CPPSection>


```cpp
#include <bits/stdc++.h> // see /general/running-code-locally
using namespace std;

using ll = long long;

using vi = vector<int>;
#define pb push_back
#define all(x) begin(x), end(x)
#define sz(x) (int)(x).size()

using pi = pair<int,int>;
#define f first
#define s second
#define mp make_pair

void setIO(string name = "") {
	cin.tie(0)->sync_with_stdio(0); // see /general/fast-io
	if (sz(name)) {
		freopen((name+".in").c_str(), "r", stdin); // see /general/io
		freopen((name+".out").c_str(), "w", stdout);
	}
}


int main() {
	setIO();
	int n, t, ans = 0;
	cin >> n >> t;
	vi books(n);
	for(int i = 0; i < n; i++){
		cin >> books[i];
	}

	int left = 0, right = 0, cur = 0;
	while(left < n && right < n) {
		while(right < n) {
			cur += books[right++];
			if(cur > t) {
				cur -= books[--right]; 
				break;
			}
		}

		ans = max(ans, right - left);
		cur -= books[left++];
	}

	cout << ans;
}
```

</CPPSection>

<JavaSection>

```java
import java.util.*;
import java.io.*;

public class Books {
	public static void main(String[] args) {
		Kattio io = new Kattio();

		int n = io.nextInt();
		int t = io.nextInt();

		int[] books = new int[n];

		for(int i = 0; i < n; i++) {
			books[i] = io.nextInt();
		}

		int left = 0, right = 0, cur = 0, ans = 0;
		while(left < n && right < n) {
			while(right < n) {
				cur += books[right++];
				if(cur > t) {
					cur -= books[--right]; 
					break;
				}
			}

			ans = Math.max(ans, right - left);
			cur -= books[left++];
		}

		io.println(ans);
		io.close();
	}

	CodeSnip{Kattio}
}
```

</JavaSection>

</LanguageSection>

## Problems

<Problems problems="ad" />
