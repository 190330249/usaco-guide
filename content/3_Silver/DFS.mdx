---
id: dfs
title: Depth First Search (DFS)
author: Siyong Huang
prerequisites: 
 - intro-graphs
description: "A way to recursively traverse a graph."
frequency: 4
---

import { Problem } from "../models";

export const problems = {
    sample: [
      new Problem("CSES", "Building Roads", "1666", "Intro|Easy", false, ["DFS"]),
    ],
    general: [
      new Problem("CF", "Bear & Friendship", "problemset/problem/771/A", "Easy", false, ["DFS"]),
      new Problem("Silver", "Closing the Farm", "644", "Easy", false, ["DFS"]),
      new Problem("Silver", "Moocast", "668", "Easy", false, ["DFS"]),
      new Problem("Silver", "Fence Planning", "944", "Easy", false, ["DFS"]),
      new Problem("Kattis", "Birthday Party", "birthday", "Easy", false, ["DFS"], "DFS with each edge removed"),
      new Problem("Silver", "Mootube", "788", "Easy", false, ["Tree", "DFS"]),
      new Problem("CF", "PolandBall & Forest", "problemset/problem/755/C", "Easy", false, ["Tree", "DFS"]),
      new Problem("Silver", "Milk Visits", "968", "Normal", false, ["DFS"]),
      new Problem("Silver", "Wormhole Sort", "992", "Normal", false, ["DFS", "Binary Search"]),
      new Problem("Silver", "Moo Particle", "1040", "Normal", false, ["Sorting"]),
      new Problem("Gold", "Moocast", "669", "Normal", false, [], ""),
    ],
    tree: [
      new Problem("CSES", "Subordinates", "1674", "Very Easy", false, ["Tree", "DFS"]),
      new Problem("CF", "Journey", "contest/839/problem/C", "Easy", false, ["Tree", "DFS"]),
      new Problem("CSES", "Tree Diameter", "1131", "Normal", false, ["Tree", "DFS"]),
      new Problem("CSES", "Tree Distances I", "1132", "Normal", false, ["Tree", "DFS"]),
      new Problem("CSES", "Tree Distances II", "1133", "Normal", false, ["Tree", "DFS"]),
      new Problem("CF", "Wizard's Tour", "contest/860/problem/D", "Normal", false, ["Tree", "DFS"]),
      new Problem("POI", "Hotels", "https://szkopul.edu.pl/problemset/problem/gDw3iFkeVm7ZA3j_16-XR7jI/site/?key=statement", "Normal", false, ["Tree", "DFS"]),
      new Problem("HE", "Birthday Gifts", "https://www.hackerearth.com/practice/math/combinatorics/inclusion-exclusion/practice-problems/algorithm/mancunian-and-birthday-gifts-d44faa15/description/", "Normal", false, ["Tree", "PIE"], ""),
      new Problem("Gold", "Cow At Large", "790", "Hard", false, [], ""),
    ],
    bipsample: [
      new Problem("CSES", "Building Teams", "1668", "Easy", false, ["Bipartite"]),
    ],    
    bip: [
      new Problem("CF", "Bipartiteness", "contest/862/problem/B", "Easy", false, ["Bipartite"]),
      new Problem("Silver", "The Great Revegetation", "920", "Easy", false, ["Bipartite"]),
      new Problem("Silver", "Clock Tree", "1016", "Hard", false, []),
      new Problem("CF", "BOI - Graph", "contest/1387/problem/A", "Hard", false, [], ""),
	  new Problem("DMOJ", "APIO - Table Coloring", "apio11p1", "Insane", false, [], "apio-11-color"),
    ],
};

<!-- new Problem("CSA", "Tree Reconstruction", "tree-construct", "Hard", false, ["Tree", "DFS"], "several cases"), 

not a good example
-->

## Resources

<Resources>
  <Resource source="CPH" title="12.1 - DFS, 14 - Tree algorithms" starred></Resource>
  <Resource source="CSA" title="Depth First Search" url="depth_first_search" starred>interactive</Resource>
  <Resource source="IUSACO" title="10.4 - Graph Traversal Algorithms"></Resource>
  <Resource source="PAPS" title="12.2 - Depth-First Search">with an example problem</Resource>
  <Resource source="CPC" title="7 - Graphs 1" url="07_graphs_1">fast-paced</Resource>
  <Resource source="cp-algo" title="Depth First Search" url="graph/depth-first-search.html">hard to parse for a beginner</Resource>
  <Resource source="TC" title="Graphs Section 2" url="introduction-to-graphs-and-their-data-structures-section-2"></Resource>
</Resources>

## Counting Connected Components

A **Connected Component** is a maximal set of connected nodes.
In other words, two nodes are in the same connected component *if and only if* they can reach each other via edges in the graph.

<Problems problems={problems.sample} />

The goal of this problem is to add edges such that the entire graph is a single connected component.
Note that each edge can connect at most two connected components, reducing the overall count by one.
Since this is always possible, you must add $N-1$ edges.
In order to solve the second part of the solution, notice that connecting any two nodes in two connected components is sufficient -- this lends itself to many solutions.
For example, pick a representative from each component and link them together in a line. 

<!-- You don't want to add an edge between two nodes that are already connected. If you have N connected components (some of the resources should go over what those are), then adding an edge reduces it to N - 1 connected components. Everything is connected when there's 1 connected component. So the answer is (# connected components - 1). -->

### Sample Implementation

<!-- Iterate through each node. If it has not been visited, visit it and all other nodes in its component. The number of times we perform the visiting operation is the number of connected components. -->

<LanguageSection>

<CPPSection>

<!-- Tested on CSES -->

```cpp
#include <cstdio>
#include <vector>

const int MN = 1e5+10;

int N, M, ans, rep[MN];
std::vector<int> adj_list[MN];
bool visited[MN];

void dfs(int node)
{
	visited[node] = true;
	for(int u:adj_list[node])
		if(!visited[u])
			dfs(u);
}
int count_components()
{
	int count=0;
	for(int i=1;i<=N;++i)
		if(!visited[i])
		{
			rep[count++]=i;
			dfs(i);
		}
	return count;
}

int main()
{
	scanf("%d%d", &N, &M);
	for(int i=0,u,v;i<M;++i)
		scanf("%d%d", &u, &v), adj_list[u].push_back(v), adj_list[v].push_back(u);
	ans = count_components();
	printf("%d\n", ans-1);
	for(int i=1;i<ans;++i)
		printf("%d %d\n", rep[i-1], rep[i]);
	return 0;
}
```

</CPPSection>

<JavaSection>

```java
import java.io.*;
import java.util.*;

public class BuildingRoads
{
	static InputReader in = new InputReader(System.in); //Check Intro/IO
	static PrintWriter out = new PrintWriter(System.out);

	public static final int MN = 100010, MM = 200020;

	static int N, M, ans;
	static int[] rep = new int[MN], hd = new int[MN], nx = new int[MM*2], to = new int[MM*2];
	//Sorry about using chinese edge representation. Normal adjacency list exceeds time limit.
	static boolean[] visited = new boolean[MN];

	public static void adde(int u, int v, int id)
	{
		nx[id] = hd[u];
		hd[u] = id;
		to[id] = v;
	}
	public static void dfs(int node)
	{
		visited[node] = true;
		for(int id=hd[node], u;id!=-1;id=nx[id])
		{
			u=to[id];
			if(!visited[u])
				dfs(u);
		}
	}
	public static int count_components()
	{
		int count=0;
		for(int i=1;i<=N;++i)
			if(!visited[i])
			{
				rep[count++]=i;
				dfs(i);
			}
		return count;
	}

	public static void main(String... args)
	{
		N=in.nextInt();
		M=in.nextInt();
		for(int i=1;i<=N;++i) hd[i]=-1;
		for(int i=0,u,v;i<M;++i)
		{
			u = in.nextInt();
			v = in.nextInt();
			adde(u, v, i*2);
			adde(v, u, i*2+1);
		}
		ans = count_components();
		out.println(ans-1);
		for(int i=1;i<ans;++i)
			out.println(rep[i-1] + " " + rep[i]);
		out.close();
	}
}
```

</JavaSection>

</LanguageSection>


### Problems

<Problems problems={problems.general} />

## Tree Problems

### Implementation

Trees are generally treated very differently from general graph problems.
Typically, after arbitrarily rooting a tree, some interesting pieces of information are a node's parent, subtree size, and depth.
The implementation below computes those numbers.

<LanguageSection>

<CPPSection>

```cpp
#include <cstdio>
#include <vector>

const int MN = 2e5+10;

int N, p[MN], s[MN];
std::vector<int> a[MN];
void dfs(int node)
{
	s[node]=1;
	for(int u:a[node])
		dfs(u), s[node]+=s[u];
}
int main()
{
	scanf("%d", &N);
	for(int i=2;i<=N;++i)
		scanf("%d", p+i), a[p[i]].push_back(i);
	dfs(1);
	for(int i=1;i<=N;++i)
		printf("%d%c", s[i]-1, " \n"[i==N]);
	return 0;
}
```

</CPPSection>

<JavaSection>

```java
import java.io.*;
import java.util.*;

public class Subordinates
{
	static InputReader in = new InputReader(System.in);
	static PrintWriter out = new PrintWriter(System.out);

	public static final int MN = 200020;

	static int N, M, ans;
	static int[] hd = new int[MN], nx = new int[MN], to = new int[MN], s = new int[MN], p = new int[MN];

	public static void adde(int u, int v, int id)
	{
		nx[id] = hd[u];
		hd[u] = id;
		to[id] = v;
	}
	public static void dfs(int node)
	{
		s[node]=1;
		for(int id=hd[node];id!=0;id=nx[id])
		{
			dfs(to[id]);
			s[node]+=s[to[id]];
		}
	}
	public static void main(String... args)
	{
		N=in.nextInt();
		for(int i=2;i<=N;++i)
		{
			p[i]=in.nextInt();
			adde(p[i], i, i);
		}
		dfs(1);
		for(int i=1;i<=N;++i)
		{
			out.print(s[i]-1);
			if(i<N) out.print(" ");
			else out.println();
		}
		out.close();
	}
}
```

</JavaSection>

</LanguageSection>

<IncompleteSection />

### Problems

<Problems problems={problems.tree} />

## Graph Two-Coloring

*Graph two-coloring* refers to assigning a boolean value to each node of the graph, dictated by the edge configuration.
The most common example of a two-colored graph is a *bipartite graph*, in which each edge connects two nodes of opposite colors.

<Problems problems={problems.bipsample} />

### Resources

<Resources>
  <Resource source="IUSACO" title="10.7 - Bipartite Graphs" starred></Resource>
  <Resource source="CPH" title="12.3 - Graph Traversal: Applications"></Resource>
  <Resource source="cp-algo" title="Bipartite Check" url="graph/bipartite-check.html">Uses BFS, but DFS accomplishes the same task.</Resource>
</Resources>
 

### Implementation

The idea is that we can arbitrarily label a node and then run DFS. Every time we visit a new (unvisited) node, we set its color based on the edge rule. When we visit a previously visited node, check to see whether its color matches the edge rule. For example, an implementation of coloring a bipartite graph is shown below.

<LanguageSection>

<CPPSection>

```cpp
//UNTESTED
bool is_bipartite = true;
void dfs(int node)
{
	visited[node] = true;
	for(int u:adj_list[node])
		if(visited[u])
		{
			if(color[u] == color[node])
				is_bipartite = false;
		}
		else
		{
			color[u] = !color[node];
			dfs(u);
		}
}
```

</CPPSection>

<JavaSection>

```java
//UNTESTED
boolean is_bipartite = true;
public static void dfs(int node)
{
	visited[node] = true;
	for(int u:adj_list[node])
		if(visited[u])
		{
			if(color[u] == color[node])
				is_bipartite = false;
		}
		else
		{
			color[u] = !color[node];
			dfs(u);
		}
}
```

</JavaSection>

</LanguageSection>

### Problems

<Problems problems={problems.bip} />
