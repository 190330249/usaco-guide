---
id: dynamic-seg
title: Sparse and Persistent Segment Trees
author: Andi Qu
prerequisites:
  - PURS
description: Range queries on big ranges
frequency: 1
---

import { Problem } from '../models';

export const problems = {
	sparseSample: new Problem(
		'IZhO',
		'2012 - Monkey and Apple-trees',
		'https://oj.uz/problem/view/IZhO12_apple',
		'Easy',
		false,
		[],
		''
	),
	sparseGeneral: [
		new Problem(
			'IOI',
			'2005 - Mountain',
			'https://dmoj.ca/problem/ioi05p3',
			'Easy',
			false,
			[],
			''
		),
		new Problem(
			'Balkan OI',
			'2015 - Happiness',
			'https://oj.uz/problem/view/Balkan15_HAPPINESS',
			'Normal',
			true,
			[],
			''
		),
		new Problem(
			'Plat',
			'Mowing the Field',
			'http://www.usaco.org/index.php?page=viewproblem2&cpid=601',
			'Hard',
			true,
			[],
			''
		),
	],
	persistentSample: new Problem(
		'CSES',
		'Range Queries and Copies',
		'1737',
		'Easy',
		false,
		[],
		''
	),
	persistentGeneral: [
		new Problem(
			'APIO',
			'2019 - Street Lights',
			'https://oj.uz/problem/view/APIO19_street_lamps',
			'Very Hard',
			false,
			[],
			''
		),
	],
};

## Sparse Segment Trees

In problems where the query range is at most something like $10^6$, a normal segment tree suffices. However, as soon as we move to bigger ranges ($10^{12}$ in some cases), a normal segment tree results in MLE.

Luckily, we can still use a segment tree to solve these types of problems.

The main idea is that we don't have to store all the nodes at all times - we create nodes only when needed. In a normal segment tree, an update only affects $O(\log N)$ nodes, so in a sparse segment tree, we only store $O(Q \log N)$ nodes!

We can implement this efficiently using pointers to a node's children - just like a trie! (Then again, a segment tree is basically a fancier binary trie.)

<Resources>
	<Resource
		source="Benq"
		url="https://github.com/bqi343/USACO/blob/master/Implementations/content/data-structures/1D%20Range%20Queries%20(9.2)/SparseSeg%20(9.2).h"
		title="Implementation"
	/>
</Resources>

### Example Problem

<FocusProblem problem={problems.sparseSample} />

We need to support two operations on a range:

- Count the number of red-ripe trees in a range (range sum)
- Set all trees in a range to red-ripe (range paint)

We can use a segment tree with lazy propagation to solve this, but the query range is up to $10^9$, so we have to use a sparse segment tree.

Luckily, lazy propagation still works here.

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
#pragma GCC optimize("O3")
#define FOR(i, x, y) for (int i = x; i < y; i++)
#define MOD 1000000007
typedef long long ll;
using namespace std;

struct Node {
    int sum, lazy, tl, tr, l, r;
    Node() : sum(0), lazy(0), l(-1), r(-1) {}
};

const int MAXN = 123456;
Node segtree[64 * MAXN];
int cnt = 2;

void push_lazy(int node) {
    if (segtree[node].lazy) {
        segtree[node].sum = segtree[node].tr - segtree[node].tl + 1;
        int mid = (segtree[node].tl + segtree[node].tr) / 2;
        if (segtree[node].l == -1) {
            segtree[node].l = cnt++;
            segtree[segtree[node].l].tl = segtree[node].tl;
            segtree[segtree[node].l].tr = mid;
        }
        if (segtree[node].r == -1) {
            segtree[node].r = cnt++;
            segtree[segtree[node].r].tl = mid + 1;
            segtree[segtree[node].r].tr = segtree[node].tr;
        }
        segtree[segtree[node].l].lazy = segtree[segtree[node].r].lazy = 1;
        segtree[node].lazy = 0;
    }
}

void update(int node, int l, int r) {
    push_lazy(node);
    if (l == segtree[node].tl && r == segtree[node].tr) {
        segtree[node].lazy = 1;
        push_lazy(node);
    } else {
        int mid = (segtree[node].tl + segtree[node].tr) / 2;
        if (segtree[node].l == -1) {
            segtree[node].l = cnt++;
            segtree[segtree[node].l].tl = segtree[node].tl;
            segtree[segtree[node].l].tr = mid;
        }
        if (segtree[node].r == -1) {
            segtree[node].r = cnt++;
            segtree[segtree[node].r].tl = mid + 1;
            segtree[segtree[node].r].tr = segtree[node].tr;
        }

        if (l > mid) update(segtree[node].r, l, r);
        else if (r <= mid) update(segtree[node].l, l, r);
        else {
            update(segtree[node].l, l, mid);
            update(segtree[node].r, mid + 1, r);
        }

        push_lazy(segtree[node].l);
        push_lazy(segtree[node].r);
        segtree[node].sum = segtree[segtree[node].l].sum + segtree[segtree[node].r].sum;
    }
}

int query(int node, int l, int r) {
    push_lazy(node);
    if (l == segtree[node].tl && r == segtree[node].tr) return segtree[node].sum;
    else {
        int mid = (segtree[node].tl + segtree[node].tr) / 2;
        if (segtree[node].l == -1) {
            segtree[node].l = cnt++;
            segtree[segtree[node].l].tl = segtree[node].tl;
            segtree[segtree[node].l].tr = mid;
        }
        if (segtree[node].r == -1) {
            segtree[node].r = cnt++;
            segtree[segtree[node].r].tl = mid + 1;
            segtree[segtree[node].r].tr = segtree[node].tr;
        }

        if (l > mid) return query(segtree[node].r, l, r);
        else if (r <= mid) return query(segtree[node].l, l, r);
        else return query(segtree[node].l, l, mid) + query(segtree[node].r, mid + 1, r);
    }
}

int main() {
    iostream::sync_with_stdio(false);
    cin.tie(0);
    int m;
    cin >> m;

    segtree[1].sum = 0; segtree[1].lazy = 0;
    segtree[1].tl = 1; segtree[1].tr = 1e9;

    int c = 0;
    FOR(_, 0, m) {
        int d, x, y;
        cin >> d >> x >> y;
        if (d == 1) {
            c = query(1, x + c, y + c);
            cout << c << '\n';
        } else update(1, x + c, y + c);
    }
    return 0;
}
```

</CPPSection>

</LanguageSection>

### Problems

<Problems problems={problems.sparseGeneral} />

## Persistent Segment Trees

Persistent segment trees are very similar to sparse segment trees in the sense that we store child pointers. The key differences are that we have multiple roots and every time we "update" a node, we actually create a new node in its place (hence persistence).

A nice thing about persistent segment trees is that they can be used for 2D static range sum queries (think about it like prefix sums). (It's probably better to use a 2D BIT instead though.)

<IncompleteSection />

### Example Problem

<FocusProblem problem={problems.persistentSample} />

<IncompleteSection />

<LanguageSection>

<CPPSection>

```cpp
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;

struct Node {
    ll val;
    Node *l, *r;

    Node(ll x) : val(x), l(nullptr), r(nullptr) {}
    Node(Node *ll, Node *rr) {
        l = ll, r = rr;
        val = 0;
        if (l) val += l->val;
        if (r) val += r->val;
    }
    Node(Node *cp) : val(cp->val), l(cp->l), r(cp->r) {}
};

int n, cnt = 1;
ll a[200001];
Node* roots[200001];

Node* build(int l = 1, int r = n) {
    if (l == r) return new Node(a[l]);
    int mid = (l + r) / 2;
    return new Node(build(l, mid), build(mid + 1, r));
}

Node* update(Node* node, int val, int pos, int l = 1, int r = n) {
    if (l == r) return new Node(val);
    int mid = (l + r) / 2;
    if (pos > mid) return new Node(node->l, update(node->r, val, pos, mid + 1, r));
    else return new Node(update(node->l, val, pos, l, mid), node->r);
}

ll query(Node* node, int a, int b, int l = 1, int r = n) {
    if (l > b || r < a) return 0;
    if (l >= a && r <= b) return node->val;
    int mid = (l + r) / 2;
    return query(node->l, a, b, l, mid) + query(node->r, a, b, mid + 1, r);
}

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    int q;
    cin >> n >> q;
    for (int i = 1; i <= n; i++) cin >> a[i];
    roots[cnt++] = build();

    while (q--) {
        int t;
        cin >> t;
        if (t == 1) {
            int k, i, x;
            cin >> k >> i >> x;
            roots[k] = update(roots[k], x, i);
        } else if (t == 2) {
            int k, l, r;
            cin >> k >> l >> r;
            cout << query(roots[k], l, r) << '\n';
        } else {
            int k;
            cin >> k;
            roots[cnt++] = new Node(roots[k]);
        }
    }
    return 0;
}
```

</CPPSection>

</LanguageSection>

### Problems

<IncompleteSection />
