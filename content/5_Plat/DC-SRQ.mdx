---
id: DC-SRQ
title: 'Divide & Conquer - Static Range Queries'
author: Benjamin Qi, Andi Qu
description: '?'
frequency: 1
---

import { Problem } from '../models';

export const problems = {
	diviSample: [
		new Problem('JOI', 'Secret', 'JOI14_secret', 'Easy', false, [], ''),
	],
	general: [
		new Problem('CC', 'Product on Segment', 'SEGPROD', 'Easy', false, [], ''),
		new Problem(
			'Baltic OI',
			'2017 - Toll',
			'https://oj.uz/problem/view/BOI17_toll',
			'Normal',
			false,
			[],
			'baltic-17-toll'
		),
		new Problem(
			'DMOJ',
			'Continued Fractions',
			'dmopc19c7p4',
			'Normal',
			false,
			[],
			''
		),
		new Problem(
			'Plat',
			'Non-Decreasing Subsequences',
			'997',
			'Hard',
			false,
			[],
			''
		),
	],
};

## Static Array Queries

<FocusProblem problem={problems.diviSample[0]} />

Given a static array $A[1],A[2],\ldots,A[N]$, you want to answer queries in the form

$$
A[l]\ominus A[l+1]\ominus \cdots \ominus A[r]
$$

where $\ominus$ denotes an associative operation. 

[Previously](/gold/tree-euler#range-minimum-query), it was shown that we can get $O(1)$ time queries with $O(N\log N)$ time preprocessing when $\ominus$ denotes `min`. But what about other associative operations?

## Using Divide & Conquer

We can use **divide & conquer** to answer $Q$ queries offline in $O((N+Q)\log N)$ time.

Suppose that all queries satisfy $L\le l\le r\le R$ (initially, $L=1$ and $R=N$). Letting $M=\left\lfloor \frac{L+R}{2}\right\rfloor$, we can compute

$$
lef[l]=A[l]\ominus A[l+1]\ominus \cdots \ominus A[M]
$$

for all $L\le l\le M$ and

$$
rig[r]=A[M+1]\ominus A[M+2] \ominus \cdots\ominus A[r]
$$

for each $M< r\le R$. Then the answer for all queries satisfying $l\le M< r$ is simply $lef[l]\ominus rig[r]$ due to the associativity condition. After that, we recurse on all query intervals completely contained within $[L,M]$ and $[M+1,R]$ independently.

### Online Queries

Preprocess using $O(N\log N)$ memory. 

<Resources>
	<Resource source="Benq" url="https://github.com/bqi343/USACO/blob/master/Implementations/content/data-structures/Static%20Range%20Queries%20(9.1)/RangeQuery.h" title="RangeQuery">implementation</Resource>
</Resources>

<Optional title="Faster Preprocessing">

A data structure known as **sqrt-tree** can speed up preprocessing time and memory to $O(N\log \log N)$ (with $O(1)$ time online queries).

- [CF Blog Pt 1](http://codeforces.com/blog/entry/57046)
- [CF Blog Pt 2](http://codeforces.com/blog/entry/59092)

</Optional>

## Solution - Secret

```cpp
#include "secret.h"

int prefix[1000][1000], n;

void populate(int L, int R, int A[]) {
    int mid = (L + R) / 2;
    prefix[mid][mid] = A[mid];
    prefix[mid + 1][mid + 1] = A[mid + 1];

    for (int i = mid + 2; i <= R; i++)
		prefix[mid + 1][i] = Secret(prefix[mid + 1][i - 1], A[i]);
    for (int i = mid - 1; i >= L; i--)
		prefix[mid][i] = Secret(A[i], prefix[mid][i + 1]);

    if (L < mid) populate(L, mid, A);
    if (mid + 1 < R) populate(mid + 1, R, A);
}

void Init(int N, int A[]) {
    n = N;
    populate(0, N - 1, A);
}

int Query(int L, int R) {
    int a = 0, b = n - 1;

    while (a != b) {
        int mid = (a + b) / 2;
        if (mid >= L && mid < R)
			return Secret(prefix[mid][L], prefix[mid + 1][R]);
        else if (mid == R) return prefix[mid][L];
        else if (mid < L) a = mid + 1;
        else b = mid;
    }

    return prefix[a][a];
}
```

## Problems

<Problems problems={problems.general} />