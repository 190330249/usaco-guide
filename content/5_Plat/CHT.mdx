---
id: cht
title: 'Convex Hull Trick'
author: Benjamin Qi, Andi Qu
description: A way to find the maximum or minimum value of several convex functions at given points.
prerequisites:
  - convex-hull
frequency: 2
---

import { Problem } from '../models';

export const problems = {
	sample: [
		new Problem(
			'CEOI',
			'2017 - Building Bridges',
			'https://oj.uz/problem/view/CEOI17_building',
			'Normal',
			false,
			['DP', 'convex'],
			'@Later'
		),
		new Problem(
			'CF',
			'The Fair Nut and Rectangles',
			'contest/1083/problem/E',
			'Easy',
			false,
			['DP', 'convex'],
			'@Later'
		),
	],
	cht: [
		new Problem(
			'APIO',
			'2010 - Commando',
			'https://dmoj.ca/problem/apio10p1',
			'Easy',
			false,
			['DP', 'convex'],
			'http://apio-olympiad.org/2010/solutions.pdf'
		),
		new Problem(
			'CEOI',
			'2004 - Two Sawmills',
			'https://szkopul.edu.pl/problemset/problem/ovRIpLFK3IhyFPjnVXeZtGxH/site/?key=statement',
			'Easy',
			false,
			['DP', 'convex'],
			''
		),
		new Problem(
			'IOI',
			'2002 - Batch Scheduling',
			'https://wcipeg.com/problem/ioi0221',
			'Easy',
			false,
			['DP', 'convex'],
			'http://www.ioi2002.or.kr/eng/tasks/batch-handout.pdf'
		),
		new Problem(
			'POI',
			'2011 - Lightning Conductor',
			'https://szkopul.edu.pl/problemset/problem/iYVwsAcHHCRZzAtQh0QFKbsu/site/',
			'Normal',
			false,
			['DP', 'convex'],
			''
		),
		new Problem(
			'APIO',
			'2014 - Split the Sequence',
			'https://oj.uz/problem/view/APIO14_sequence',
			'Normal',
			false,
			['DP', 'convex'],
			'apio-14-sequence'
		),
		new Problem(
			'POI',
			'2014 - Supercomputer',
			'https://szkopul.edu.pl/problemset/problem/e9ycK_efBDBt4aPs-QeqYpwR/site/',
			'Normal',
			false,
			['DP', 'convex'],
			''
		),
		new Problem(
			'CEOI',
			'2009 - Harbingers',
			'https://oj.uz/problem/view/CEOI09_harbingers',
			'Hard',
			false,
			['DP', 'convex'],
			'http://infosb.net/ceoi2009/tasks/solutions.doc'
		),
		new Problem(
			'Plat',
			'Circular Barn',
			'626',
			'Hard',
			false,
			['DP', 'convex'],
			''
		),
		new Problem(
			'POI',
			'2006 - Frogs',
			'https://szkopul.edu.pl/problemset/problem/HH7LQVRVHom1g8YRe9423d1P/site/',
			'Hard',
			false,
			['DP', 'convex'],
			''
		),
		new Problem(
			'JOI',
			'2017 - Long-Distance Coach',
			'https://oj.uz/problem/view/JOI17_coach',
			'Very Hard',
			false,
			['DP', 'convex'],
			''
		),
		new Problem(
			'Plat',
			'Falling Portals',
			'998',
			'Very Hard',
			false,
			['convex'],
			''
		),
	],
};

## Introduction

Convex Hull Trick (CHT) problems are usually of the following form:

> Given several **convex** functions $f_i(x)$ such that **any two functions intersect at most once**, answer $Q$ queries of the form "what is the maximum $f_i(x)$ for some given x?".

Examples of such functions include:

- The straight line ($y = mx + c$)
- The parabola ($y = ax^2 + bx + c$)
- The square-root function ($y = \sqrt{x - a} + b$)

There are several data structures one can use to solve these problems efficiently.

### Tutorials

<Resources>
	<Resource
		source="cp-algo"
		title="Convex Hull Trick"
		url="geometry/convex_hull_trick.html"
		starred
	>
		Also introduces the Li-Chao tree
	</Resource>
	<Resource
		source="CF"
		title="Convex Hull Trick - Geo Being Useful"
		url="63823"
		starred
	>
		{' '}
	</Resource>
	<Resource source="GCP" title="15.4.1 - Convex Hull Trick">
		{' '}
	</Resource>
	<Resource
		source="Jeffrey Xiao"
		title="Convex Hull Trick"
		url="https://jeffreyxiao.me/blog/convex-hull-trick"
	>
		Introduces the O(N) CHT for specific conditions
	</Resource>
</Resources>

## $O(N \log N)$ CHT

<FocusProblem problem={problems.sample[0]} />

### Analysis

Instead of focusing on the pillars that should be destroyed, let's instead focus on the pillars that remain.

The total cost consists of the cost due to height differences plus the cost of destroying unused pillars. The latter cost is equal to the cost to destroy all pillars minus the cost to destroy the remaining pillars.

Since the cost to destroy all pillars is constant, we can thus turn the problem into one about building pillars instead of destroying them!

From this, we get a basic DP recurrence. Let $dp[i]$ be the minimum cost to build the bridge so that the last build pillar is pillar $i$.

$dp[1] = -w_1$ and the following recurrence holds:

$$
\begin{aligned}
	dp[i] &= \min_{j < i}(dp[j] + (h_j - h_i)^2 - w_i)\\
		  &= \min_{j < i}(dp[j] + h_j^2 - 2h_ih_j) + h_i^2 - w_i
\end{aligned}
$$

Notice how

$$
dp[j] + h_j^2 - 2h_ih_j
$$

effectively describes a linear function $y = mx + c$, where $m = -2h_j$, $x = h_i$, and $c = dp[j] + h_j^2$

This means that we can use CHT to compute $dp[i]$ efficiently!

However, since $m$ is not monotonic, we can't use linear CHT using a deque, so we must settle with $O(N \log N)$.

<Spoiler title="Code">

I implemented CHT using a `std::set` here, but other implementations using things like the Li-Chao tree should work similarly.

```cpp
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;

struct Line {
    bool type;
    double x;
    ll m, c;
};

bool operator<(Line l1, Line l2) {
    if (l1.type || l2.type) return l1.x < l2.x;
    return l1.m > l2.m;
}

set<Line> cht;
ll h[100001], w[100001], tot = 0, dp[100001];

bool has_prev(set<Line>::iterator it) {
    return it != cht.begin();
}
bool has_next(set<Line>::iterator it) {
    return it != cht.end() && next(it) != cht.end();
}

double intersect(set<Line>::iterator l1, set<Line>::iterator l2) {
    return (double)(l1->c - l2->c) / (l2->m - l1->m);
}

void calc_x(set<Line>::iterator it) {
    if (has_prev(it)) {
        Line l = *it;
        l.x = intersect(prev(it), it);
        cht.insert(cht.erase(it), l);
    }
}

bool bad(set<Line>::iterator it) {
    if (has_next(it) && next(it)->c <= it->c) return true;
    return (has_prev(it) && has_next(it) &&
            intersect(prev(it), next(it)) <= intersect(prev(it), it));
}

void add_line(ll m, ll c) {
    set<Line>::iterator it;

    it = cht.lower_bound({0, 0, m, c});
    if (it != cht.end() && it->m == m) {
        if (it->c <= c) return;
		cht.erase(it);
    }

    it = cht.insert({0, 0, m, c}).first;
    if (bad(it)) cht.erase(it);
    else {
        while (has_prev(it) && bad(prev(it))) cht.erase(prev(it));
        while (has_next(it) && bad(next(it))) cht.erase(next(it));

        if (has_next(it)) calc_x(next(it));
        calc_x(it);
    }
}

ll query(ll h) {
    Line l = *prev(cht.upper_bound({1, (double)h, 0, 0}));
    return l.m * h + l.c;
}

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0);
    int n;
    cin >> n;
    for (int i = 1; i <= n; i++) cin >> h[i];
    for (int i = 1; i <= n; i++) {
        cin >> w[i];
        tot += w[i];
    }

    dp[1] = -w[1];
    for (int i = 2; i <= n; i++) {
        add_line(-2 * h[i - 1], dp[i - 1] + h[i - 1] * h[i - 1]);
        dp[i] = query(h[i]) - w[i] + h[i] * h[i];
    }

    cout << tot + dp[n];
    return 0;
}
```

</Spoiler>

## $O(N)$ CHT

<FocusProblem problem={problems.sample[1]} />

<IncompleteSection>Analysis of the problem</IncompleteSection>

<Spoiler title="Code">

```cpp
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;

struct Rect {
    ll x, y, a;
    bool operator<(Rect B) { return x < B.x; }
};

Rect a[1000001];
ll dp[1000001];

double slope(int i, int j) { return (double)(dp[i] - dp[j]) / (a[i].x - a[j].x); }

int main() {
    iostream::sync_with_stdio(false);
    cin.tie(0);
    ll n;
    cin >> n;
    for (int i = 1; i <= n; i++) {
        cin >> a[i].x >> a[i].y >> a[i].a;
    }
    sort(a + 1, a + n + 1);

    deque<ll> q;
    q.push_back(0);
    for (int i = 1; i <= n; i++) {
        while (q.size() > 1 && slope(q[0], q[1]) >= a[i].y) q.pop_front();

        ll j = q.front();
        dp[i] = max(dp[i - 1], a[i].x * a[i].y - a[i].a + dp[j] - a[j].x * a[i].y);

        while (q.size() > 1 && slope(q[q.size() - 2], q.back()) <= slope(q.back(), i)) q.pop_back();
        q.push_back(i);
    }

    cout << dp[n];
    return 0;
}
```

</Spoiler>

## Problems

<Problems problems={problems.cht} />
