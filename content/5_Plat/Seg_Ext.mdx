---
id: seg-ext
title: 'More Applications of Segment Tree'
author: Benjamin Qi, Andi Qu
prerequisites:
  - PURS
description: Pushing the limits of what a segment tree can do.
frequency: 3
---

import { Problem } from '../models';

export const problems = {
	walkSam: [
		new Problem('CSES', 'Hotel Queries', '1143', 'Easy', false, ['PURQ'], ''),
	],
	walk: [
		new Problem('Old Gold', 'Seating', '231', 'Normal', false, [], ''), // max segtree
		new Problem('Plat', 'Balancing', '624', 'Normal', false, [], ''),
	],
	combSam: [
		new Problem(
			'CSES',
			'Subarray Sum Queries',
			'1190',
			'Normal',
			false,
			['PURQ'],
			''
		),
	],
	comb: [
		new Problem('Old Gold', 'Marathon', '495', 'Easy', false, [], ''),
		new Problem(
			'Balkan OI',
			'Election',
			'https://oj.uz/problem/view/BOI18_election',
			'Easy',
			false,
			[],
			'balkan-18-election'
		),
		new Problem('Old Gold', 'Optimal Milking', '365', 'Normal', false, [], ''),
		new Problem(
			'POI',
			'Cards',
			'https://szkopul.edu.pl/problemset/problem/qpsk3ygf8MU7D_1Es0oc_xd8/site/?key=statement',
			'Normal',
			false,
			[],
			''
		),
		new Problem(
			'Plat',
			'High Card Low Card',
			'577',
			'Normal',
			false,
			['PURQ', 'Greedy'],
			''
		),
	],
	waveletSam: [
		new Problem(
			'YS',
			'Range K-th Smallest',
			'range_kth_smallest',
			'Normal',
			false,
			['Wavelet'],
			''
		),
	],
	wavelet: [
		new Problem(
			'Kattis',
			'Easy Query',
			'easyquery',
			'Hard',
			false,
			['Wavelet'],
			'easy-query'
		),
		new Problem(
			'DMOJ',
			"Ninjaclasher's Wrath 2",
			'globexcup19s4',
			'Hard',
			false,
			['Wavelet'],
			''
		),
	],
};

## Walking on a Segment Tree

<Problems problems={problems.walkSam} />

You want to support queries of the following form on an array $a_1,\ldots,a_N$ (along with point updates).

> Find the first $i$ such that $a_i\ge x$.

Of course, you can do this in $O(\log^2N)$ time with a max segment tree and binary searching on the first $i$ such that $\max(a_1,\ldots,a_i)\ge x$. But try to do this in $O(\log N)$ time.

### Solution - Hotel Queries

Instead of binary searching and querying the segment tree separately, let's do them together!

Assume that you know that the answer is in some range $[l, r]$. Let $mid = \left \lfloor{\frac{l + r}{2}}\right \rfloor$.

If $\max(a_l, \dots, a_{mid}) \geq x$, then we know that the answer is in the range $[l, mid]$. Otherwise, the answer is in the range $[mid + 1, r]$.

Imagine that the segment tree is a decision tree. We start at the root and move down. When we're at some node that contains $\max(a_l, \dots, a_r)$ and we know that the answer is in the range $[l, r]$, we move to the left child if $\max(a_l, \dots, a_{mid}) \geq x$; otherwise, we move to the right child.

This is convenient because $\max(a_l, \dots, a_{mid})$ is already stored in the left child, so we can find it in $O(1)$ time.

<Spoiler title="Code">

```cpp
#include <bits/stdc++.h>
using namespace std;

const int MAXN = 200001;

int n;
int segtree[4 * MAXN], a[MAXN];

void build(int l = 1, int r = n, int node = 1) {
    if (l == r) segtree[node] = a[l];
    else {
        int mid = (l + r) / 2;
        build(l, mid, node * 2);
        build(mid + 1, r, node * 2 + 1);
        segtree[node] = max(segtree[node * 2], segtree[node * 2 + 1]);
    }
}

void queryupdate(int val, int l = 1, int r = n, int node = 1) {
    if (l == r) {
        segtree[node] -= val;
        cout << l << ' ';
    } else {
        int mid = (l + r) / 2;
        if (segtree[node * 2] >= val) queryupdate(val, l, mid, node * 2);
        else queryupdate(val, mid + 1, r, node * 2 + 1);

        segtree[node] = max(segtree[node * 2], segtree[node * 2 + 1]);
    }
}

int main() {
    iostream::sync_with_stdio(false);
    cin.tie(0);
    int q;
    cin >> n >> q;
    for (int i = 1; i <= n; i++) cin >> a[i];
    build();

    while (q--) {
        int x;
        cin >> x;
        if (segtree[1] < x) cout << "0 ";
        else queryupdate(x);
    }
    return 0;
}
```

</Spoiler>

### Problems

<Problems problems={problems.walk} />

## Combining

<Problems problems={problems.combSam} />

### Solution - Subarray Sum Queries

In each node of the segment tree that stores information about the range $[l, r]$ we store the following information:

- The maximum subarray sum in the range $[l, r]$. (Let this be $G$)
- The maximum subarray sum in the range $[l, r]$ if it must contain $a_l$. (Let this be $L$)
- The maximum subarray sum in the range $[l, r]$ if it must contain $a_r$. (Let this be $R$)
- The total sum of the range. (Let this be $S$)

When we combine two nodes $u$ (left child) and $v$ (right child) to make node $w$,

- $w.G = \max(u.G, v.G, u.R + v.L)$
- $w.L = \max(u.L, u.S + v.L)$
- $w.R = \max(u.R + v.S, v.R)$
- $w.S = u.S + v.S$

We can thus handle updates and queries efficiently.

<Spoiler title="Code">

```cpp
#include <bits/stdc++.h>
typedef long long ll;
using namespace std;

const ll MAXN = 200001;

struct Node {
    ll g_max, l_max, r_max, sum;
    Node operator +(Node b) {
        return {
            max(max(g_max, b.g_max), r_max + b.l_max),
            max(l_max, sum + b.l_max),
            max(b.r_max, r_max + b.sum),
            sum + b.sum
        };
    }
};

ll n, a[MAXN];
Node segtree[4 * MAXN];

void build(ll l = 1, ll r = n, ll node = 1) {
    if (l == r) segtree[node] = {max(0ll, a[l]), max(0ll, a[l]), max(0ll, a[l]), a[l]};
    else {
        ll mid = (l + r) / 2;
        build(l, mid, node * 2);
        build(mid + 1, r, node * 2 + 1);
        segtree[node] = segtree[node * 2] + segtree[node * 2 + 1];
    }
}
void update(ll pos, ll val, ll l = 1, ll r = n, ll node = 1) {
    if (l == r) segtree[node] = {max(0ll, val), max(0ll, val), max(0ll, val), val};
    else {
        ll mid = (l + r) / 2;
        if (pos > mid) update(pos, val, mid + 1, r, node * 2 + 1);
        else update(pos, val, l, mid, node * 2);
        segtree[node] = segtree[node * 2] + segtree[node * 2 + 1];
    }
}

int main() {
    iostream::sync_with_stdio(false);
    cin.tie(0);
    ll q;
    cin >> n >> q;
    for (int i = 1; i <= n; i++) cin >> a[i];
    build();

    while (q--) {
        ll x, y;
        cin >> x >> y;
        update(x, y);
        cout << segtree[1].g_max << '\n';
    }
    return 0;
}
```

</Spoiler>

### Problems

<Problems problems={problems.comb} />

## Wavelet Tree

<Problems problems={problems.waveletSam} />

Like a segment tree on values rather than indices.

<Resources>
	<Resource source="CF" title="Intro to New DS: Wavelet Trees" url="52854">
		Link in blog post is broken, check my comment.
	</Resource>
</Resources>

### Solution - Range K-th Smallest

<IncompleteSection />

### Problems

<Problems problems={problems.wavelet} />
